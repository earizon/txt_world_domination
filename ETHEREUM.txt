● Apropos:
  For comments, requests and feedback feel free to open an issue or 
  open a Pull-Request:
@[https://github.com/earizon/txt_world_domination/blob/main/ETHEREUM.txt]


- Topics Acronyms:
  - PM  : Project Management
  - SLC : software life cycle
  - QA  : Quality Assurance. Everything realated to removing errors,
          passing unit/functional/acceptance tests, Service Level Agreements (SLAs), ...
  - 101 : (pronounced ONE-oh-ONE). Slang term for the most basic knowledge in
          some subject. @[https://en.wikipedia.org/wiki/101_(slang)]
  - EVM : Ethereum Virtual Machine.

● External Links
  @[https://github.com/ethereum/wiki/wiki/White-Paper]
  @[https://ethereum.github.io/yellowpaper/paper.pdf]
  @[https://solidity.readthedocs.io/]
  @[https://solidity.readthedocs.io/en/latest/resources.html] Solidity Resources
  @[https://github.com/ethereum/wiki/wiki/JSON-RPC]
  @[https://github.com/ethereum/wiki/wiki/Design-Rationale]
  @[https://theethereum.wiki/w/index.php/Main_Page]
  @[https://ethereum-magicians.org]

- Solidity top questions@ethereum.stackexchange.com
@[https://ethereum.stackexchange.com/questions/tagged/solidity?sort=votes&pageSize=15]
- Enterprise Ethereum Alliance Resources:
@[https://entethalliance.org/resources/]
- Curated list of libraries, auditing/secuirity tools, dev tools, security tutorial links,...
@[https://github.com/bkrem/awesome-solidity]
- Multipurspose Eth. Ontology:
@[https://media.consensys.net/ethon-introducing-semantic-ethereum-15f1f0696986]
 @[https://github.com/ConsenSys/EthOn/]
 @[https://ethon.consensys.net/statistics.html]
- EVM:
@[https://github.com/pirapira/awesome-ethereum-virtual-machine]
@[https://github.com/ethereum/go-ethereum/tree/master/core/vm]
@[https://github.com/xf00f/web3x/tree/master/web3x-evm] TypeScript implementation

- Lot of interesting repos related to Ethereum:
@[https://github.com/pirapira?utf8=%E2%9C%93&tab=repositories&q=&type=source]


● Who is Who:
  (Forcibly incomplete but still quite pertinent list of core developers and companies)
  - See also:
  @[https://medium.com/ethex-market/who-are-the-core-devs-of-ethereum-part-i-beb342aaaff0]

  - Vitalik Buterin, Ethereum White-Paper
    @[https://github.com/vbuterin]
    @[https://github.com/vbuterin/diagrams]

  - Gavin Wood: Ethereum Co-Founder
    Ethereum Yellow Paper
  @[http://gavwood.com/]
  @[https://en.wikipedia.org/wiki/Gavin_Wood]
   founder of Parity Technologies

  - Joseph Lubin:
    @[https://en.wikipedia.org/wiki/Joseph_Lubin_(entrepreneur)]
    founder of ConsenSys.

  - Shahan Khatchadourian
    - Pegasys Eng. Co-founder
    - Created Hyperledger Besu

  Co-founder@PegaSys

  - Anthony Diorio
    @[https://anthonydiiorio.ca/]
    In 2013, Anthony Diiorio funded, and along with Charles Hoskinson,
    Mihai Alisie, and Vitalik Buterin, co-founded the smart contract
    platform Ethereum.

  - Loredana Cirstea:
    Author of dType, seth.io, Pipeline remix plugin, ...
    @[https://github.com/loredanacirstea/articles]
    @[https://github.com/loredanacirstea?utf8=%E2%9C%93&tab=repositories&q=&type=source&language=]
    @[https://medium.com/@loredana.cirstea/dtype-decentralized-type-system-functional-programming-on-ethereum-4f7666377c9f]
    @[https://www.youtube.com/watch?v=GZg4L2o0Nyw&feature=youtu.be]

  - Nick Johnson "Arachnid":
    @[http://blog.notdot.net/]
    @[http://blog.notdot.net/tag/damn-cool-algorithms]
      - Arachnid Labs ("string utils")
    - Core developer on go-ethereum,
    - lead developer of ENS

  - Ronan Sandford (wighawag), prominent smart contract developer:
    - author of ERC-1155 standard
    - working on diamonds standards support in buidler-deploy.

  - Raul Jordan, Prysmatic labs: Sharding Protocol
    minimal sharding protocol implementation.

  - Rob Hitchens:
  @[https://medium.com/@robhitchens]
  @[https://about.me/hitchens]
    Distributed Applications Architect and Mentor in Calgary, Alberta, Canada
    Top poster on Ethereum Stack exchange since 2016.
    Co-author and mentor, Ethereum Developer, Hyperledger Fabric
    Developers, Quorum Developer, Hyperledger Sawtooth Lake Developer and
    Tezos Developer training at B9lab.com since 2017.
    Advisor and co-founder, Solidified.io, Ethereum smart contract
    quality assurance.
    - Author of Solidity CRUD:
    @[https://medium.com/@robhitchens/solidity-crud-part-1-824ffa69509a]

  - Nick Mudge: Designed the Diamon Standard (EIP 2535) for proxy-contracts

  - Anjan Roy @[https://github.com/itzmeanjan]
    Lead Blockchain Engineer @ Polygon ("Matic Network").


  - DApps and Solidity Development:
    - Manuel Araoz: @[https://maraoz.com/]:
      CTO&co-founder at Zeppelin.
    - Luis Cuende: @[http://blog.aragon.one/author/luis/]
      CEO and cofounder of Aragon One

    - b9lab: Quality Blockchain Education for everyone
    @[https://www.b9lab.com/]
      - Xavier Lepretre, senior consultant at B9Lab

    - Steve Marx @[https://ethereum.stackexchange.com/users/19510/smarx]
      and Tood Proebsting:
      Authors of @[https://programtheblockchain.com/] with great
      tutorials about Payment Channels:
      @[https://programtheblockchain.com/posts/2018/12/10/introduction-to-ethereum-payment-channels-video/]
      @[https://programtheblockchain.com/posts/2018/02/23/writing-a-simple-payment-channel/]:
      @[https://programtheblockchain.com/posts/2018/03/02/building-long-lived-payment-channels]

    - Péter Szilágyi, @[https://github.com/karalabe]
      Core Puppeth developer @[https://www.youtube.com/watch?v=T5RcjYPTG9g]

  - Paul Lintilhac: Quantitative Developer at ConsenSys, Alethio developer

  - Hudson Jameson (@Souptacular)
  @[https://hudsonjameson.com/]

  - Nick Savers (@nicksavers)

  - Martin Becze (@wanderer)

  - Greg Colvin (@gcolvin)

  - Alex Beregszaszi (@axic)

  StackExchange Top users:
  - "Afri" Ethereum FAQ answers on Stackoverflow
    (hidden user from the Parity Team)
    Lastest activity: 2018-08-21
  @[https://ethereum.stackexchange.com/users/87/afri]

● Who-is-who Companies:
- https://consensys.net/:
  Consensys techs:
  Balanc3             TravelBlocks                                 Linnia
  Cellarius           Waterloo                                     Catalyst and Hub Account Manager
  ConsenSys Academy   Panvala                                      Meridio
  Plasma              Gitcoin                                      MetaMask
  Gitcoin             Infura                                       N0d.capital
  Token Foundry       Kaleido                                      Nethereum
  Viant               Applied Researcher: Sharding                 Numia
  uPort               Applied Researcher: Sidechains (PegaSys)     OpenLaw
  Trustology          Quantitative/Qualitative Researcher          PegaSys
  TruSet              Senior Design Researcher - Ujo Music

- QuillHash, security Firm, authors of QuillAudits,
  fully automated platform to verify smart contracts
  @[https://audits.quillhash.com]
  (manual review + automated tools).
  - Smart contract audits and penetration tests.

- Ujo: Ethereum blockchain-based open music industry peer-to-peer platform built by ConsenSys.
  Ujo aims to increase transparency and efficiency in the music industry through an automated,
  decentralised rights management and payments system upon which any music service or
  application can be built. Creators and rights holders register works and their stakes in those
  works in smart contracts on the blockchain. Payments are delivered automatically and
  instantly based on that information using the self-enforcing smart contract technology. Artists
  may also publish policies for how their music may be used, facilitating an open marketplace in
  which anybody can innovate a new business model, app or service as long as they meet the
  terms of those policies.

  - https://pegasys.tech/: Consensys Company with 55+ team dedicated
    to enterprise grade blockchain at ConsenSys.
    focused on privacy, permissioning, scalability, and other
    features to make Ethereum production-ready.
    Developers of Pantheon

- NomiClabs (Argentina)
@[https://nomiclabs.io/]
  - Products:
    - Buidler
    - Sprawl: Permissionless and censorship resistant p2p decentrilized exchange
    @[https://github.com/SprawlNetwork/whitepaper/blob/master/Sprawl.pdf]
  - Developers:
    - Patricio Palladino: Author on  web3x: Typescript version of web3.js

- OpenLaw: Create, store and exec legal agreements

- https://viant.io/: Model Business processes, track assets+build supply chains faster

● Network Versions [[{101,scalability.evm,scalability.consensus.ethereum2,scalability.layer2,layer2.rollup.optimistic,layer2.rollup.zk]]
• Protocol and Code Updates:
@[https://ethereum.github.io/yellowpaper/paper.pdf]
@[https://en.wikipedia.org/wiki/Ethereum#Milestones]
  Name/Code Name     1st Block  Release     Public Ethereum    Network        Notes
                        Number  date        Network Version    Block Reward
  Frontier                   0  2015-07-30
  ---------------------------------------------------------------------------------
  Ice Age               200000  2015-09-08
  ---------------------------------------------------------------------------------
  Homestead            1150000  2016-03-15  Homestead          5 ether
  ---------------------------------------------------------------------------------
  DAO Fork             1920000  2016-07-20
  ---------------------------------------------------------------------------------
  Tangerine Whistle    2463000  2016-10-18
  ---------------------------------------------------------------------------------
  SpuriousDragon       2675000  2016-11-23
  ---------------------------------------------------------------------------------
  Byzantium            4370000  2017-10-16  Metropolis Part1*1
  ---------------------------------------------------------------------------------
  Constantinople *4    7280000  2019-02-28  Metropolis Part2*2
  +                                        ----------------------------------------
  Petersburg           7280000  2019-02-28
  ---------------------------------------------------------------------------------
  Istanbul             9069000  2019-12-08
  ---------------------------------------------------------------------------------
  MuirGlacier          9200000  2020-01-02
  ---------------------------------------------------------------------------------
  Berlin              12244000  2021-04-15
  ---------------------------------------------------------------------------------
  London              12965000  2021-08-05
  ---------------------------------------------------------------------------------
  ArrowGlacier        13773000
  ---------------------------------------------------------------------------------
                                            Serenity *3
                                            PoS replacing PoW

  *1 Byzantium hardfork == """ Ethereum for the masses """.
   @[https://www.infoq.com/news/2017/08/Ethereum-HardFork]
    - It  increases anonymity through Zero-knowledge zk-snark proofs ,
    - It includes more predictable gas charges which were becoming
      difficult to calculate with the increased number of ICOs.
  *2 Metropolis Part 2,Constantinople: (Aka "Ethereum 2.0"):
     - It lays the fundations of PoS(Casper consensus): According to
 @[https://www.trustnodes.com/2019/06/15/ethereum-2-0-planned-for-launch-on-the-3rd-of-january-2020]
     ...Phase zero of ethereum 2.0, which enables Proof of Stake (PoS),
        is targeted to launch on the 2020-01-03 .
          Delayed, not yet complete on 2021-12  or 1y9months later.
      - spec freeze: 20??-06-30
        New realistic targets, there are two milestones.
     - First, the deposit contract is to launch ahead
       of the genesis block to allow validators to make deposits.
       .. They’re hoping at least 2 million eth will be deposited
     - Second milestone is the genesis block launch on the day.
       "...This would allow three months of deposits to accumulate
       and 7 months from today for at least two clients to reach
       production status, Drake said.."
       └───────┬───────┘
       production status == """there has been a long running cross
                               client testnet that has gone through
                               security audit, fuzzing, parts have
                               gone through formal verification, and
                               hasn’t suffered major issues for a
                               healthy amount of time."""


  *3 Serenity: Ethereum 2.0 "last phase", switch to proof of stake
     - huge upgrades on the scalability side (sards, ...)
     - Ethereum 2.0 phases
       - REF: @[https://medium.com/alethio/ethereum-2-0-terms-demystified-8398357429d7]
              2019-08-13
       - Phase 0 — The beacon chain
         - managing validators and stakes
         - organizing and electing committees and proposers
         - applying consensus rules
         - rewarding and penalizing/slashing
       - Phase 1 — Shards
         - constructing the shard chains and blocks
         - anchoring (cross-linking) shard blocks to beacon chain
         - ability to do bETH transfers between validators (this might come
           sooner as it’s not technically linked to work on sharding)
       - Phase 2 — Execution Environments
         - Ewasm based virtual machine for execution of Smart Contracts.
         - every shard has access to all execution environments.
         - ability to make transactions within execution environments.
         - ability to run and interact with smart contracts.
         - cross-shard communication.

     Due to the advances in (optimistic/zk)+Rollups chains it's quite
     possible that Ethereum 2 ends up being Ethereum 1.5
     (Ethereum 1 + Sharding) + zk-Rollups as explained by Vitalik in:
   @[https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698]
     """
      ...base-layer scaling would primarily be focused on scaling how much
      data blocks can hold, and not efficiency of on-chain computation or
      IO operations. The only determinant of the scalability of a rollup is
      how much data the chain can hold, and any increase beyond the current
      ~60 kB/sec will help...
      • Ethereum 1-L1                : ~15 TPS.
      • everyone moving to rollups   : ~3000 TPS.
      • rollups + eth2 sharded-chains:  up to ~100_000 TPS.
      • eth2 + phase2                : ~1000-5000 TPS on L1
                                        (100x less than Rollups).
                                        ^^^^^^^^^^^^^^^^^^^^^^^^.
        IT SEEMS VERY PLAUSIBLE TO ME THAT WHEN PHASE 2 FINALLY COMES,
        ESSENTIALLY NO ONE WILL CARE ABOUT IT.
     """

  *4 Original Constantinople network upgrade was postponed and two
     protocol upgrades will need to occur on the same block number in
     order to fix issues on various Ethereum test networks (Ropsten,...)


  REFs:
  - 2018-06-16: Casper and sharding merger confirmed
  @[https://www.trustnodes.com/2018/06/16/casper-sharding-merger-confirmed-constantinople-back-table]
  - 2019-02-22: scheduled upgrade at block number 7,280,000,  predicted on 2019-02-28
  @[https://blog.ethereum.org/2019/02/22/ethereum-constantinople-st-petersburg-upgrade-announcement/]

<hr/>
<span title>Chain IDs running EVMs Smart Contracts</span>
• REFs:
  · @[https://chainid.network/]
  · @[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids]
  ·(+ Summary from original project sources)

• NOTE:read @[#layer2_scalability_summary]  for difference among side-chains and rollups.
       (TLDR: rollups: safer, side-chains: Easier/more centrilized).

                             ┌─ TheGraph Protocol Support
  Chain Name/Chain ID  │Symb│││ notes
  ─────────────────────│────│─│─────────────────────────────────────────────────────
  ethereum             |    | |
  └ mainnet/1          | ETH| |
  └ testnet kovan/42   | KOV| |
  └ testnet görli/5    | GOR| |
  └ testnet ropsten/3  | ROP| |
  └ testnet rinkeby/4  | RIN| |
  ---------------------|----| |-----------------------------------------------------
  expanse net/2        | EXP| |
  ---------------------|----| |-----------------------------------------------------
  thaichain/7          | TCH| | thaishield audits verify your
  └ 2.0 thaifi/17      | TFI| | distributed systems work as intended.
                       |    | | our engineers fully review system’s
                       |    | | architecture and codebase, and then
                       |    | | write a thorough report with
                       |    | | actionable feedback for every issue.
  --------------------------| |-----------------------------------------------------
  ubiq/8               | UBQ| | built upon improved version of e.codebase,
  └ testnet/9          |    | | it offers enterprise-stable pow.
                       |    | | conservative upgrade schedule.
  --------------------------|-|-----------------------------------------------------
  arbitrum one/42161   |AETH|Y| optimistic rollup.
  └ test.rinkeby/421611|aRETH | integrated with binance exchange
                       |    | | (but withdrawals not yet enabled
                       |    | |  as of 2021-11-26  )
  └ on xdai/200        |XDAI| |  (research project)
  --------------------------|-|-----------------------------------------------------
  Optimistic Eth./10   |OETH|Y| type: l2 optimistic-rollup
  └ testnet kova/69    | KOR| | millisec tx,10-100x cheaper.
  └ testnet goerly/420 | GOR| | periodically submit l2 tx merkle root to
                       |    | | mainnet, storing N L2 tx 1 tx mainnet.
                       |    | | https://chainid.lin/?network=optimism
                       |    | | node: https://mainnet.optimism.io
                       |    | | expl: https://optimistic.etherscan.io
                       |    | | supported by infura.
  ---------------------|----|-|-----------------------------------------------------
  xDAI Chain/100       |xDAI|Y|  Aims at creating Stable Payments Fees tied to USD
  ---------------------|----|-|-----------------------------------------------------
  NEAR/???             |????|Y| It runs in concert with Ether/Polka./Cosmos/
                       |    | |
  ---------------------|----|-|-----------------------------------------------------
  CELO/???             |????|Y|• https://celo.org
                       |    | |• PoS, mobile-1st platform for fin.dApps+crypto payments
                       |    | |• KickStart anounced that its platform will change to
                       |    | |  be based on the Celo blockchain in 2021-12.
                       |    | |• CELO founders/inverstors include Jack Dorsey (Twitter
                       |    | |  CEO), SocialCapital, CoinBase, Telekom, ...
  ---------------------|----|-|-----------------------------------------------------
  AVALANCHE/???        |????|Y|
  ---------------------|----|-|-----------------------------------------------------
  StarkNet             |????|?|• L2 stark rollup.
                       |    | |• Used by SORASE (Paris based company providing
                       |    | |  NFTs for "LaLiga", "Gerad Piqué", ...)
                       |    | |• Alpha state as of 2022-02-22
  ---------------------|----|-|-----------------------------------------------------
  POA/???              |????|Y|
  ---------------------|----|-|-----------------------------------------------------
  MOONRIVER/???        |????|Y|
  ---------------------|----|-|-----------------------------------------------------
  Fuse Mainnet/122     |FUSE|Y|  "Open Source" Economy, create Branded wallets...
  └ Sparknet/123       SPARK| |  47 validators, ...
  ---------------------|----|-|-----------------------------------------------------
  polygon Main./137    MATIC|Y| type: L2 zk-rollup
  └ Test.Mumbai/80001  MATIC| | https://polygon.technology/
                       |    | | polygon: protocol+framework to build+
                       |    | | connect Ether. compatible Networks
  ---------------------|----|-|-----------------------------------------------------
  palm Main./*1        |PALM| | sidechain for selling&trading
  └ Testnet/*2         |PALM| | real-world and digi. assets NFTs.
  *1:11297108109       |    | | IBFT 2.0 poa consensus.
  *2:11297108099       |    | | (pseudo-centralized/consortium net).
                       |    | | automated mainnet bridge relay service.
                       |    | | Connect payment tokens (DAI, NFTs) with
                       |    | | bridging contracts deployed on both
                       |    | | networks. Fees collected from this
                       |    | | bridge are partially used to purchase
                       |    | | carbon offsets.
  ---------------------+----|-|-----------------------------------------------------
  Metadium Main./11    |META| | Self Sov. Identity with 2 Factor Authentication
  └ Testnet/12         | KAL| |
  ---------------------|----| |-----------------------------------------------------
  GoodData Main./32    |GooD| |  NFTs/"Metaverse"
  └ Testnet/33         |GooD| |  AI and ML Optimize Rewards
                       |    | |  Region-aware distributed storage
  ---------------------|----| |-----------------------------------------------------
  Telos EVM Main./40   |TLOS| |  "The most scalable E.platform available today"
  └ Testnet/41         |TLOS| |  Fixed gas fee. Enviro.Friendly
                       |    | |  ESG compliance
  ---------------------|----| |-----------------------------------------------------
  CoinEx SmartCh./52   | CET| |  PoS based. Permission-free, low fess.
  └ Testnet/53         |CETT| |  Finance oriented
  ---------------------|----| |-----------------------------------------------------
  Ontology Main./58    | ONG| |  Focus:Decentralized IDentity. Customers include
  └ Testnet/5851       | ONG| |  Daimler Benz Mobility.
                       |    | |  App User base: 50% Asia, 7% USA.
                       |    | |  partnered with rOCKI, next-gen music [NFT]
                       |    | |  streaming service and NFT platform built on
                       |    | |  Binance Smart Chain (BSC) to use its DID solution
                       |    | |  to prevent badn actors impersonating artists.
                       |    | |  Multi-Virtual Machine supports.
                       |    | |  "Ont. has its own VM, and also supports Wasm, NeoVM.
                       |    | |  and EVM....  Devs can now use Ont.Bridge to convert
                       |    | |  Ont.Native OEP4 to ORC20 tokens, adding to MetaMask,
                       |    | |  and deploying dApps.
  ---------------------|----| |-----------------------------------------------------
  GoChain Main./60     |  GO| |  Proof of Reputation (PoR) web3 based public+private
  └ Testnet/31337      |  GO| |  1300 TX/sec.(10000x greener, 1000x cheaper)
                       |    | |  Run by Lenovo, RMIT university, Nicosia University,
                       |    | |  Pennsylvania State University, ...
                       |    | |  Quite active as of 2021-11 according to:
                       |    | |@[https://medium.com/gochain]
                       |    | |  Clientes include Fortune 500 companies,
                       |    | |  Compañía Nacional de Minería de Colombia,
                       |    | |  Services include:
                       |    | |  - Zeromint NFT Marketplace and Chainparency.
  --------------------------| |-----------------------------------------------------
  OKExChain Main./65   | OKT| |  Decentralized Exchange (DEX) oriented, running
  └ Mainnet/66         | OKT| |  "on top" Cosmos + EVM.
  ---------------------|----| |-----------------------------------------------------
  POA Network Core/99  | POA| |
  └ Sokol/77           | SKL| |
  ---------------------|----| |-----------------------------------------------------
  PrimusChain          |    | |
  └ Main./78           |PETH| |
  ---------------------|----| |-----------------------------------------------------
  Meter Mainnet/82     | MTR| |  "High performance infra" allowing S.C. to
  └ Testnet/83         | MTR| |  "travel" through heterogeneous blockchain networks.
                       |    | |  Partneting with ChainLink, Harmony, Poligy,
                       |    | |  Standard Tokenization Protocol, Oasis Foundation,
                       |    | |  ...
                       |    | |  100+ validators.
  ---------------------|----| |-----------------------------------------------------
  Lightstreams         |    | |
  └ Mainnet/162        | PHT| |  Built on Tendermint consensus ("Cosmos"). According
  └ Testnet/163        | PHT| |  to page: a $5.63 TX in E.MainNet becomes $0.0002 in
                       |    | |  lightstreams. $42.30 Uniswap reduces to $0.0016.
                       |    | |  x25 faster with install 3secs. settlement.
                       |    | |  Doesn't look to be very active. 1/2 post per year.
  ---------------------|----| |-----------------------------------------------------
  BitTorrent Ch./199   | BTT| |  Blokchain tokenizing BitTorrent Decentralized
  └ Testnet/1028       | BTT| |  file sharing protocol.
  ---------------------|----| |-----------------------------------------------------
  Freight Trust        |    | |  Focus on regulated/compliant SupplyChain.
        Network/211    | 0xF| |  EID X12, EDINT AS2/AS4,
                       |    | |  EDI EDIFACT, Custom/Imports,
                       |    | |  Custom/Exports, Freight Forwarders
  ---------------------|----| |-----------------------------------------------------
  Energy Web Ch./246   | ???| |  https://energyweb.org/
                       |    | |  "World’s first public, enterprise-grade
                       |    | |   blockchain tailored to the energy sector"
                       |    | |  46 projects in 21 countries
                       |    | |  with 41 partners as of 2021-11
                       |    | |  W3C DID is used as core Identity building block.
                       |    | |  Identity is provided to any customer, asset,
                       |    | |  utility or regulator.
  ---------------------|----| |-----------------------------------------------------
  Theta                |    | |  Specialized in peer-to-peer (real-time)video
  └ Mainet    /361     TFUEL| |  streaming/transcoding.
  └ Testnet   /365     TFUEL| |  streaming/transcoding.
    Sap.Test. /363     TFUEL| |  Compat. with EVM Constantinople plus
    Amber Test/364     TFUEL| |  a couple of key Istanbul features.
                       |    | |  Global partners including Google, Samsung,
                       |    | |  Binance, Blockchain.com, and Gumi.
  ---------------------|----| |-----------------------------------------------------
  Acala Network/787    | ACA| |  layer-1 with built-in liquidity and
  └ Testnet/595        |mACA| |  ready-made fin.apps + trustless
                       |    | |  exchange, decentralized stablecoin
                       |    | |  (aUSD), DOT Liquid Staking (LDOT),
                       |    | |  and EVM+. supported by Polkadot Substrate.
  ---------------------|----| |-----------------------------------------------------
  Ambros Chain         |AMBR| |  600+ PoA network designed for IoT.
  └ MainNet/ 880       |AMBR| |  13.848 Holders.
  └ Testnet/8888       |AMBR| |  Digital identities are given to devices,
                       |    | |  with all data about their condition and
                       |    | |  movement securely bundled and automatically
                       |    | |  relayed to your blockchain.
  ---------------------|----| |-----------------------------------------------------
  Wanchain/888         | WAN| |  https://www.wanchain.org/
  └ Testnet/999        | WAN| |  Finance oriented Public|Private-to-Public|Private
  ---------------------|----| |-----------------------------------------------------
  Clover Main./1023    | CLV| |  part of cross-blockhain (EVM, DOT/KSM+ parachains,
  └ Testnet/1024       | CLV| |  Solana) project.
  ---------------------|----| |-----------------------------------------------------
  MathChain/1139       |MATH| |  https://mathchain.org/en/
  └ Testnet/1140       |MATH| |  SmartWallet AppChain based on (Polkadot) Substrate
                       |    | |  Features: DID, SecretStore, EVM, Off-chain Worker.
  ---------------------|----| |-----------------------------------------------------
  Ecoball Main./???    | ECO| |  Finance Oriented. Claims to support 100.000 TX/s
  └ Test.Espuma/???    | ECO| |  using VPoS and smart-node selection with close-to-zero
                       |    | |  trading fees.
                       |    | |  25 validator pools and 245 delegators.
  ---------------------|----| |-----------------------------------------------------
  QuarkChain           |    | |  flexible, scalable, user-oriented
  └ Mainnet            |    | |  blockchain infrastructure by using
    └ Root/100000      | QKC| |  blockchain sharding technology.
    └ Shards/*1        | QKC| |
  └ Devnet
    └ Root/110000      | QKC| |
    └ Shards/*2        | QKC| |
  *1:100001..8         |    | |
  *2:100001..8         |    | |
  ---------------------|----| |-----------------------------------------------------
  Harmony              |    | |  2-second TX finality @ 1/1000 price.
  └ Mainnet            |    | |  Open platform for assets, collectibles,
    └ Shards/*1        |  ON| |E identity and governance.
  └ Testnet            |    | |  secure bridges offer cross-chain asset
    └ Shards/*2        |  ON| |E transfers with E.MainNet, Binance and
    1666600000..3      |    | |  3 other chains.
    1666600000..3      |    | |  daVinci NFT marketplace: April 2021.
                       |    | |
  ---------------------|----| |-----------------------------------------------------
  IoTeX Network        |    | |@[https://iotex.io/]
  └ Mainnet/4689       |IOTX| |  9K+     DEVICES       200K+   COMMUNITY
  └ Testnet/4690       |IOTX| |  14,4M   TRANSACTIONS  39,000+ STAKERS
                       |    | |  """IEEE Blockchain& IoT Standards
                       |    | |   Working Group Appoints IoTeX Head of
                       |    | |   Cryptography as Vice Chair """
                       |    | |
  ---------------------|----|-|-----------------------------------------------------
  Binan.SmartCh./56    | BNB|Y|   PoSA = Proof of Stake + Proof of Authority.
  └ Testnet/97         |tBNB| |   WARN: "Spam Chain". Very active <a href="https://www.techtimes.com/articles/268625/20211128/binance-smart-chain-becomes-most-followed-cryptocurrency-on-twitter.htm]">on Twitter an press</a>
                                             Completely broken in Real World:
                                           @[https://github.com/binance-chain/bsc/issues/553]

  OTHERS Networks: @[https://chainid.network/]
    Diode , Flare , ThunderCore, Callisto, ...
  -------------------------------------------------------------------------------------------------
[[}]]


[[{standards,00_PM.ext_resource,01_doc_has.taxonomy,00_PM.TODO]]
● Related Taxonomies:
  - TokenTaxonomyFramework
  @[https://github.com/InterWorkAlliance/TokenTaxonomyFramework]
  @[https://interwork.org/real-world-tokens-a-seven-step-journey-into-the-ttf/]

  - Laws/Legal Taxonomy: @[https://law.stackexchange.com/tags]
  - Economics  Taxonomy: @[https://economics.stackexchange.com/tags]
[[}]]

● EVM [[{10_EVM,00_PM.ext_resource]]
 • External Refs:
  @[https://github.com/ethereum/yellowpaper]
  @[https://github.com/ethereum/wiki/wiki/Ethereum-Development-Tutorial]
  @[http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#the-evm]

 • Patricia tree [[{101,10_EVM.101,persistence.blockchain,,infrastructure.storage,infrastructure.network}]]
@[https://eth.wiki/en/fundamentals/patricia-tree]
  - cryptographically fully deterministic "key/value":
    A Patricia trie: cryptographycally protected (key,value) store with
    O(log(n)) inserts/lookups/deletes.
    Much easier to understand and code than alternatives (red-black tries).

  - Ethereum use Merkle Patricia Tries (with roots hashed stored in block-header) for:
    ✓ root-of-state:  *1
      · trie-path : sha3(ethereumAddress)
      · trie-value: rlp(ethereumAccount) ← nonce, balance,root-of-contract-storage, codeHash
                                                          └───────────┬──────────┘
    ✓ root-of-transactions:                                 trie-path : sha3(position-of-variable)
      · trie-path : rlp(transactionIndex)                   trie-value: rlp-encoding of storage value
      · trie-value: rlp(transaction)?

    ✓ root-of-receipts:
      · trie-path : rlp(transactionIndex)
      · trie-value: rlp(receipt)?

   
  - RLP NOTES: Recursive Length Prefix encoding. Tools exist to convert from/to JSON objects, ...
   @[https://eth.wiki/en/fundamentals/rlp] [TODO]

  *1: EVM state :
    @[https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/]
    - 400 million nodes in the state trie. Of these, about 3,000 (but as
      many as 6,000) need to be added or modified every 15 seconds.
      Staying in sync with the Ethereum blockchain is, effectively,
      constantly building a new version of the state trie over
      and over again.
       ... This multi-step process of state trie database operations is why
      Ethereum implementations are so taxing on disk I/O and memory, and
      why even a “fast sync” can take up to 6 hours to complete, even
      on fast connections. To run a full node in Ethereum, a fast SSD (as
      opposed to a cheap, reliable HDD) is a requirement, because
      processing state changes is extremely demanding on disk read/writes.


  • RADIX-TRIE, BASIC BUILDING BLOCK OF PATRICIA TIRE:
   ####################################################
   # PRE-SETUP) CHOOSE AN ORDERED ALPHABET.           #
   # (Hex digits "nibles" in Ethereum implementation) #
   ####################################################

  ┌─ NODE "micro─db" ──────────────────────────────────────┐
  │  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F        ← ORDERED (IMPLICIT)
  │  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·        │ POSITION GIVEN AN
  │  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·        │ INITIAL ORDERED ALPHABET
  │ [p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,value]│
  └─ └──────────────────────┬──────────────────────┘ └─┬─┘─┘
    array containing values (keys are implicits,    "information"
    based on order-of-array = order-of-alphabet)    located-in-order
                                                    @end-of-array

    KEY-POINT: trie must be built/calculated "upside-down":
               leaf nodes first, then its leaf-parent, then leaf-grandparents,
               ... finally the root-node.

    • p0..pF values := NULL|sha3(rlp(pointed-node))
                            └─┬─┘
      "Merkle part" of the Patricia trie.
      KEY POINTs: It root-hash is publicly known, then anyone can
                  provide a proof that the trie has a given value
                  and nobody can provide a false proof for non
                  existing key-values pairs.

  • To fetch the value of key "dog" in trie:
    STEP 1) dog → (to alphabet) → 646F67 ······························┐
    STEP 2) Walk over trie path:                                       ·
     0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] root-node                  ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6]                 ·
    ┌────────┘                                                         ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4]              ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6]           ·
    ┌──────────────────────────────┘                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F]        ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F][6]     ·
    ┌──────────────┘                                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F][6][7] ←┘
                                     └─┬─┘
     ?: hash-of-pointed-node         dog value!!!


  PROBLEM: radix tries are inefficient:
    a bytes32 needs 64 chars long or over a kilobyte of extra space
    to store one level per character.
    each lookup/delete will take the full 64 steps.
  SOLUTION: PATRICIA TRIE TO THE RESCUE.

  - PATRICIA TRIE:
    - Most nodes in the radix-trie will be "empty" (no value) in
      a 64 chars path. Forcing them to have empty values in every index + "target"
      index is a waste.
    Patricia Trie node extension add next structures:
    - encodedPath: "partial path" shortcut to skip ahead using compact encoding.
    Then the Patricia Trie node wil be one of :
    - NULL               node: (represented as "empty string")
    - branch    A        node: [ v0, ...,vF, vt ]
    - extension A 2-item node: [ encodedPath, key ]   ← key: used for next db-lookup
    - leaf      A 2-item node: [ encodedPath, value ] ← a flag in 1st nible of encoded
                                                        path marks node as being a leaf.

  - note: To differentiate among nibble 1 and nibble 01, both stored as "01",
          a partial path is prefixed with a flag for odd-cases.
          (See original post for more info)

• EVM Accounts [[{12_solidity,10_EVM.101,01_doc_has.diagram]] #[evm_accounts_summary]
@[http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html]
  Account   ← same address space both for contract and normal accounts
  ┌─────────────────────────┐
  │bytes[32]       address  │
  ├─────────────────────────┤
  │wei             balance  │
  ├─────────────────────────┤
  │Map<256b,256b>  storage  │
  └─────────────────────────┘

           ┌────────────────────────────────────┬───────────────────────────────────────┐
           │   EXTERNALLY OWNED ACCOUNT         │          CONTRACT ACCOUNTS            │
  ┌────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │CREATION│→ Generate random 32bytes priv. key │→Create smart─contract source code  *1 │
  │        │→ Generate Pub.Key from Priv.Key    │→Generate bytecode by compiling source │
  │        │→ Generate public address as:       │→Send "Contract Creation" TX for mining│
  │        │  bytes[32] pub.addr= hash(pub.addr)│→keep Contract address once "published"│
  │        │                                    │ (determined from nonce)               │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │CONTROL │Private Key: Only the (human) owner │ BYTECODE                              │
  │BY      │of the  secret  private key can     │                                       │
  │        │decrease the balance by signing new │                                       │
  │        │TX                                  │                                       │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │FEATURES│ bytes[32] address                  │ bytes[32] address *1                  │
  │        │                                    │ Map<256b,256b> storage *2             │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │ADDRESS │ Generated deterministically from   │ Generated deterministically from      │
  │        │ priv.key (→ pub.key → hash(pub.key)│ priv.key , bytecode,  TX.nonce        │
  └────────┴────────────────────────────────────┴───────────────────────────^───────────┘
                                    ┌───────────────────────────────────────┘
                                    ├─It's recomended to change the nonce when deploying
                                    │ to two or more different networks, since there is
                                    │ a small but finite possibility, that TXs can be
                                    │ replayed on such networks.
                                    └─For private networks contracts can also be deployed
                                      in the genesis.json block assigned to any arbitrary
                                      (easy-to-remember) address.

 *2: account.storage: Persistent memory area
     - It is not possible to enumerate storage from within a contract
     - It is comparatively costly to read and even more so, to modify storage
       in the context of an (update state) TX. (It's still free of cost during
       external query calls).
     - A contract can neither read nor write to any storage apart from its own

  Signing transactions Flow:
   - Identify the next available nonce for the sender account
   - Create the RawTransaction object
   - Encode the RawTransaction object using Recursive Length Prefix encoding
   - Sign the RawTransaction object
   - Send the RawTransaction object to a node for processing

  The nonce is an increasing numeric value which is used to uniquely identify
  transactions. A nonce can only be used once and until a transaction is mined,
  it is possible to send multiple versions of a transaction with the same nonce,
  however, once mined, any subsequent submissions will be rejected.
[[}]]

• EVM Message Calls (CALL opcode) [[{10_EVM.101,20_QA.error_control,01_doc_has.diagram]]
  - Contracts can user message calls to call other contracts or send Ether to
    non-contract accounts.

        ETHEREUM NETWORK
         o······o······o
         ·      ·      ·   ─ → ─  Gossip Protocol
         o      o─  → ─o
         ·      ↑      ↓
  local→ o─  → ─o······O ← Mining
  node        ↑        │   node
         │           ┌─┘
         │           │
         │           │ Signed TX is mapped to the top─level
   Signed TX         │ message call by Mining Node
         ↑   ┌───────│────────────────────────────────── EVM executing at Mining Node ──┐
  ┌──────┴─┐ │       ↓                     ┌─────┐                               ┌─────┐│
  │external│ │      top─level              │sc01 │                               │sc02 ││
  │client  │ │      message call       ──→ │funcA│  → message call ────────────→ │funcB││
  └────────┘ │                             └─────┘                               └─────┘│
             │      ───────────────          │  ^     ────────────                  │   │
             │      sender  = tx signer addr │  │     sender  = sc01.addr           │   │
             │      target  = sc01.add  *1   │  │     target  = sc02.addr           │   │
             │      payload = abi(funcA+args)│  │     payload = abi(funcB+arggs)    │   │
             │      value   = 0+gweis        │  │     value   = 0+gweis             │   │
             │      gas     = *2             │  │     gas     = *2                  │   │
             │   *3 return data  ←───────────┘  └──── return data  ←────────────────┘   │
             └──────────────────────────────────────────────────────────────────────────┘

    *1 : target can also be an external (non-contract) account (or even == "sender")

    *2 : Enough gas to execute called function, but small enought to avoid
         wasting too-much ethers (because of software bugs, gas-price, ...)
         Contracts decide how much remaining gas is sent within calls to other
         contracts.
         An (out-of-gas|*) exception in inner message call is signalled by an
         error value put onto the stack.
         The gas sent is consumed.
         By default in  Solidity calling contract re-launch a manual exception
         to make exceptions "bubble up" the remote call stack.

    *3 : return data is stored at  preallocated location  in caller's memory.
         return data of top-level call is not used , since client disconnects as
         soon as local node cofirms Signed TX reception.
         sc01.funcA will use async Events to communicate results.
         (original external client and any other interested cliet will listen for
          such events)

   - Calls depth is limited to 1024 (Prefer loops to recursive calls)

 • EVM DELEGATECALL opcode, Homestead+
   - mostly indentical to a message call BUT
     - called code is executed in the context of the calling contract
       - sender == original msg.sender
       - value  == original msg.value
       - Same storage
       - Same current balance
       - Different Code / Different Program Counter
       - New function stack

   - Used in libraries, since it allows a contract to dynamically load code
     from a different address at runtime.
     For example to manipulate Complex data structures.
     Library code is deployed once at a specific address and their code invoqued
     through DELEGATECALL.
       In comparison to contracts, libraries:
       - Have no state variables. A reference to struct must be passed.
       - Can NOT inherit nor be inherited
       - Can NOT recieve Ethe

   - Could represent a   security risk for calling contract
     which  needs to trust that the receiving contract  while
     manipulating its own storage.

   - Replaces   deprecated CALLCODE  fixing bug since CALLCODE did not
     preserve msg.sender and msg.value.
[[}]]

 • EVM OpCodes Summary [[{10_EVM.101,10_EVM.i/o,10_EVM.gas]]
   - Ethereum Virtual Machine Opcodes low level reference to EVM:
    @[https://ethervm.io/]
   - EVM Illustrated [[{00_PM.TODO}]]
     @[https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf]

     Opcodes:
   @[https://github.com/crytic/evm-opcodes]
   - EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.
   - Persistent storage is quite expensive.
   - The Solidity compiler makes interesting choices in order to minimize gas usage.

   - To interact with a Smart Contract, you send it raw bytes.
   - It does some computation, possibly changing its own state,
     and then sends you raw bytes in return.
   - Method calling does not actually exist. It is a collective
     illusion created by the ABI.
   - The ABI is specified like a low-level format, but in function
     it's more like a serialization format for a cross-language RPC framework.
   - We could draw analogies between the architectural tiers of DApp and Web App:
     - The blockchain is like the backing database
     - A contract is like a web service
     - A transaction is like a request
     - ABI is the data-interchange format, like Protocol Buffer

 • EVM Memory
   - A contract obtains a freshly cleared instance for each message call
   - Memory is linear and can be addressed at byte level
   -  Reads are limited to a width of 256 bits
   -  Writes can be either 8 bits or 256 bits wide
   - Memory is expanded by a word (256-bit), when accessing
       (either reading or writing) a previously untouched memory word (ie.
       any offset within a word). At the time of expansion, the cost in gas
       must be paid. Memory is more costly the larger it grows (it scales
       quadratically)
   - calldata: Separate area of memory whe message call payload is placed
   - See also: @[#solidity_storage_magging]

 • EVM Stack
   - EVM memory area list of 256bits up to 1024 elements used for computations.
   - The 16 topmost elements can be moved to the top or swaped wih the top element
   - All other operations take the topmost one (or two, or more) elements and push
     the result onto the stack.
   - top elements can be moved to/from storage/memory, but deeper elements can
     be accessed without first removing elements on top of them.

   - (EVM)full computational state: can be defined by the tuple:
     (block_state, transaction, message, code, memory, stack, pc, gas)
     block_state = global state = all accounts (balances + storage)

   - selfdestruct(target): Destructor for contract @ address
     - Remaining Ethers are sent to target
     - storage & code are removed from the blockchain state

• EVM Instructions:
  REF: @[https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go]
  - EVM works with next inputs:
    Prog.Counter(PC): to known where to fetch next EVM instruction to execute
                      in units of 32 bytes (0x20 bytes).
    Contract Context: To know where contract state is in storage.
    EVM "RAM" Memory: Input/Output  for Operations.
    STACK           : input/Out for Operations

  • EVM executes code start-to-end from zero address (vs some other defined/parametrizable entry point).


  • EVM OPCODES: REF: https://www.ethervm.io/
                      COND.ARIT. END-  DESCRIPTION
                      TIO- ME-  FUNC/
                      NAL  TIC  COMP.
    --------------------------------- BASIC ARITMETHIC
    • ADD/SUB/MUL    |    |    |    | (uint256 values)
      DIV/SDIV       |    |    |    | SDIV == Signed division
      EXP            |    |    |    | EXP a b  == a ** b
      SIGNEXTEND     |    |    |    | SIGNEXTEND b x y ==  y = sign extends x from (b + 1) * 8 bits (up to 256 bits).
    --------------------------------- MODULAR ARITMETHIC
    • MOD/SMOD       |    |    |    | MOD a b = a % b, SMOD == signed mod.
      ADDMOD/MULMOD  |    |    |    | ADMOD  a b N == (a + b) % N
                     |    |    |    | MULMOD a b N == (a * b) % N
    • NOT            |    |    |    |
    --------------------------------- BYTE RELATED OPERATIONS
    • BYTE           |    |    |    | BYTE i x y ==  y = (x >> (248 - i * 8)) &  0xFF
                     |    |    |    | ith byte of (u)int256 x, counting from most significant byte
    • SHL/SHR/SAR    |    |    |    | 256-bit Shift left / right
                     |    |    |    | SAR: int256 (aritmetic) shift right
    • SHA3           |    |    |    | SHA3 offset length  == keccak256(memory[offset:offset+length])
                     |    |    |    | WARN: SHA3 != keccak (Ethereum keccak-256). More info at:
      @[https://ethereum.stackexchange.com/questions/550/which-cryptographic-hash-function-does-ethereum-use]
    --------------------------------- TX ACCOUNT RELATED DATA
    • ADDRESS        |    |    |    | "this". address of executing contract
      BALANCE        |    |    |    | address(addr).balance in wei
      SELFBALANCE    |    |    |    | address(this).balance in wei (v.Istanbul+/EIP-1884)
      ------------------------------- EXTERNAL INPUT FUNCT. INVOCATION
                                      (DATA COMMING FROM "OUTSIDE" THE EVM
      ORIGIN         |    |    |    | ORIGIN tx.origin  ==  transaction origin address
    • CALLER         |    |    |    | == "msg.caller" (EOA or contract) address.
      CALLVALUE      |    |    |    | TX "funds" in wei
      CALLDATALOAD   |    |    |    | CALLDATALOAD i  read (u)int256 msg.data[i:i+32] from message data
      CALLDATASIZE   |    |    |    | message data length in bytes
      CALLDATACOPY   |    |    |    | CALLDATACOPY destOffset offset length. Copy message data like:
                     |    |    |    | memory[destOffset:destOffset+length] = msg.data[offset:offset+length]
      ------------------------------- RETURN VALUE FROM FUNCTION
      RETURNDATASIZE |    |    |    | size-in-bytes of returned data from last external call (v.Byzantium+/EIP-211)
      RETURNDATACOPY |    |    |    | copy returned data (v.Byzantium+/EIP-211)
                     |    |    |    | memory[dst_offset:dst_offset+length] = RETURNDATA[offset:offset+length]
      ------------------------------- Reading Smart Contract Code
    • EXTCODESIZE    |    |    |    | address(addr).code.size for param addr.
      CODESIZE       |    |    |    | address(this).code.size
      EXTCODECOPY    |    |    |    | EXTCODECOPY addr dst_offset offset length. copy contract's bytecode like:
                     |    |    |    | memory[dst_offset:dst_offset+length] = address(addr).code[offset:offset+length]
      CODECOPY       |    |    |    | CODECOPY dst_offset offset length  copy executing contract's bytecode like:
                     |    |    |    | memory[dst_offset:dst_offset+length] = address(this).code[offset:offset+length]
      ------------------------------- BLOCK RELATED RUNTIME PARAMS.
    • EXTCODEHASH    |    |    |    | EXTCODEHASH addr hash = address(addr).exists ? keccak256(address(addr).code) : 0  (v Constantinople +/ EIP-1052)
      BLOCKHASH      |    |    |    | BLOCKHASH block hash    hash = block.blockHash(block), only valid for 256 most recent blocks excluding current one
      COINBASE       |    |    |    | current block's miner (injected from miner's ethereum config at node startup)
      DIFFICULTY     |    |    |    | current block.difficulty (established by network consensus)
      GAS            |    |    |    | return remaining gas
      GASLIMIT       |    |    |    | current block.gaslimit (established by network consensus)
      GASPRICE       |    |    |    | tx.gasprice established by signer in wei-per-unit-of-gas
      NUMBER         |    |    |    | current block.number
      TIMESTAMP      |    |    |    | current miner block's Unix timestamp in seconds
      CHAINID        |    |    |    | 1: mainnet, 2 Morden testnet(disused),2 Expanse mainnet, 3 Ropsten testnet, 4 Rinkeby testnet
      CHAINID        |    |    |    | 5: Goerli testnet, 42: Kovan testnet (v.Istanbul+/EIP-1344)
      BASEFEE        |    |    |    | v.London+/EIP-3198
      ------------------------------- MEMORY READ/WRITE FROM/TO STACK
    • MLOAD          |    |    |    | MLOAD  offset value  (u)int256 value = memory[offset:offset+32]
      MSTORE         |    |    |    | MSTORE offset value  memory[offset:offset+32] = (uint256) value
      MSTORE8        |    |    |    |                      memory[offset] = value & 0xFF
      MSIZE          |    |    |    | return size-in-bytes of memory for this contract execution.
    --------------------------------- STACK OPERATIONS
    • ISZERO         |    |    |    | Push 1 if topmost value is zero
      DUP1/2/../17   |    |    |    | clone 1st/2nd/3rd/... element in stack with "0th"
      SWAP1..17      |    |    |    | Swap  1st/2nd/3rd/... element in stack with "0th"
      PUSH1/.../33   |    |    |    |PUSH 1/2/3/.../33 byte value onto start
      POP            |    |    |    | pops and discard (u)int256 from stack.
    --------------------------------- CONTRACT STORAGE
    • SLOAD          |    |    |    | SLOAD  key value, (u)int256 value = storage[key] (read from storage)
      SSTORE         |    |    |    | SSTORE key value, storage[key] = value
    • LT/GT/SLT/SGT/ |XXXX|    |    |
      EQ/ISZERO      |    |    |    |
    • AND/OR/XOR     |XXXX|    |    | 256-bit bitwise ops
    --------------------------------- PC CONTROL "JUMP" OPERATIONS.
    • JUMP           |    |    |    | read-and-pop topmost stack-value, then "jumps" Program Counter to read value.
      JUMPI          |XXXX|    |    | jump condition if 2nd value in stack is NOT "0". (Consume 2 stack values)
    • JUMPDEST       |    |    |    | Target location must contain JUMPDEST opcode (otherwise exec.
                     |    |    |    | fails). This checking is the sole purpose of JUMPDEST, mark
                     |    |    |    | location as valid jump target).
    • PC             |    |    |    | Program counter value
    --------------------------------- FUNCTION INVOCATION
      CALLCODE       |    |    |    | gas addr value args_offset args_length ret_offset  ret_length. call method IN this contract?
      CALL           |    |    |    | gas addr value args_offset args_length ret_offset  ret_length. call method IN ANOTHER CONTRACT
      DELEGATECALL   |    |    |    | gas addr       args_offset args_length  ret_offset ret_length. call method IN ANOTHER CONTRACT
                     |    |    |    |                                                                using current storage (v.Homestead+/EIP-7)
      STATICCALL     |    |    |    | gas addr       args_offset args_length  ret_offset ret_length. call method IN ANOTHER CONTRACT
                     |    |    |    |                                                                with state changes disallowed
                     |    |    |    |                                                                (v.Byzantium+/EIP-214)
    • RETURN         |    |    |X   | offset length , Returns data from a portion of the EVM's memory. (return memory[offset:offset+length])
    --------------------------------- TX ABORT
    • REVERT         |    |    |X   | REVERT  offset  length  -   revert(memory[offset:offset+length])    Byzantium hardfork, EIP-140: reverts with return data FE  Invalid     -   -   -   -
    • STOP           |    |    |X   |unconditional halts execution
    --------------------------------- TX ABORT
    • LOG0...4       |    |    |    | Output Log (Indexed event) generation readable by clients
                     |    |    |    | LOG0(memory[offset:offset+length])  fires an event
                     |    |    |    | LOG1(memory[offset:offset+length], topic0)  fires an event
                     |    |    |    | LOG2(memory[offset:offset+length], topic0, topic1)  fires an event
                     |    |    |    | LOG3(memory[offset:offset+length], topic0, topic1, topic2)  fires an event
                     |    |    |    | LOG4(memory[offset:offset+length], topic0, topic1, topic2, topic3)  fires an event(vs OpCodes)
    --------------------------------- CONTRACT LIFE CYCLE
    • SELFDESTRUCT   |    |    |    | SELFDESTRUCT addr, destroy "this" contract, then sends all remaining funds to "addr".
    • CREATE2        |    |    |    | value offset length salt addr.  addr = new memory[offset:offset+length].value(value)
                     |    |    |    | (v.Constantinople+/EIP-1014). Creates child contract with deterministic address

[[}]]

● EVM ABI Spec: [[{10_EVM.abi]]
  Full reference:@[https://solidity.readthedocs.io/en/latest/abi-spec.html]

  - The encoding is not self describing and thus requires a schema in order to decode.
  - Interface functions of a contract are strongly typed
    (known at compilation time and static)
  - All contracts will have the interface definitions of any contracts they call a
    vailable at compile-time.
  - Data is encoded according to its type

  <b>FUNCTION SELECTOR:</b>
  - Keccak-256(hash-of-function-signature)[0,1,2,3]
                       ^------+---------^  ^^^^^^^
                              |            first 4 bytes of keccak256
                              |
                     - canonical expression of the
                       basic prototype without data
                       location specifier :=
                       funct.name with the parenthesised
                       list of parameter types split by a
                       single comma (spaces removed).
                     - Return type is  NOT  part of sign.
                       → No overriding by return type allowed.
                       (this help to keep function call
                        resolution context-independent)

  <b>ARGUMENT (and return value) ENCODING:</b>
  - Starting from fifth byte

  -  ELEMENTARY TYPES :
    - uint<M> : unsigned                integer type of 8,16,24,...256 bits,
    -  int<M> : two's complement signed integer type of 8,16,24,...256 bits,
    - address : typed uint160 (function selector uses address not uint160)
    - bool    : typed uint8 restricted to values 0, 1.
    -  fixed<M>x<N>: "M / (10    N)" value signed fixed-point decimal number
                     M bits from 8,16,...256
                     N bits from 0,8,...80
    - ufixed<M>x<N>: unsigned variant of fixed<M>x<N>.
    - fixed,   : synonyms for fixed128x18, ufixed128x18 respectively.
      ufixed
    - bytes<M>: binary type of M bytes, 0 < M <= 32.
    - function: an address (20 bytes) followed by a function selector (4 bytes).
                Encoded identical to bytes24.

  -  (fixed-size) array :
    <type>[M]: a fixed-length array of M elements, M >= 0, of the given type.

  -  non-fixed-size types exist :
    - bytes   : dynamic sized byte sequence
    - string  : dynamic sized unicode string assumed to be UTF-8 encoded
    - <type>[]: a variable-length array of elements of the given type

  -  tuple:  (or tuples of tuples, arrays of tuples,...)
    - (T1,T2,...,Tn): tuple consisting of the types T1, …, Tn, n >= 0

  -  Mapping Solidity to ABI types:
  Solidity     ABI Type
  contract     address
  enum         smallest uint type large enough to hold all values
  struct       tuple

   Formal Specification of the Encodin
  - We distinguish two types:
    - static : encoded in-place.
    - dynamic: encoded at a separately allocated location after the current block.
               - bytes
               - string
               - T[] for any T
               - T[k] for any dynamic T and any k >= 0
               - (T1,...,Tk) if Ti is dynamic for some 1 <= i <= k

  - Definitions:
    - len(a) :  (uint256) number of bytes in a binary string a
    - enc    :  actual encoding binary string:
                ABI_type_Value → enc(ABI_type_Value)
                                 ^^^^^^^^^^^^^^^^^^^
                             len(enc(ABI_type_Value)) depends on:
                                 - ABI_type_Value if type of ABI_type_Value is dynamic.
                                 - ABI_type       if type of ABI_type_Value is  static.

   Examples

  Given the contract:

  pragma solidity >=0.4.16 <0.7.0;

  contract Foo {
    function bar(bytes3[2] memory) public pure {}
    function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }
    function sam(bytes memory, bool, uint[] memory) public pure {}
  }

  Function call to FooInstance.baz(69, true)
                                                              0xcdcd77c0: the Method ID. 4 bytes of Keccak("baz(uint32,bool)")
      0x0000000000000000000000000000000000000000000000000000000000000045: uint32 "   69-value" left-padded
      0x0000000000000000000000000000000000000000000000000000000000000001: uint32 " true-value" left-padded

  Function return:
      0x0000000000000000000000000000000000000000000000000000000000000000: uint32 "false-value" left-padded


  Function call to FooInstance.bar("abc", "def")
                                                              0xfce353f6: the Method ID. 4 bytes of Keccak("bar(bytes3[2])")
      0x6162630000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned
      0x6465660000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned

  Function call to FooInstance.dave("dave", true and [1,2,3])
                                                              0xa5643bf2: the Method ID. 4 bytes of Keccak(sam(bytes,bool,uint256[]))
      0x0000000000000000000000000000000000000000000000000000000000000060: location of data-part of  first  dynamic-type  parameter
                                                                          measured in bytes from the start of the arguments block.
      0x0000000000000000000000000000000000000000000000000000000000000001: boolean true
      0x00000000000000000000000000000000000000000000000000000000000000a0: location of data-part of  first    third-type  parameter
                                                                          measured in bytes from the start of the arguments block.
                                                                          first dynamic-argument:
      0x0000000000000000000000000000000000000000000000000000000000000004: length of the byte array in elements
      0x6461766500000000000000000000000000000000000000000000000000000000: contents of the first argument
                                                                          second dynamic-argument:
      0x0000000000000000000000000000000000000000000000000000000000000003: length of the array in element
      0x0000000000000000000000000000000000000000000000000000000000000001: - first entry
      0x0000000000000000000000000000000000000000000000000000000000000002: - second entry
      0x0000000000000000000000000000000000000000000000000000000000000003: - third entry


   Events ABI Encodin
  - Log entries provide the contract's address,
  - Up to four topics
  - some arbitrary length binary data.

  Given an event name and series of event parameters, we split them into two sub-series:
   - indexed     parameters: used in Keccak-event-signature to form the topics of the log entry.
   - non-indexed parameters: byte array of the event.

  In effect, a log entry using this ABI is described as:
   - contract_address (emiting the event)

   - topics[0]: keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")

   - topics[n]: abi_encode(EVENT_INDEXED_ARGS[n - 1])
                           ^^^^^^^^^^^^^^^^^^
                         EVENT_ARGS that are indexed

   - data     : ABI encoding of EVENT_NON_INDEXED_ARGS


  - if type-byte-length <= 32 → value padded/sign-extended          to 32 bytes is included
  - if type-byte-length >  32 → Keccak hash of a special in-place encoded value is included
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                           - This allows applications to efficiently query for keyccak(value)
                             of dynamic-length types
                             but leaves applications unable to decode indexed values they have
                             not queried for
                           - Use the same dynamic value repeated in index and non-index event
                             fields for full functionallity.
[[}]]

• EVM Events & LOGS [[{10_EVM.101,10_EVM.events]]
  - In the wild, there are three main uses for event logs:
    - As external apps return values, because a transaction does not record a
      method's return values, only the hash confirming the transaction.
    - As a kind of cheaper alternative data storage, as long as the
      contract does not need access to it.
      According to the Yellow paper:
      "...There is no size limit to the data: you will be limited by how
          much Ether you have. (And of course the block gas limit.).The size
          limit of one event is a function of the block's gas limit, which as
          of now tends to be around 3,145,192 (i.e., the first seven digits of
          pi). According to Jonathan Patrick, logging costs 76 gas per byte. So
          I'd assume you could get in around 41kb per log event...."
    - Output evm device sending Event data that DApp clients can subscribe to.

  - Emiting an event is a simple EVM logging primitives (log0, log1, ..., log4)
    and a single Solidity

     - The EVM logging facility uses different terminologies than Solidity:

    instruction. e.g.:
    // Solidity event declaration:
    event accountDeposit( address indexed _from, bytes32 indexed _id, uint _value);
    ...
    // Solidity event emission:
    emit  accountDeposit( _from, _id, _value);

  - Event limitations :
    - There may be at most 3 indexed parameters.
    - If the type of an indexed parameter is larger than 32 bytes,
      only the KECCAK256 digest of the data is stored.

    "topics": (event indices). There may be up to 4, exactly 32 bytes each.
              Solidity consumes one topic for the event's signature so only 3 are available

    "data"  : Payload of the event. It may be arbitrary number of bytes.

  - NOTE: Internally Ethereum nodes use bloom indexes/filters to implement topics and
          topic search in order to speed up search-by-topic.

  - External clients must be able to restore current contract state [[{20_QA.BEST PATTERNS]]
    by just reading events.
  - Ethereum can return just a very limited information in each
    read-only query. (Up to 7 fields). That means that reports and
    data-analysis must be done on event logs.
  - Contract/s state/s must be consulted only by code originated by
    a new transaction trying to update the current state.

  - Logs: It is possible to store data in a specially indexed data structure
    that maps all the way up to the block level.
    This feature called 'logs' is used to implement events.
  - Contracts  CAN NOT  access log data after it has been created, but they
    can be efficiently accessed from outside the blockchain.
    Since some part of the log data is stored in bloom filters,
    it is possible to search for this data in an efficient and cryptographically
    secure way, so network peers that do not download the whole blockchain
    ("light clients") can still find these logs.
  - Logs were designed to be a form of storage that costs significantly
    less gas than contract storage:
    Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes.
    Up to 3 parameters can be indexed. [[}]]

   Event Limits:
  - Up to 3 indexed fields.
  - Up to 7 fields (indexed + non-indexed fields)
  - The size limit of one event is a function of the block's gas limit,
    ~ 3_145_192 (first seven digits of pi * 2)
    With a gas costs of 76 gas per byte limit is about 41kb per log event.
    REF: <a TODO href="http://jonathanpatrick.me/blog/ethereum-compressed-text"> Storing compressed text in Ethereum transaction logs</a>

   Solidity code:
  event EventDepositLog(
      uint256 indexed _market,  ← Up to 3 indexes
      address indexed _sender,    Strings, arrays can  NOT  be used in indexes
      uint256 _amount,            (will be automatically replaced by its hash)
      uint256 _time);

   JS Client Log monitoring:
  var myEventMonitor =
    myContract.MyEventNameLog(
       {_sender: userAddress },           // ← filter by idx sender
       {fromBlock: 0, toBlock: 'latest'}  // ← filter by block range*1
    );                                         if ommited observe
                                               "real-time" events

  myEventMonitor.watch(                  // ← Start watching
    (err, result) => {
      if (err) { ...    return; }
      console.log(
           "_market:"+result.args._market
         + "_sender:"+result.args._sender );
    }
  )
  ....
  myEventMonitor.stopWatching()          // ← Stop watching
[[}]]

● Solidity to storage address [[{10_EVM,persistence.contract_state,12_solidity,13_SLC.troubleshooting,13_SLC.debugging]]
REF: @[https://www.mayowatudonu.com/blockchain/deep-dive-into-evm-memory-and-storage]
  contract BlockVoting {
    Period[] dynArray01;        ← Idx 0x00..32bytes/64 hex-digits ...00
                                      - array length stored in next available slot
                                      - array data allocated at a slot number:
                                        hash of n(keccak256(n))
    uint public voteThreshold;  ← Idx 0x00..32bytes/64 hex-digits ...01
    mapping(uint8   => bool)    ← Idx 0x00..32bytes/64 hex─digits ...02  ←·············┐
      public map01;                   - slots are unused,                              ·
                                      - value for each key located at keccak256(n, p)←─┤
                                                                                ^  ^   ·
                                                                left padded to 32 bytes·
    uint8[] dynArray01;         ← Idx 0x00..32bytes/64 hex-digits ...                  ·
    ...                                                                                ·
    constructor () public {           $ truffle> compile                               ·
         voteThreshold = 10;          $ truffle> BlockVoting.new()                     ·
         dynArray01.push(20);                    .then(item => instance = item;)       ·
         dynArray01.push(30);         $ truffle> web3.eth                              ·
         dynArray01.push(56);                    .getStorageAt(instance.address, 0)    ·
         map01[1] =  5;  ←······┐     '0x0a' (== 10)$                                  ·
                                · ┌····················································┘
                                · ├ $ truffle(dev)> n = '00..32bytes/64 hex-digits ...02'
                                · ├ $ truffle(dev)> p = 'x0..32bytes/64 hex-digits ...01'
                                · ├ $ truffle(dev)> hash01 = web3.sha3(n + p, {encoding: 'hex'})
                                · │ 0xaca3b76ed4968740c3180dd7fa37f4aa229a2c758a848f53920e9ccb4c4bb74e
                                · └ $ truffle(dev)> web3.eth.getStorageAt( instance.address, hash01)
                                └ '0x05'                                                    ...
    }
  }

• NOTE: This can be used to pre-fill a hardcoded smart-contract
        with given status in genesis.json block:

  "alloc": {
    "0x0000000000000000000000000000000000000020": {
      "code": "0x6060604...6",
      "storage": {
        "0x0000000000000000000000000000000000000000000000000000000000000001": "0x02", ← Assign voteThreshold = 02
        "0x29ecdbdf95c7f6ceec92d6150c697aa14abeb0f8595dd58d808842ea237d8494": "0x01", ← dynArray01(1)
        "0x6aa118c6537572d8b515a9f9154be55a3377a8de7991cd23bf6e5ceb368688e3": "0x01", ← dynArray01(1)
        ....
        "0xaca3b76ed4968740c3180dd7fa37f4aa229a2c758a848f53920e9ccb4c4bb74e": "0x01"  ← Assign canVote[...]=0x01
        "0xd188ba2dc293670542c1befaf7678b0859e5354a0727d1188b2afb6f47fe24d1": "0x01"  ← Assign canVote[...]=0x01
      },
      "balance": "0"
    },
    ...
  }
[[}]]
[[}]]

● TRANSACTIONS [[{101,transaction.101,signature.ecdsa_secp256k1]]
  NOTE: a client Transaction in blockchain is an INTENTION to modify the state of the ddbb.
  It's up to the consensus algorithm to decide when and/or whether the TX will
  be accepted. Client Dapps (web-app/mobile app) must react asynchronously to
  future events. Only when the transaction is inserted in a block (and some future
  works have been mined -in non consensus with statistical finality -) it is considered
  as a valid transaction.
  ┌ ETHEREUM TRANSACTION ────┐  TX is encoded as   "RLPdata" (nonce,gasPrice,startGas,to,value,data)
  │                          │                   + signature (r, s, v)
  ├──────────────────────────┤
  │ • signature tuple        ←  EOA-wallet valid signature. Signature address must match "from"
  │                          │  sign.tuple == (signature_hash, v, r, s)  *1 Signature Details
  ├──────────────────────────┤
  │ • EOA-last-nonce + 1     ←  increasing counter avoid replay attacks. Multiple versions of
  │                          │  a TX can be sent with a repeated nonce overwriting pending TX.
  │                          │  Once mined, a submissions will be rejected.
  │                          │
  │ • address sender ("from")←  Must match EOA-address in TX signature, as a proof that from
  │                          │  is actually willing to pay for TX.
  │                          │
┌ │ • address target ("to")  ←  If to == 0            : it means "create contract"
│ │                          │  if to == EOA          : standard wallet-to-wallet payment
│ │                          │  if to == (deployed) SC: Write/Modify/Update Function invocation.
│ │                          │  NOTE: Read-only queries (view/pure functions) do not need a TX
│ │                          │        An standard JSON-RPC with func.params query is enough.
├ │ • byte[]  code("payload")←  if target == 0: compiled bytecode factory for contract.
│ │                          │  Otherwise abi-encoded function call. If encoded function (selector)
│ │                          │  doesn't match any function in S.C. code, its fallback function will
│ │                          │  be invoqued. Otherwise, an exception will be raised.
│ │ • wei ether              ←  ether sent/paid to target/"to"
│ │                          │
│ │                          │
│ │ • wei gasPrice           ←  desired gas price TX signer will pay to miners for  1-unit-of-gas
│ │                          │  when running code.   Used by miners to prioritize TXs .
│ │                          │
│ │ • wei gas                ←  When multiplied by TX.gasPrice == desired max.Ether to pay
│ │                          │  for executing TX. Its purpose is to limit max.
│ └──────────────────────────┘  amount-of-work needed to execute invoqued S.C. code.
│
└ if target == "zero" then:
     step 1: new contract created
     step 2: transaccion.payload executed
     step 3: exec. output stored on-chain at (contract)account.code

  *1  Signature Details: @[https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3]
   - SECP256K1 (one of the ECDSA supported algorithms) is used for signature.
     SECP256K1 Output signature is composed of two integers (r,s) but SECP256K1 ETH/BTC library, however,
     defines the public key as (r, s, v), where v := 0|1. (v is called the recovery id).
     when public key is derived  from the signature  two solutions surge and v is needed.
     - if derived-public-key length is 64 bytes (r,s)   is used.
     - if derived-public-key length is 65 bytes,(r,s,v) is used.
     More info at @[https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v]
     Ethereum makes further adjustments to v in order to prevent replay attack as explained in
     @[https://github.com/ethereum/EIPs/issues/155]]

     · 'ecrecover': Solidity Global Crypto Funct can be used to recover the address given the signature.
       function ecrecover
       (bytes32 signature_hash, uint8 v, bytes32 r, bytes32 s)
       view
       returns (address)   ← Original address associated with the public key (zero on error)
                             Can be used for N/M signatures (See @[#eip-191])

     - NOTE: The use of Curve25519 with Schnoor signing scheme (Ed25519) is under discussion

     - NOTE: Only Externally Owned Accounts can sign transactions. EIP-1271 offers a
       "abstraction" of signature as described in @[eip-1271].



  TX SENDER-to-MINER PAYMENT RULES:
  • If ( execution gas < transaction.gas ) { Refund rest to sender }
  • If ( execution gas > transaction.gas ) {
      · out-of-gas exception triggered.
      · modifications made to the state in current call frame reverted.
      · TX is still mined, and weis lost BUT there is no state change.
    }


  BLOCK VALIDATION ALGORITHM (CONSENSUS)
  ======================================
  - Check if previous block referenced exists and is valid
  - Check ( last_block.timestamp < new_block.timestamp < lst_block.timestamp + 15 minutes )
  - Check block-number, difficulty, transaction root, uncle root and gas limit
    (various low-level Ethereum-specific concepts) are valid.
  - Check that proof-of-work is valid.
  - Let S[0] be the STATE_ROOT of the previous block.
  - Let TX be the block's transaction list, with n transactions. For all "i" in
    0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any application returns error, or
    if the total gas consumed in the block up until this point exceeds consensus
    constant BLOCK.GASLIMIT, return error.
  - Let S_FINAL be S[n], but adding the block reward paid to the miner.
  - Check if S_FINAL == STATE_ROOT.

[[}]]

● EIP-191: Signed Data Standard (Multisignature TXs) [[{signature.multisignature,02_use_case.identity,standards.eip/erc.191,00_PM.TODO]]
@[https://eips.ethereum.org/EIPS/eip-191]
@[https://github.com/ethereum/EIPs/issues/191]
- See also @[#eip-712]

  - Several multisignature wallet implementations have been created
    which accepts presigned transactions (chunk of binary signed_data,
    along with signature (r, s and v) ).
    interpretation of the signed_data has not been specified, leading to
    several problems.
    - Standard Ethereum transactions can be submitted as signed_data.
    - An Ethereum transaction can be unpacked, into:
      - RLP<nonce, gasPrice, startGas, to, value, data> (called RLPdata),
      - r, s and v.

  - Multisignature wallets have also had the problem that a presigned
    transaction has not been tied to a particular validator, i.e a specific
    wallet. Example:
    · Users A, B and C have the 2/3-wallet X
    · Users A, B and D have the 2/3-wallet Y
    · Users A and B submites presigned transaction to X.
    · Attacker sends presigned transactions to Y (instead of X).

Example code:
@[https://github.com/0xsequence/erc-1155/blob/master/SPECIFICATIONS.md#meta-transactions]

  • EIP-4361: Using EIP-191 for Offchain client Auth.: [[{20_QA.UX}]]
  @[https://github.com/spruceid/EIPs/blob/eip-4361/EIPS/eip-4361.md]
  @[https://ethereum-magicians.org/t/eip-4361-sign-in-with-ethereum/7263/2]

  - Scenario:
    "https://service.org" wants to authenticate user through its Ethereum account:
      0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2

    ┌─ Example message to be signed ────────────────────────────────────────┐
    │ I accept the ServiceOrg Terms of Service: https://service.org/tos     │
    │                                                                       │
    │ URI: https://service.org/login                                        │
    │ Version: 1                                                            │
    │ Chain ID: 1                                                           │
    │ Nonce: 328917                                                         │
    │ Issued At: 2021─09─30T16:25:24Z                                       │
    │ Resources:                                                            │
    │ ─ ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/ │
    │ ─ https://example.com/my─web2─claim.json                              │
    └───────────────────────────────────────────────────────────────────────┘
    - For EOAs              verification method in EIP-191  MUST be used.
    - For Contract Accounts verification method in EIP-1271 MUST be used.
[[}]]


● TX Gas Price [[{101,transaction,10_EVM.gas_price,10_EVM.events,privacy.zksnark,scalability.consensus}]]
• REFs:
  @[https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees]
  @[http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html?highlight=gas#what-is-gas]
• Gas rationale:
  · Gas protect against DoS attacks and buggy nodes, EVMs, and/or smart-contracts.
  · Price cost applies to public network and (optionally) to private/consortium networks.
    NOTE: private/consortium networks will still be constrained to
          gas limits even when gas price is ZERO. [TODO]: Recheck
  · TXs will fail if the consume too much gas ("CPU" or storage)
  but users will not loose any ethers when price is set to ZERO.


• See gas consumption per OpCode:
@[https://github.com/ethereum/pyethereum/blob/master/ethereum/opcodes.py]
  # NON-OPCODE GAS PRICES
  GDEFAULT           =     1
  GMEMORY            =     3
  GQUADRATICMEMDENOM =   512  # 1 gas per 512 quadwords
  GSTORAGEREFUND     = 15000
  GSTORAGEKILL       =  5000
  GSTORAGEMOD        =  5000
  GSTORAGEADD        = 20000
  GEXPONENTBYTE      =    10 # cost of EXP exponent per byte
  GCOPY              =     3 # cost to copy one 32 byte word
  GCONTRACTBYTE      =   200 # one byte of code in contract creation
  GCALLVALUETRANSFER =  9000 # non-zero-valued call
  GLOGBYTE           =     8 # cost of a byte of logdata

  GTXCOST            = 21000 # TX BASE GAS COST
  GTXDATAZERO        =     4 # TX DATA ZERO BYTE GAS COST
  GTXDATANONZERO     =    68 # TX DATA NON ZERO BYTE GAS COST
  GSHA3WORD          =     6 # Cost of SHA3 per word
  GSHA256BASE        =    60 # Base c of SHA256
  GSHA256WORD        =    12 # Cost of SHA256 per word
  GRIPEMD160BASE     =   600 # Base cost of RIPEMD160
  GRIPEMD160WORD     =   120 # Cost of RIPEMD160 per word
  GIDENTITYBASE      =    15 # Base cost of indentity
  GIDENTITYWORD      =     3 # Cost of identity per word
  GECRECOVER         =  3000 # Cost of ecrecover op

  GSTIPEND           =  2300

  GCALLNEWACCOUNT    = 25000
  GSUICIDEREFUND     = 24000

• The most expensive operations by far are storage ones :
  ┌─────────────┬───────┬────────────────────────────────────────────┐
  │Operation    │   Gas │ Remark                                     │
  │Name         │ Spent │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │step         │     1 │ default amount per execution cycle         │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │stop         │     0 │ free                                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │suicide      │     0 │ free                                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │self-destruct│-24000 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sha3         │    20 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sload        │    20 │ get 32-bytes from permanent storage        │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sstore  op   │   100 │ put 32-bytes into permanent storage        │
  │             │       │ (+ ~ 20000 by setting     zero → non-zero) │
  │             │       │ (- ~ 10000 by setting non-zero → zero)     │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │balance      │    20 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │create       │   100 │ contract creation                          │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │call         │    20 │ initiating a read─only call                │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │memory       │     1 │ every additional word when expanding memory│
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │txdata       │     5 │ every byte of data or code for a TX        │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │transaction  │   500 │ base fee transaction                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │contract     │ 53000 │ changed in homestead from 21000            │
  │  creation   │       │                                            │
  └─────────────┴───────┴────────────────────────────────────────────┘
  - Most instructions costs 3~10 gas.
  - Gas costs are set somewhat arbitrarily, and will change/adapt in the future.
  - As costs change, compilers will make different choices.

• TX cost:
  @[https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603]
  ✓ 21000 gas per TX (fixed cost)
  ✓     4 gas per     zero-byte of data|code
  ✓    68 gas per non-zero-byte of data|code
    WARN : Small negative numbers are mostly 1s, costing quite a lot of gas.

• LOGGING (INMUTABLE EVENTS) GAS COSTS:                        [events]
@[https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9]
  • gas costs for evm logging primitives depends on number of topics (indexes)
    and payload length:
    (constants are defined in protocol_params)

    ✓   8 gas per byte in a LOG operation's data LogDataGas
    ✓ 375 gas per LOG                            topicLogTopicGas
    ✓ 375 gas per LOG operation                  LogGas
    ✓   3 gas per byte of payload                MemoryGas

    ✓ ??? gas per data in calldata if source log
          data comes from mined TX
          (4 gas per zero-byte, 64 per non-zero-byte)

      HINT : event with all non-zero bytes called from external
             TX it is still a lot cheaper than storage.
             • 3200 no-zero-bytes log gas   TX FIXED COST(log or sstore) :
               (external signed TX sent from wallet/client dApp)

               Concept                     Unit *         Sub
                                           Unit-cost      Total
               ─────────────────────────────────────────────────
               TX cost                    |   1 * 21000 |  21000
               external tx non-zero-bytes |3200 *    68 | 217600 ← TIP: optimize non-zero-bytes
               TX data|code byte          |3200 *     5 |  16000
                ────────────────────────────────────────────────
                                                  TOTAL   254600

             • 3200 no-zero-bytes log gas bill:
               Most gas cost is TX data, not log ops itself.

               Concept                     Unit *            Sub
                                           Unit-cost       Total
               ─────────────────────────────────────────────────
               TX FIXED COST              |   1 * 254600| 254600 ← Most gas cost is TX data,
               log-data-cost              |3200 *      8|  25600   TIP: optimize input data
               memory usage cost          |3200 *      3|   9600
               log call cost              |   1 *    375|    375
               ─────────────────────────────────────────────────
                                                  TOTAL   290175 ~ 7.8 times cheaper

             • 320 no-zero-bytes sstore bill:
               Concept                     Unit *            Sub
                                           Unit-cost       Total
               ─────────────────────────────────────────────────
               TX FIXED COST              |   1 * 254600| 254600
               memory usage cost          |3200 *      3|   9600
               sstore op                  | 100 *    100|  10000
               sstore zero → non-zero     | 100 *  20000|2000000
               ─────────────────────────────────────────────────
                                                  TOTAL  2274200
             • The real reason is for lower prices is that log data is NOT
               really stored as blockchain status. Logs, in principle, can
               be recalculated on the fly as necessary.
               TX validation (by miners) will not access past logs.

             • Network as a whole does not bear the cost of logs.
               Only API service nodes need to actually process, store,
               and index the logs.
             • cost structure is kept  minimal t  prevent log spammin  .

● Watch Out default gas price!!!
• Extracted from stack-overflow:
   Q: """ETH (to USD) price has gone from ~8 to ~90 USD in 6 months
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         I see that most people are still using default gas price of
         2e10 wei/gas. Shouldn't we be lowering the gas prices per TX
         to account for this price change?
         ... I intend to drop fee gas price by 75%. Will TXs still be
         mined in a timely fashion?"""
   A: ...Absolutely. Everyone should. There's a great site here that
         will help you understand gas and gas prices.
        It's called Ethereum Gas Station: http://ethgasstation.info/
        They just recently made this post which explains something they
        call the Safe Gas Price:
      @[https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91]

● EIP 1559: [[{scalability,10_EVM.gas_price]]
  @[https://blog.ethereum.org/2020/06/16/eth1x-1559/]
  • Problem Context:
    • TX gas price can spike when block ussage is close to full.
    • wallets trying to pay "fast" (vs waiting for TX demand/fees
      to go down) might end up paying ridiculous fees.
      (Supported by Besu and other clients).
  • EIP-1559 dramatically alter how gas fees are calculated.
    • TX fees broken into two categories:
      ✓ base fee  :  predictable  based on how TX number in last block.
        · base fee will be burned (removed from circulation)  vs going
          into miner's pockets.
        · base fee dynamically adjust so that the overall gas usage in
          a block moves toward the current limit of 10 million gas.

      ✓ Miner tip : added at will by TX users in order to incentivize
                    miners to include their TX in mined block.

  NOTES:
   • EIP-1559 does NOT reduce TX fees.
[[}]]

● gas price calc: {{{
    : WARN:
  - Extracted from @[https://medium.com/hackernoon/costs-of-a-real-world-ethereum-contract-2033511b3214]
    """(2017–08–23) The median gas price at the time of writing this article was,
    and continues to be, in the realm of 20 Gwei. This is far greater than the
    typical average and safe-low found on EthGasStation (4 and 0.5 Gwei respectively).
    The median is so high because of bad gas-price defaults found in many wallets.
    I highly recommend using EthGasStation's average gas-price or lower in order
    to not pay high fees and to help drive down the market rate for gas-price."""

  @[http://ethgasstation.info/calculator.php]
  Gas (defined in the [Ethereum-Yellow-Paper]):
  - virtual pricing mechanism for TXs (ether transfer and smart contracts controlled)
  - Protect against Denial of Service attacks and resource-consumption attacks
    by compromised, malfunctioning or malicious nodes.
  - EnterpriseEthereum provides additional tools to reduce security risks, such
    as more granular permissions for actions in a network or node-entrance
    firewalls and allowed/denied list of valid TX signers

  Taking a reference ratio of 200€/ether:
    Fixed Costs:
     └ TX gas price: 21000 gas/tx
       ┌──────────┬─────────────────┬────────┐
       │ gasprice │ total gas price │ total €│
       ├──────────┼─────────────────┼────────┤
       │  1gwei   │ 21000 x  1gwei  │ 0,0042 │
       │ 20gwei   │ 21000 x 20gwei  │ 0,0840 │
       └──────────┴─────────────────┴────────┘

    Internal Storage Costs:
    └ 32bytes Contract storage: 20000 gas
      ┌──────────┬─────────────────┬────────┐
      │ gasprice │ total gas price │ total €│
      ├──────────┼─────────────────┼────────┤
      │  1gwei   │ 21000 x  1gwei  │ 0,004 €│
      │ 20gwei   │ 21000 x 10gwei  │ 0,080 €│
      └──────────┴─────────────────┴────────┘
    └ Total TX cost for 64 bytes  (32bytes from debitor to creditor account)
      ┌──────────┬─────────┐
      │ gasprice │ total € │
      ├──────────┼─────────┤
      │  1gwei   │ 0,0122  │ 0,0042 (TX fix cost) + 2 x 0,0040 (32bytes Contract storage)
      │ 20gwei   │ 0,2440  │
      └──────────┴─────────┘

    LOGS-COST:
    └ ┌───────┬───────┬────────┬────────────┬────────────────────────────────────┐
      │size in│ num.of│ gas    │total       │  total €                           │
      │  bytes│ topics│ price  │gas price   │  (200€/eth)                        │
      ├───────┼───────┼────────┼────────────┼────────────────────────────────────┤
      │       │       │        │            │  LOG Cost   TX Cost                │
      │       │       │        │            │ ┌───────┐   ┌────┐                 │
      │  1024 │   3   │ 1gwei  │9692 x 1gwei│ 0,0019384 + 0,0042 € = 0.0061384 € │
      │   512 │   3   │ 1gwei  │5596 x 1gwei│ 0,0011192 + 0,0042 € = 0.0053192 € │
      │   256 │   1   │ 1gwei  │2798 x 1gwei│ 0,0005596 + 0,0042 € = 0.0047596 € │
      │   128 │   0   │ 1gwei  │1399 x 1gwei│ 0,0002798 + 0,0042 € = 0.0044798 € │
      ├───────┼───────┼────────┼────────────┼────────────────────────────────────┤
      │       │       │ 20gwei │9692 x20gwei│ 0,0387680 + 0,0840 € = 0.1227680 € │
      │   512 │   3   │ 20gwei │5596 x20gwei│ 0,0223840 + 0,0840 € = 0.1063840 € │
      │   256 │   1   │ 20gwei │2798 x20gwei│ 0,0111920 + 0,0840 € = 0.0951920 € │
      │   128 │   0   │ 20gwei │1399 x20gwei│ 0,0055960 + 0,0840 € = 0.0895960 € │
      └───────┴───────┴────────┴────────────┴────────────────────────────────────┘
                                └┬─┘
                                 └─────────────────────────────────────────────────────────┐
       NEW LOG GAS          LOG BYTES GAS         TOPIC ("INDEX")GAS                   TOTAL GAS
      ┌───────────┐   ┌─────────────────────┐   ┌─────────────────┐                       ┌┴─┐
      (375 gas/LOG) + (8 gas/byte x 1024byte) + (375 gas/topic * 3) = 375 + 8192 + 1125 = 9692
      (375 gas/LOG) + (8 gas/byte x  512byte) + (375 gas/topic * 3) = 375 + 4096 + 1125 = 5596
      (375 gas/LOG) + (8 gas/byte x  512byte) + (375 gas/topic * 1) = 375 + 2048 +  375 = 2798
      (375 gas/LOG) + (8 gas/byte x  128byte) + (375 gas/topic * 0) = 375 + 1024        = 1399
                       ^^^^^^^^^^
                     ☞ This means 256 gas for 32bytes, version 20.000 gas for 32 bytes
                       in internal storage.   78.125 times cheaper per byte !!
                                               FIX TX cost not included
}}}
● EVM: Calls vs TXs: [[{01_doc_has.comparative,101,10_EVM.101]]
  Imagine a solidity code similar to:

    contract Voting {
      mapping (uint /*proposal */=> uint /*total votes*/) countMap;
      event totalForProposal(uint total)
      ...
      function vote(uint proposalID)
      returns (uint total) {
         countMap[proposalID] = votes[proposalID]++;
         unit   result  = countMap[proposalID];
         emit totalForProposals(  result )
         return   result
      }
      ...
    }
  This is function will modify the state of the blockchain
  (it's not a "view"  or "pure" function in Solidity parlance)

  Calling this function from "outside" the blockchain is done through
  a criptographically signed transaction. The module (mobile wallet,
  middleware,...) sending the signed transaction will wait indefinetely
  while the TX is first propagated through the network to a mining node
  , then mined (the miner executes the contract) and the TX receipt
  received later on in a mined block).
  The only way tthis external module has to fetch the result of the
  function is through asynchronous eventsi,

  This same function can be called in the mid of another transaction
  when another method indirectly call it. This time, and that's why
  the solidity code includes an "emit totalFroProposals..." as to
  allow the module to be notified of the result.

  - This function can also be part of a bigger execution path an called
  in the mid of an started transaction. The EVM will already be executing
  some method that in turn calls this "vote" function as part of a
  normal program execution. When the "vote" function returns it has
  access to the returned result since it has been placed on the EVM
  stack. The emitted event is ignored (actually will be included in
  the block after mining to be propagated back to any listening
  application).

  Note also that we can have read-only functions ("view" or "pure"
  in Solidity parlance"). In that case both an external module or
  an internal function can fetch the returned value inmediatelly
  (there is no TX propagation or mining and all the needed data
  is local to the closest ethereum node -geth, parity,...-).
  The javascript web3js (or java web3j or ...)
  In the case of the external module through an RPC call, and in
  the case of an internal EVM function through the (much faster)
  EVM stack.
[[}]]

● EVM State transition function [[{transaction.101,10_EVM.101]]
APPLY (S, TX) → S'  ← S : initial global state
                    ← S': final   global state
 can be defined as follows:
- Check if incomming TX is well-formed (right number of values),
  signature is valid, and the nonce matches the nonce in the
  sender's account.  Return an error otherwise.
- Calculate the transaction fee as STAR_GAS * GAS_PRICE, and
  determine the sending address from the signature. Subtract the
  fee from the sender's account balance and increment the
  sender's nonce. If sender's balance < fee, return an error.
- Initialize GAS = STARTGAS, and take off a certain quantity
  of gas per byte to pay for the bytes in the transaction.
- Transfer the TX value from the sender's account to the
  receiving account.  If the receiving account does not yet
  exist, create if. If the receiving account is a contract,
  run the contract's code either to completion or until the
  execution runs out of gas.
- If the value transfer failed because the sender did not have
  enough money, or the code execution ran out of gas, revert
  all state changes except the payment of the fees, and add
  the fees to the miner's account
- Otherwise, refund the fees for all remaining gas to
  the sender, and send the fees paid for gas consumed to the
  miner.
[[}]]

● Offline/Online TX signing: [[{wallet.101,transaction.signature]]
    OFFLINE TX SIGNING (RECOMENDED)           |    "ON-LINE" TX SIGNING (LESS SECURE, DISCOURAGED)
                                              |
The "raw" TX must be signed first             | - An Ethereum node (geth, parity,...) will be used.
by an offline (js,python,hardware wallet,...) | - It forces to have the wallet on the client node and
client using a private key ("wallet")         |   unlock the account. Unless the wallet is hardware
with or without connection to any ethereum    |   secured is usually less safe than client signature
network node.                                 |   (but offline clients can also be insecure or
The signed TX is then sent to the network.    |   hacked)
[[}]]

● EIP-2535 Diamons: [[{101,10_EVM,persistence.contract_state,persistence.data_structure]]
                    [[20_QA.UX,20_QA.solidity,12_solidity.upgradable_contracts,13_SLC.troubleshooting,standards.eip/erc.2535]]
@[https://eips.ethereum.org/EIPS/eip-2535]
  - About EIP-170 24K Max Contract Size
    @[https://ethereum-magicians.org/t/removing-or-increasing-the-contract-size-limit/3045]
     (See original link for -very- detailed info)
    - 24K max. size is used to prevent denial-of-service attacks.
      ( O(n) for disk-read resources, code-preprocessing, Merkle proof data )

      Note:  Private chains allow to tune max.contract size in consortium / private networks
             but the EIP-2535 is compatible with MainNet and provide other features to upgrade
             contracts (or a subset of functions "inside" the contract) through proxies.

  - Possible Solutions changing Ethereum Implementation
    - Increase contract size limit.
    - Increase cost of relevant opcodes (CALL, ...)
    - Allow infinite contract size by Implementing paging of contract code
      (suggested by @SergioDemianLerner) and "paying" for extra pages:
      - first page loaded for free
      - jumping into another page pays a fee (500 gas) to fetch from disk.
    - Allow infinite contract size and make the cost of OPCODES like CALL
      dynamic to allow for this change. Code size will still be limited by
      block gas limit. ( moderate difficulty change but makes a lot of sense IMO)
      - In detail:
        - ethereum account   (array in state trie)
          ----------------
           nonce
           balance
           storageRoot
           codeHash        New proposed addition
           codeSize     ←  · immutable value after deployment
                           · reseted at contract destruction.

        - CALL, DELEGATECALL, CALLCODE , ... opcodes should charge additional
          gas per extra word if contract code size greater than 24KB.
      - Rationale
        contract size limit used only to prevent exploiting fixed costs.
        Can be overcomed by making costs variable.'codeSize' helps in calculating
        call cost before reading the whole contract failing fast with Out-of-Gas.
        - Merkle proofs will be generated at a fixed cost as we won't have
          to load whole contracts from disk first. 'codeSize' should be enough
          for generating Merkle proofs of calls that will throw OOG.
      - no extra cost charged to existing contracts ( they are all under 24KB).

  - proxy pattern: (Compatible with current EIPs and implementations
    - Allows to store S.C. code in different contracts using a "dispatcher"
      contract to calls delegating calls to real contracts.
      (e.g.: ZeppelinOS's upgradability contracts, EIP-#1538)
    - Proxy Contract == "Stay small by borrowing functions from other
                        contracts using low level opcode "delegatecall".

  - Proxy Pattern Limitations
    - extra unnecessary code.
    - Proxy patterns add another attack vector.
    - Proxy patterns make contracts calls more expensive
      ( Proxy must copy params, then make external delegate call).
    - Proxy patterns (e.g.EIP-1538) make inter-logic contract call
      (a lot) more expensive:
       external →  proxy    →  contract → contract2
       call        contract    call
    -  hurt readability for the end user:
      - proxy contract code/ABI is different from real delegated code.
        most people can barely use the read/write features in etherscan,
        they can't load a custom ABI and make web3 calls.
    - development is slightly more complex.
    - harder to verify actual code.
    - Loading a large contract will be fast-sequential read while loading
      multiple small ones will be slow-random read.

  • EIP-2535 Diamon Standard (STANDARD FOR PROXY CONTRACTS)
    - COMPILER AWARE UPGRADABILITY OF CONTRACTS USING FACETS !!!!  by Nick Mudge
      Replaces "EIP-1538 Upgradeable Contracts" (also by Nick Mudge).
    - The idea is to use a proxy contract with an internal database that maps
      each function implementation to a different contract (address).

    - STATE AND FUNCTIONS ARE KEPT TOGETHER UNDER THE SAME ETHEREUM ADDRESS.
      MAKING EASIER AND MORE FLEXIBLE TO ACCESS/MODIFY CONTRACT STORAGE.

    - PROVIDES A FLEXIBLE AND TRANSPARENT METHOD TO SUPPOR UPGRADEABLE DIAMONDS.

     """ ... A diamond could be structured like this:
         • The diamond has 10 facets.
         • Each facet has N functions.
         • Each facet covers a distinct area of functionality.
           (ownership, identity, NFT, ...)
         • Each facet has its own state variables declared it its own
           Diamond Storage contract, or it shares state variables with a small
           number of facets via one or more Diamond Storage contracts.
     """

  • DIAMON STORAGE PATTERNS
  @[https://medium.com/1milliondevs/solidity-storage-layout-for-proxy-contracts-and-diamonds-c4f009b6903]
  @[https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb]

  • PROBLEM CONTEXT:
    Standard Storage Layout rules for non-proxy contracts:
    ======================================================
    - 1st state variable stored at position 0,
      2nd state variable stored at position 1,
                └─────────────┘
      ...
      this also include arrays/maps "pointers" (vs arrays/map values)
    - Dynamic arrays/maps store values at positions based on
      hash (array|map pointer-storage-position, array-index|map-key).

    When using proxies COLLISIONS WILL ARISE  since (at compilation time)
    Solidity is not aware of "peer" contracts implementing the proxy.

    ┌───────────────────── PROPOSED SOLUTIONS/STORAGE-PATTERNS ***BEFORE DIAMON STANDARD**** ───────────────────────────────────────────────────┐
    | UNSTRUCTURED STORAGE, using assembly,           | INHERITED STORAGE:                         | ETERNAL STORAGE PATTERN:                   |
    ├─────────────────────────────────────────────────┼────────────────────────────────────────────┼────────────────────────────────────────────|
    |                                                 |- proxy contract + facets inherit a storage |Both proxy/ies and facet/s use a general    |
    |contract ProxyA {                                |  contract with storage variables used      |storage based on maps                       |
    |    const bytes32 STATE01_POS =                  |  ensuring no collision arise.              |contract .... {                             |
    |          = keccak256("state01");                |                                            |   mapping(bytes32 => uint256  ) uIntStore; |
    |    function getState01() ...                    |                                            |   mapping(bytes32 => string   ) stringStore|
    |    returns(address state01) {                   |                                            |   mapping(bytes32 => address  ) addrStore; |
    |      assembly { state01 := sload(STATE01_POS) } |                                            |   ...                                      |
    |    }                                            |                                            |                                            |
    |    function setstate01(address state01) ... {   |                                            |   function (...) {                         |
    |      assembly { sstore(STATE01_POS, state01) }  |                                            |      return addressStorage["user"];        |
    |    }                                            |                                            |      addrStorage["user"] = newUser;        |
    |}                                                |                                            |  }                                         |
    |                                                 |                                            |}                                           |
    ├─────────────────────────────────────────────────┼────────────────────────────────────────────┼────────────────────────────────────────────┤
    |DOWNSIDES:                                       |DOWNSIDES:                                  |DOWNSIDES:                                  |
    |• One getter+setter function for each storage var|• Facets need to inherit storage contracts  |• Clumsy syntax.                            |
    |• It does not work for complex types             |  that they don't use breaking the basic    |• It          works for values|arrays       |
    |  (structs, mappings, ...).                      |  "IS-A" inheritance rule in OOP.           |  it does not work  for mapping|struct vals.|
    |                                                 |• Facets become tightly coupled to specific |  (in simple/generic way).                  |
    |                                                 |  proxy contracts (Due to the "IS-A" inher.)|• proxies and facets forced to use the same |
    |                                                 |• facets CANNOT be used by other proxy      |  storage API.                              |
    |                                                 |  contracts declaring different state vars. |• Not easy to see at what state var. exist  |
    |                                                 |                                            |• More gas needed than direct access.       |
    |                                                 |                                            |                                            |
    ├─────────────────────────────────────────────────│ ────────────────────────────────────────────────────────────────────────────────────────│
    |• proxy-contract delegates on single pattern.    |• good for diamonds delegating to different facets depending on which function is called.|
    └───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

    KEYPOINT: Solidity v0.6.4+ allows to set storage slots for storage reference
      variables from inline assembly within solidity code (bypassing
      default Compiler default storage patterns causing conflicts among
      proxy instances ). @[https://github.com/ethereum/solidity/releases/tag/v0.6.4]
      allowing new storage patterns for delegatecall-proxies/upgradable contracts.

    ┌─ DIAMOND STORAGE PATTERN : NO STORAGE DOWNSIDES !!! ──
    │ PRE-SETUP: Create Storage Contract/s:
    │ → Create a "Diamond Storage contract" for
    │   each storage "interface implementation".
    │   → Inside it, create struct/s with suitable
    │     state variables for the interface implementation.
    │     → Choose a position in storage for the struct/s.
    │       → Write a function inisde the storage contract
    │         creating and returning the storage pointer.
    │ 
    │ Identity: example of "orthogonal facet" (vs Tokenization, MarketPrice,...)
    │ ┌ e.g: ────────────────────────────────┐
    │ │ contract MyIdentityStorageContract { <·· Create one for each storage pattern
    │ │   struct MyIdentityStorage {         <·· Struct reused by Facets. 
    │ │     uint aVar;                       │
    │ │     bytes myBytes;                   │
    │ │     mapping(uint => bytes32) myMap;  │
    │ │   }                                  │
    │ │                                      │
    │ │   function myIdentityStorage()    <··· Public func. used by proxies/facets
    │ │   internal pure                      │
    │ │   returns(MyStorage storage ms) {    │
    │ │     assembly {                       │
    │ │      ms_slot := 0xabcd55b489......<···· keccak256("com.comp1.identity.storage")
    │ │     }                                │  Namespaces come for free!!!
    │ │   }                                  │
    │ │ }                                    │
    │ └──────────────────────────────────────┘
    │ KEYPOINT: 
    │  For each contract/proxy/facet using the storage contract: 
    │  → inherit storage contract
    │    → call the function returning the storage pointer.
    │
    │ ┌─ e.g. Storage "consumer" ──────────────┐
    │ │ contract MyIdentityFacet is ...        │
    │ │         MyIdentityStorageContract {    │
    │ │   constanct MyIdentityStorage         <·· Instantiate
    │ │     storage IDS = myIdentityStorage(); │  Storage
    │ │                                        │
    │ │   function ...(...) external {         │
    │ │     MS01.myMap[selector] = myData;    <·· Write to
    │ │     MS01.aVar = uint(myData);          │      
    │ │     ...                                │
    │ │     bytes32 data = IDS01.             <·· Read from
    │ │                     myMap[selector];   │
    │ │     ...                                │
    │ │   }                                    │
    │ │ }                                      │
    │ └────────────────────────────────────────┘
    └─────────────────────────────────────────────────────

   • interface IDiamondCut {
     ·  enum FacetCutAction {
     ·    Add/*0*/, Replace/*1*/, Remove/*2*/
     ·  }
     ·
     ·  struct FacetCut {
     ·      address facetAddress;
     ·      FacetCutAction action;
     ·      bytes4[] functionSelectors;
     ·  }
     ·
     ·  function diamondCut(                    ● CONTROL FUNCTION (Add/update/del funs)
     ·      FacetCut[] calldata _cut,
     ·      address _init,                  <-··· (Opt) facet address to execute _calldata
     ·      bytes calldata _CD              <-··· (Opt) fun to call, including fun selector+args
     ·  ) external;
     ·
     ·  event DiamondCut(
     ·      FacetCut[] _diamondCut, 
     ·      address _init,
     ·      bytes _calldata);
     }
    
   • interface IDiamondLoupe {                   ● READ-ONLY INTROSPECTION
     · 
     ·  struct Facet {
     ·      address facetAddress;
     ·      bytes4[] functionSelectors;
     ·  }
     ·
     ·  function 
     ·    facets()
     ·    external view
     ·    returns (Facet[] memory facets_l);      <- ALL THE FACET ADDR.+FUNS. in diamon
     ·
     ·  function
     ·    facetFunctionSelectors(address _facet) 
     ·    external view
     ·    returns (bytes4[] memory facetFun_l);   <- ALL fun.selectors used from _facet
     ·
     ·  function 
     ·    facetAddresses()
     ·    external view
     ·    returns (address[] memory facetAddr_l); <- ALL used facets
     ·
     ·  function 
     ·    facetAddress(bytes4 _funSelector)
     ·    external view
     ·    returns (address facetAddress_);        <- facet address implementing fun.
     ·}

    ┌─ DIAMOND IMPLEMENTATION S.C. ────────────────────┐
    │                                                  │
    │ mapping (bytes4 ←································ function 'ABI'
    │          => address  ←··························· SC. instance
    │ ) internal FACETS_DDBB;                          │address.
    │  e.g.:                                           │
    │  e2532512(func1)  => 0x0....contract "Facet" A <··┐     facetA┐
    │  ───────────────     ─────────────────────────   │├─────│S.C. │
    │  253e253A(func2)  => 0x0....contract "Facet" A <··┘     └────┬┘
    │  ───────────────     ─────────────────────────   │           │
    │  FA539B19(func3)  => 0x0....contract "Facet" B <··┐          │
    │  ───────────────     ─────────────────────────   ││   facetB┐│
    │  D38A5B17(func4)  => 0x0....contract "Facet" B   │├───│S.C. ││
    │  ───────────────     ─────────────────────────   ││   └────┬┘│
    │  16D253AB(func5)  => 0x0....contract "Facet" B <··┘        │ │
    │  ───────────────     ─────────────────────────   │         │ │
    │  ...     (func6)  => 0x0....contract "Facet" C <··┐ facetC┐│ │
    │  ───────────────     ─────────────────────────   │├─│S.C. ││ │
    │  ...     (func7)  =˃ 0x0....contract "Facet" C <··┘ └────┬┘│ │
    │                      └──────────┬────────────┘   │       │ │ │
    │                      facets are contract/s that  │       │ │ │
    │                      diamond borrows functions   │       │ │ │
    │                      from.                       │       │ │ │
    │ ┌──────────────────────┐                         │       │ │ │
    │ │struct StorageFacetC {│ <···facetC (read/write)········─┤ │ │
    │ │  ...                 │                         │       │ │ │
    │ │}                     │                         │       │ │ │
    │ └──────────────────────┘                         │       │ │ │
    └──────────────────────────────────────────────────┘       │ │ │
    ┌─ S.C. Storage2 ──────────────────────────────────┐       │ │ │
    │ ┌──────────────────────┐                         │       │ │ │
    │ │struct StorageFacetB {│ <···· facetC (read)············─┘ │ │
    │ │  ...                 │                                   │ │
    │ │}                     │ <···· facetB (read/write)·······──┤ │
    │ └──────────────────────┘                         │         │ │
    └──────────────────────────────────────────────────┘         │ │
    ┌─ S.C. Storage3 ──────────────────────────────────┐         │ │
    │ ┌─────────────────────┐                          │         │ │
    │ │struct StorageFacetA{│ <···· facetB (read)··············──┘ │
    │ │  ...                │                                      │
    │ │}                    │ <···· facetA (read/write)···········─┘
    │ └─────────────────────┘                          │
    └──────────────────────────────────────────────────┘
                                           ^^^^^^^^^^^^ 
    The read-only restriction of facetA contract to storageFacetB       is not
    mandatory, but probably useful in order to let only facetX update 
    the state of DiamonStorageFacetX. 

● Diamon Tooling 
• MainNet diamon "loupe" inspector @[https://louper.dev/]
• "Diamond Setter", (Python) tool to manage diamonds.
  by Joey Zacherl@VolleyFire (liquidity provider for decentralized exchanges),
  @[https://github.com/lampshade9909/DiamondSetter]
  WARN: No new upgrades since 2020-07 (more than two years ago)
        60 package dependencies.
        37 stars @ 2021-11, last commit: 2020-06-11
  PRE-SETUP)
  - User python standard virtualenv mechanism to configure project.
  USSAGE)
  → Copy ABI JSON files to "Contracts/"
    (make sure filename matches contract name in config)
    → provide contract addresses in "diamondSetter.config" *1
      (template "diamondSetter_template.config" can be used)
      →   $ python diamondSetter.py set
        App will automatically determine what needs upgraded/removed
        by calling the proper Diamond Standard functions.
        diamondCutDict_removes = {}
        diamondCutDict_updates = {'0xd3758...': ['d22fd5fc', 'ba802cef'],
                                  '0xc630a...': ['a39fac12', 'c6ee701e', ...]}
        diamondCutDict_merged  = {'0xd3758...': ['d22fd5fc', ... ],
                                  '0xc630a...': ['a39fac12', 'c6ee701e', ...]}
                                                └──────────────┬────────────┘
                                                function selectors affected in proxy diamond

      →   $ python diamondSetter.py hash diamond.storage.tutorial.properties
          Next assembly code gets added to your solidity smart contract:

        assembly { ds_slot := 0x8009ef9e316d149758ddd03fd4cb6dd67f0acee3d8cdf1372cf6f2ac6d689dbd }
                              └───────────────────────────────┬────────────────────────────────┘
                                  == keccak256("diamond.storage.tutorial.properties")

        Use same 'ds_slot' across multiple contracts to share storage or unique one to prevent
        sharing.

  *1 Config example:

     | [ACCOUNT]
     | publicAddress = ...
     | privateKey = ...
     | gasPrice_gwei = 20
     |
     | [NODE]
     | url = http://...
     |
     | [CONTRACT_PROXY]
     | filename = tutorial_proxy
     | address = 0xfb1495fb3adca65a1c3374f206971891d3137ff9
     |
     | [CONTRACTS_LOGIC]
     | tutorial_logic_a    = 0xd37589ee0c581ef58efab0d2adb08d08b373125f
     | tutorial_properties = 0xc630aae56ac54f52ee7fb757bf6b23f86a8aacea

• Ronan Sandford (wighawag),  (ERC-1155 author), announced
  WiP support for deploying/cutting diamonds in "buidler-deploy"
  a tool to deploy contracts to any network, keeping track
  of them and replicating the same environment for testing.

• Nayms is using diamonds in production. See blog post:
  " Upgradeable smart contracts using the Diamond Standard"
  - reddit announment:
  @[https://www.reddit.com/r/ethereum/comments/hu3gq1/erc1155_multi_token_standard_updated_to_mention/]

• Issue open in OpenZepelling to use diamon standard:
@[https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2537]
• EIP-2535 Awesome Diamons: 
  https://bytemeta.vip/repo/mudgen/awesome-diamonds
  Curated list of external resources
[[}]]

● Ether.Addresses [[{10_EVM,20_QA.UX]]
  - Issues:
    REF: @[https://ethereum.stackexchange.com/questions/267/why-dont-ethereum-addresses-have-checksums]
    Initial Ethereum design didn't have support for address checksum.
    thus, a single mistyped digit could make sending to an invalid
    address (loosing all the money).

    Q: Was it an oversight that was overlooked by the designers?
    A: the raw hexadecimal string ussually called "Ethereum address"
       wasn't even intended to be the standard way of representing such information.
       containing no checksums. On top of it software can be written
       creating an encoding and string in base 58 with built-in version number
       and checksum, 100% interoperable by silently decoding the new

    NOTE: always include "0x" prefix in front of raw addresses

• ICAP Addresses (IBAN Compatible):
@[https://github.com/ethereum/wiki/wiki/Inter-exchange-Client-Address-Protocol-(ICAP)]
  - ICAP: Inter Exchange Client Address Protocol (ICAP)
  - compatible with IBAN account formatting.

  It looks like: "XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS".

  - (it uses a wider range of alphanumeric characters to save
    space and includes a checksum. similar to Bitcoin)

  - ICAP is a fully valid International Bank Account Number (or IBAN).

  - It doesn't use hexadecimal addresses. BY the help of ENS
    it can just use an actual human-readable-string to end up
    with something like "XE81ETHXREGJEFFCOLEMAN".
                         ^^^^^^^^^^^^^^^^^^^^^^
                     "XE81 ETH XREG JEFF COLEMAN"
                    (It still matches bank formats)

   Update 2016-02: Vitalik  transitional  checksumming:
    - provides some additional protection against accidental errors
    while remaining backwards compatible with wallets that doesn't support
    the checksum (and will ignore the case differences).

    - Ex: Input address '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826'

      Output checksumed:'0xCd2a3d9f938e13Cd947eC05ABC7fe734df8DD826'
                           ^             ^     ^  ^^^         ^^
                           └──────────────────────────────────────┘
              letters are in the same corresponding place as a "1" bit
              in the raw binary keccack-256 hash of the address bytes
              are capitalised. Numbers are unchanged.


  Update: EIP55 introduces checksum in Ethereum addresses. (Still optional
          but widely adopted -Metamask,...-)
[[}]]

● Ethereum Name Service: [[{standards.eip/erc,20_QA.UX]]
@[https://ens.domains/]
"""No more long addresses: ENS eliminates the need to copy - and worse,
   type - long hexadecimal addresses ...
   you'll be able to:
   - send money to 'aardvark.eth' instead of '0x4cbe58c50480...',
   - interact with your favorite contract at 'mycontract.eth'
   - visit a Swarm-hosted site at 'swarmsite.eth'. """

 Ext. Links
- https://github.com/ethereum/EIPs/issues/137 Ethereum Name Service
- https://github.com/ethereum/EIPs/issues/162 Initial ENS Registrar Specification
- https://www.npmjs.com/package/ethereum-ens,  Javascript library
  Nick’s talk on ENS at DevCon 2:
  - https://www.youtube.com/watch?v=pLDDbCZXvTE
  - https://arachnid.github.io/devcon2/#/title  (talk slides)
- https://registrar.ens.domains
- https://docs.ens.domains/en/latest/userguide.html
- Geth implementation
  https://github.com/ethereum/go-ethereum/tree/master/contracts/ens

  GOAL: resolve human-readable names to Ethereum addresses, Swarm/IPFS hashes, ....
        provide also metadata about names (contracts ABIs, whois info,...)
  - ENS operates on a system of   dot-separated hierarchial names called domains ,
    with the owner of a domain having full control over the distribution of subdomains.

  - Top-level domains (.eth, .test,...) owned by 'registrars' smart contracts
    Anyone may, by following the rules imposed by these registrar contracts,
    obtain ownership of a second-level domain for their own use.

  - Secure: ENS is built on smart contracts on the Ethereum blockchain, meaning
    it doesn't suffer from the insecurity of the DNS system.  You can be confident
    names you enter work the way their owner intended.

  - Truly Distributed: ENS operates in a distributed fashion for both its infrastructure
    and governance. Anyone can register a .eth domain name for themselves by participating
    in an auction process, mediated by the blockchain.

   TERMINOLOGY
    - domain     : complete, human-readable form of a name; eg, ‘vitalik.wallet.eth’
    - label      : a single component of a domain; eg, ‘vitalik’, ‘wallet’, or ‘eth’
    - label hash : keccak-256(label) eg, keccak256(‘eth’) =
                   0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0
    - node       : namehash function output used to uniquely identify a name in ENS

- Ex. JS Client code to register:
  REF: https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial

| var name = "MyPersonalDemocracy"
| registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
| var democracy = eth.contract(daoCompiled.Democracy.info.abiDefinition).
|                 at(democracy.address);
| democracy.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})
|
| (Wait for the previous transactions to be picked up and then)
|
| registrar.setAddress.sendTransaction(name, democracy.address, true,{from: eth.accounts[0]});

 • ENS Architecture:
  DOMAIN            | REGISTRY CONTRACT                | RESOLVER(S) INTERFACE
  ------            | -----------------                | ---------------------
  - owner (address) | - owned (sub)domains list        | translate name → address
  - resolver        | ----------------                 +-------------------------
  - time-to-live    | + issues subdomains to users  *1
    for all records |   following logic in contract *1 | RECORD:
                    | + Set resolver+TTL for domain *1 | -------
                    | + Transfer ownership             | - type: (Ethereum address, Swarm content hash, ...)
                    | *1 Only owner of affected domain |          New record types may be defined via EIP
                                                       |          with no need to make changes to the registry
                                                       |          or resolvers
                                                       | - Namehash: 32-byte hash of name (compaq storage+privacy)
                                                       |             defined recursively to preserve the
                                                       |             hierarchal nature
                                                       | ----------
                                                       | - Iface method/s to be implemented by resolver
                                                       |    in order to provide records of that kind.
 • MainNet/... Deployments
  General-purpose resolver implementations are offered for users whose requirements are straightforward,
  such as serving an infrequently changed address for a name.

    MAINNET DEPLOYMENT: 0x314159265dd8dbb310642f98f50c066173c1259b
                        users may register names under the eth TLD using an auction based registrar.
    ROPSTEN
    TESTNET DEPLOYMENT: 0x112234455c3a32fd11230c42e7bccd4a84e02010
                        users may register names under two top level domains:
                        .eth , auction based
                        .test, allows anyone to claim an unused name for test purposes expiring after 28 days
    RINKEBY
    TESTNET DEPLOYMENT: 0xe7410170f87102df0055eb195163a03b7f2bff4a
                        .test supported
[[}]]

###############################################################
  SOLIDITY
###############################################################
● External Links:
  @[https://remix.ethereum.org/#]   Online IDE
  @[https://solidity.readthedocs.io/en/latest/solidity-in-depth.html]
  @[https://solidity.readthedocs.io/en/develop/]
  @[https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt] EBNF Grammar Summary
  @[https://ethfiddle.com/]
  @[https://github.com/ConsenSys/smart-contract-best-practices']

● Solidty: What's New [[{12_solidity]]
  Solidity 0.8 Breaking changes
@[https://github.com/ethereum/solidity/blob/develop/docs/080-breaking-changes.rst]

  - Silent Changes of the Semantics
    - Arithmetic operations revert on underflow and overflow.
      You can use  unchecked { ... }  to go back to previous wrapping behaviour.
      (better readability of code with slight increase of gas costs)
      No need anymore to import "SafeMath".

    - ABI coder v2 is activated by default. :
      (pragma experimental ABIEncoderV2" not-needed/redundant)
      - supports for more types and better sanity checks on inputs.
      -  some fun. calls are more expensive

    - internal checks (failing assertions,div-by-zero, overflow,...) translate to revert (vs invalid) opcode.
        saving gas on errors  while  allowing static analysis tools to distinguish
      them from  invalid-input-reverts (failing "require").

    - If a byte array in storage is accessed whose length is encoded incorrectly, a panic is caused.
      A contract cannot get into this situation unless inline assembly is used to modify the raw representation of storage byte arrays.

    - constants 'variables' values used in array length expressions as intermediate expressions properly rounded.
      (previously, arbitrary precision used in all branches of the evaluation tree).

    - "byte" removed in favor of "bytes1".

  - New Restrictions
    - removed ambiguous syntax "here and there".
    - Address literals have the type "address" (vs "address payable"). Use explicit conversion. Ex:
      payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF).

    - explicit type conversions only allowed fo  at most one change in sign, width or type-category.
      multiple changes will require multiple conversions . Ex: uint16(int8) →  uint16(uint8(int8))
                                                                               ^lenght^sign

    - call options can only be given once: c.f{gas: 10000}{value: 1}() →  c.f{gas: 10000, value: 1}()

    -  enum  max length 256 members. (allows to assume uint8)

    - global vars 'tx.origin' and 'msg.sender' have type "address"` (vs payable address)
      Ex: msg.sender.transfer(x) → payable(msg.sender).transfer(x)

  - See source to check How update old code

  0.7.0
  https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst
  - Silent Changes of the Semantics
    - Exponentiation and shifts of literals by non-literals (e.g. 1 << x or 2 ** x)
      will always use either the type uint256 or int256

    - Ether and gas is now specified using a new syntax:
      x.f{gas: 10000, value: 2 ether}(arg1, arg2) vs x.f.gas(10000).value(2 ether)(arg1, arg2)

    -  global variable  now  is deprecated
       block.timestamp should be used instead .

    - NatSpec comments on variables only allowed for public state variables

    - Unicode string literals supported now.  unicode"Hello 😃"

    - state mutability of functions can now be restricted during inheritance                        [qa]
      with "pure" and "view".

    - structs and arrays containing mapping can only be used in storage.
      (Previously, mapping members   silently skipped in memory )

    - Assignments to structs or arrays in storage does not work if they contain mappings.
      (Previously, mapping members   silently skipped during the copy operation )

    - Visibility (public/external) not needed in constructors anymore.
       To prevent a contract from being created, mark it as  abstract .

    - using A for B must be repeated in all derived contracts of B.
  Solidity 0.6 Breaking changes
  https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst

  - Breaking changes:
    - Explicitness Requirements:
      - only functions marked as virtual can be overridden.
      - "override" must be used in implementing children.

    - Member-access to ".length" in arrays is always read-only (including storage ones).
      No possible to resize storage arrays by assigning a new value to their length.
      Use "push()/pop()" or "push(value)" instead.
      push(value) for dynamic storage arrays returns nothing (new length previously)
      This prevents storage collisions of gigantic storage arrays.

    - "abstract" keyword can be used to mark contracts as abstract.
      - This avoids creating such contracts with "new" operator.
      - not possible to generate bytecode for them during compilation.

    - Libraries have to implement all their functions, not only the internal ones.

    - unnamed "fallback function" split up into:
      - fallback function marked with "fallback" keyword.
        - called when no other function matches
        - can be payable or not.
      - receive  function marked with "receive " keyword. implicitly "payable".
        - called whenever the call data is empty (with/without ether received).

  - New Features
    - try/catch statement allows to react on failed external calls.               [qa][error-handling]
    - "struct" and "enum" types can be declared at file level.
    - Array slices can be used for calldata arrays.
      e.g.: low-level way to decode function call payload
            abi.decode(msg.data [4:] , (uint, uint))" [TODO]
    - Natspec supports multiple return parameters in developer documentation.
    - "address" → "address payable" conversion thanks to: payable(myaddress)
    - compiler now appends the `IPFS <https://ipfs.io/>`_ hash of the metadata file to the
      end of the bytecode by default (previously swarm hash by default)

@[https://blog.ethereum.org/2020/01/29/solidity-0.6-try-catch/]
[[}]]

● solc (Solidity Compiler) [[{101,12_solidity.solc,20_QA.formal_verification,20_QA.auditing,13_SLC.debugging,00_PM.WiP]]
  • svm: Solidity compiler Version Manager, similar to Node nvm,..
  @[https://github.com/web3j/svm]
  $ svm install 0.6.2   ← install|uninstall|deactivate
  $ svm use     0.6.2     use|current
                          ls|ls-remote
                          alias|unalias
  • COMPILING:
  @[https://docs.soliditylang.org/en/latest/using-the-compiler.html]
  $ solc  \
    --base-path ...              ← default: ./
    --include-path ...           ← default: ./
    github.com/.../lib1/=./lib1/ ← (Opt) (src)input path redirect
    -o outputDirectory \
    --bin --ast-compact-json \

    --optimize                 ← Don't forget before deploying
                                 opcode is executed ~200 times.
                            --optimize-runs=$N
                             ┌───────────────┘
                             N=1:    deploy -expensive/exec. +expensive
                             N=1000: deploy +expensive/exec. -expensive
                             Affected tunning:
                             • size of binary search in 'dispatch'
                             • storage of constants (strings,..)
    --asm sourceFile.sol

  • LINKIN
    • Replace bytecode placeholders (__$...34 chars...$__) with
      with actual library addresses, where the 34 chars is the
      keccak256("fully-qualified-library-name")
      (bytecode will end with some extra metadata:
       // placeholder -> fq-library-name as a hint )

    $ export LIB_MATH="0x...hex-address-of-deployed-lib..."
    $ export LIB_HEAP="0x...hex-address-of-deployed-lib..."
    $ solc --libraries \
      "file.sol:Math=${LIB_MATH} file.sol:Heap=${LIB_HEAP}"
      ...
  - Using JSON as (STDIN) input:  RECOMENDED FOR AUTOMATED BUILDS
    $ solc --standard-json ... ← return JSON-output on  STDOUT.
                                 Always success. Errors are
                                 reported through JSON-output
    (go to offical doc for more details)

  • EVM Version --evm-version  (settings.evmVersion JSON) affects
    compiler output in different ways:

    ────────────────────────────────────────────────────────────
    homestead  · (oldest version)
    ────────────────────────────────────────────────────────────
    tangerine  · Gas cost for access to other accounts
      Whistle    increased, relevant for gas estimation and the
                 optimizer.
               · All gas sent by default for external calls,
                 previously a certain amount had to be retained.
    ────────────────────────────────────────────────────────────
    spurious   · Gas cost for the exp opcode increased,
      Dragon     relevant for gas estimation and the optimizer.
    ────────────────────────────────────────────────────────────
    byzantium  · Opcodes returndatacopy, returndatasize and
                 staticcall are available in assembly.
               · The staticcall opcode is used when calling
                 non-library view or pure functions, which
                 prevents the functions from modifying state at
                 the EVM level, i.e., even applies when you use
                 invalid type conversions.
               · It is possible to access dynamic data returned
                 from function calls.
    ────────────────────────────────────────────────────────────
    constan-   · Opcodes create2`, extcodehash, shl, shr and
     tinople     sar are available in assembly.
               · Shifting operators use shifting opcodes and
                 thus need less gas.
    ────────────────────────────────────────────────────────────
    petersburg · compiler behaves the same way as with constantinople.
    ────────────────────────────────────────────────────────────
    istanbul   · Opcodes chainid and selfbalance are available in assembly.
    ────────────────────────────────────────────────────────────
    berlin     · Gas costs for SLOAD, *CALL, BALANCE, EXT* and
                 SELFDESTRUCT increased. The compiler assumes cold
                 gas costs for such operations. This is relevant
                 for gas estimation and the optimizer.
    ────────────────────────────────────────────────────────────
    london     · (default as of 2022-01)
               · The block’s base fee (EIP-3198 and EIP-1559)
                 can be accessed via the global block.basefee or
                 basefee() in inline assembly.
    ────────────────────────────────────────────────────────────

  - JSON-INPUT:
    {
      "language": "Solidity",  ← "Solidity" | "Yul".
      "sources": {
        "myFile.sol": {
          "keccak256": "0x123...",  ← Optional: used to verify retrieved content
          "urls": [...]             ← Ordered list of bzzr://, ipfs://, FileSystem paths
        },                            (only FS allowed to commandline interface)
        "destructible": {
          "keccak256": "0x234...",  ← Optional
          "content": "... "         ← Inline contract source code
        }
      },
      {                      ←  Optional "settings":
        "stopAfter": "parsing",
        "remappings": [ ":g=/dir" ],
        "optimizer": {...}   ← active?, runs over opcodes,
          "details": {...},  ← peephole,inliner,jumpdestRemover,orderLiterals,
                               deduplicate,cse,constantOptimizer,yul/yulDetails
        "evmVersion": "byzantium",
        "viaIR": true,  ← highly EXPERIMENTAL. compile through Yul
        "debug": {
          "revertStrings": "default",   ←  "strip"  : removes all keeping side-effects
                                           "debug"  : injects compiler-generated reverts.
                                                      (ABI encoders V1 and V2)
                                           "verboseDebug":  appends further information
          "debugInfo": ["location", "snippet"] // extra debug info to include in ASM/YUL
        },
        "metadata": {
          "useLiteralContent": true,
          "bytecodeHash": "ipfs"
        },
        "libraries": {  ← needed for linkin libraries.
          "myFile.sol": { "MyLib": "0x123123..." }
        },                   Enable abi output for all contracts. Compiler output
        "outputSelection": { types include:
          "*": {             abi, ast, devdoc, userdoc, metadata, ir/irOptimized(Yul),
            "*": [ "abi" ] ← storageLayout(Slots/offsets/types of contract's vars),
          }                   evm.assembly, evm.bytecode.*, evm.methodIdentifiers
        }                      ,10_EVM.gasEstimates, ewasm.wast, ewasm.wasm
      "modelChecker":{...} ← experimental/subject to changes (Formal Probes)
      }
    }

  - JSON-OUTPUT
    {
      "errors": [ { ... } ],
      "sources":   {...} // file-level outputs.
      "contracts": {...} // detailed contract-level output
    }
  -------------------------------------------------------------------
  <span xsmall>Troubleshooting</span>
  • CONTEXT:
    Next code compiles "OK" for A and B:
    SOLC INPUT              →   SOLC OUTPUT
    ==========                  ==============
    pragma solidity ^0.4.8;     A.bin  6060604...
    contract A {                B.bin  6060604...
      uint public a1;
    }

    contract B  is A  {
      uint8 public b1;
    }

    • Problem:  Now we add constructor to parent A contract. An B output is empty.

    • SOLUTION:
      B does NOT implements all mehtods of declared interfaces or base clases.
      solc compiler consider the class abstract and does not generate any
      bin. B will need to provide parent A constructor with a parameter:
      contract B is A {
        uint8 public b1;
        constructor(address _a) A(_a) { ... }
      }

  <span title TODO>Src.upgrade</span>
  @[https://docs.soliditylang.org/en/latest/using-the-compiler.html#solidity-upgrade]
   • solidity-upgrade semi-automatically upgrade contract source code
  <hr/>

  <span title TODO>Source Code Verification</span>
  • PRE-SETUP)
    Anotate the solc compiler version used as well as compiler flags
    @[#solc_summary]
  • STEP 1) Go to some online service like:
  @[https://etherscan.io/verifyContract]

  • Source code verification works by compiling the code you claim is
    the source code and comparing the resulting bytecode (bitwise) to
    what is deployed. If it matches, SUCCESS.

  • BEST PATTERNS:
  @[https://ethereum.stackexchange.com/questions/74785/publish-and-verify-the-source-contract-code-in-ethscan-i-tried-it-but-it-keeps/74796]
  • """ ...contract has ^ in pragma, so no one can be sure what
     compiler was used.  Its presence is a sign that the code hasn't
     received an appropriate critical review.
     ...  If you can inspect the machine that compiled it, and the
     compiler (solc, truffle, remix) you might be able to piece together
     what version was used. ..."

  <span xsmall TODO>Decompiling mainnet Contracts</span>
  @[https://www.contract-library.com/]
  - Decompiles most smart contracts deployed on the mainnet to a high
    level representation. Show also source code when available
  @[https://contract-library.com/contracts/Ethereum/42A1CA0A79A9E7D83AEE9012D21920B02F9FC2C6]
[[}]]

● Solidity 101: [[{101,12_solidity.101,persistence.data_structure,20_QA,00_PM.WiP]]
(Initial version from @[https://learnxinyminutes.com/docs/solidity/]
 with "lot of extras")
● EVENT-STREAM ORIENTED:
  - Clients "outside" the ethereum network send
     signed TXs  to the network. Eventually  those TXs will be
    accepted ("mined") by the consensus and the modified state
    eventually propagated back with the propagation on new
    accepted ("mined") blocks.
    Each TXs can also create new inmutable logs that are also
    propagated back with the new mined block propagation.
    (See "events" topic for related info)

  First Important different when compared with standard languages:
  - A function invoqued "outside" the network (from a new
    signed TX pending to be mined) can return values, but
    those values will be ignored (except, maybe by the
    debugger during the development phase). Events are used
    to inform the client about application-layer data.
    (Some low level-EVM data can be directly extracted from the
    TX receipt, like the gas spent, hash, ...).

● NATSPEC COMMENTS
  /// @title Contract title
  /// @author Author name
  contract ... {

    /// @notice information about what function does;
    /// @dev Function documentation for developer
    /// @param someParam Some description of what the param does
    /// @return Description of the return value
    function ... { ...}
    }

● import "filename";                          IMPORTS
  import * as symbolName from "filename";     NodeJS tooling (truffle,...) will also
  import {symbol1 as alias, symbol2}          import from "node_modules/"
         from ""filename"";
  import ""filename"" as symbolName;


● FALLBACK FUNCTION: (called when no other function matches)
  event EventFallback(address from, int256 amount);
  ...
  function () payable {
    if (! this.owner.send(amount)) { throw ; }
    EventFallback(msg.sender, receiver, amount);
  };

  event EventFallback(address from, int256 amount);
  ...
  function () payable {
    if (! this.owner.send(amount)) { throw ; }
    EventFallback(msg.sender, receiver, amount);
  };

● DATA TYPES / STORAGE:
  NOTE: In Solidity/Ethereum, contract data structures like maps/arrays can and
        ussually are automatically  persisted to permanent storage (on each
        potential node in the 1000's of nodes network!!!). Temporal storage
        in memory/calldata must be indicated explicetely.
  • no doubles or floats (Risky in the Accountancy World)
  • Minimal support for strings, it use is discouraged.
  uint public constant z        All non-explicitely assigned values return zero.
                                WARN : 'private' members are still visible/readable
                                       to anyone except the Solidity-compiler.
  uint public constant a = 8; ← 32 bytes (256bits), alt. uint256
                                or (u)int(8,16,24,...,248,256)
                                internal visibility by default.
                                'public' automatically creates getter (NOT setter)
  uint immutable x;           ← immutable: Init@constructor, constant from there on.
  uint256 c = a + b;
  assert(c >= a);             ← overflow check ("SafeMath") integrated in Solc 0.8+
  bool b = true;              ← boolean, alt(type inferred): var b = true;
  address payable owner;      ← 20 byte Ethereum addresses (arithmetic not allowed)
                                Mark as 'payable' to allow sending ethers.
  this;                       ← address of current contract
                                WARN: this.func1() call func. externally.
                                           func1() call func. internally (faster)
  owner.transfer("balance");  ← reverts on failure
  if (owner.send) {}          ← low-level send allows to capture failure..
                                Make sure to update/decrease internal contract balances
                                BEFORE attempting a send, to avoid recursive drains.
  owner.balance;              ← check balance for owner
  byte1 a;                    ← byte2, byte3, ... bytes32

  bytes m;                    ←  same as byte[] array (but packed tightly in calldata)
                                 More expensive than byte1-byte32, so use those when possible

  string n = "hello";         ← stored in UTF8, internally same as bytes, BUT does
                                NOT allow length/index/push access (202?)
                                string utility functions  could be added
                                prefer bytes32 hash of string when possible
                                · use bytes(myString).length / bytes(myString)[7] = 'x' to
                                  access the low-byte-representation of myString
                                WARN:  string[] arrays not allowed.

  var f = someFunction;       ← assign function to variable.
      f(22);                    ← call func.

  (x, y) = (2, 7);            ← Destructuring/Tuples: assign/swap multiple values

  enum State {                ← ENUMS
     Created,
     Locked,
     Inactive
  };
  State public s0 = State.Created;
  state = State.Created;
  uint8  i_8_0 = uint8(State.Created);  ← enums can be explicitly converted to ints
  uint16 i16_0 = uint16(State.Created); ← enums can be explicitly converted to ints
  State s2 = State(i_8_0)               ← uintXX → enum using enum constructor
                                          Will raise an assert exception if
                                          u1 is outside the State bounds.

● DATA LOCATIONS:
  • Memory  : intermediate operations.
  • calldata: input data.
  • storage : internal state.

● Basic operators: Comparisons, bit operators and arithmetic.
  WARN: ^  XOR (use '**' for exponentiation)

● Predefined constants (at Tx runtime)
  msg.sender; ← address of sender (or contract calling our contract)
  msg.value;  ← weis provided to this contract. function should be "payable"
  msg.data;   ← bytes, complete call data, used for example for multi-signatures
                in a single (expensive) transaction.
  msg.gas;    ← remaining gas

  tx.origin;  ← signer of TX sent to blockchain
  tx.gasprice;← gas price of the transaction


  block.timestamp ← aprox UNIX-current time  (alias: 'now')
                    WARN: Can be manipulated by miners
  block.number;
  block.difficulty;
  block.blockhash(1); ← bytes32, only works for most recent 256 blocks
  block.gasLimit();

● "Common" pattern: remove function removing storage/code from
  current/future blocks (helps thin clients). (Alternatively, de-activate)
  function remove() {
    if(msg.sender == creator) { ← creator registered in constructor
      selfdestruct(creator);
    }
  }


● Setting max-gas allowed for calls to
  external non-trusted Contracts:
  NonTrustedContract.someMethod (...);  ← WARN!: External contract can
                                                 potentially waste all gas.
  NonTrustedContract                    ← Protect.
   .someMethod { gas:gasleft() } (...);   TODO:(0) Detail protection.

<hr/>
<span title>Currency Units</span>
● Currency units: (Useful in public network, not that much in consortium ones)
     wei : basic unit in solidity code, APIs, ...
    gwei =  1^9  weis ,  gas prices . Ex. web3j default gas price is 22 gwei
                        alias: shannon|nanoether|nano
   szabo =  1^3  gweis, alias: |microether|micro
  finney = 10^6  gweis, micropayments, alias: |milliether|milli
   ether =  1^9  gweis, main unit
  kether =  1^3  ethers, alias: (grand|einstein)
  mether =  1^6  ethers
  gether =  1^9  ethers
  tether =  1^12 ethers

● Time units:
  second : unit-of-time
  minutes
  days

<hr/>
<span title>Data Structures 101</span>

● STRUCTS
  struct Bank {               ← DECLARE STRUCT
      address owner;            ← all vars are "zero-value" by default.
      uint balance;               except mappings
  }
  Bank b = Bank({ owner: msg.sender, balance: 5 });
  b.balance = 5;
  delete b;

● ARRAYS
  bytes32[5] fixedArray1;     ← STATIC/FIXED-SIZE ARRAY DECLARATION
             fixedArray[0] = 1; ← Intialization.
             fixedArray[1] = 2;
             fixedArray.push(3);←   Error. Not allowed for fixed size array

  bytes32[] memory            ← dynamic array declaration/initialization
  dnyArray1 = bytes32[](3);   ← Dynamics arrays in memory are NOT really
                                dynamics. An given size must be defined at
                                initialization to avoid memory overflows.
                                The only difference with fixed size array is
                                that they can be used as parameters in functions
                                receiving an array of undefined size.
  dynArray1[0] = ...;                 ← By default. values is "Zero".
  dynArray1[1] = ...;
  dynArray1.length
  uint[] storage              ← Dynamic Size Array declaration
   dynArray2 = uint[]
  dynArray1.length = 1        ← Fails for in-memory  dyn arrays
  dynArray2.length = 5        ← OK    for in-storage dyn array
  dynArray1.push(1)           ← Fails? (TODO)
  dynArray2.push(1)           ← OK, returns new array length
  uint newLength = dynArray1.push(...);
  uint x[][5];                ← 2-dimensional Dyn.array of uint[5]
  ...
  var storage x = uint[][5]   ← Fixed-(5)size-array of
                                dynamic-uint-arrays  (var for type inference)
  x[2][1]                     ← second uint in third dyn-array

  funcX( [uint(1), 2, 3] );   ← Array Literal expression (not assigned to vars.)
         └─────────────┘        - type     : memory array of fixed length.
                                - base type: common type of array elements.

  Array Limitations:
  · arrays of arrays not (YET 202?) allowed in external functions
  · (EVM limitation): dynamic content NOT allowed in external-function return-value
    Workaround: use large statically-sized arrays
  · Deleting an element in the array (delete myArray[idx1]) generates gaps over time
    leading to unpredictable gas costs if a contract itself has to search
    through those gaps. Can be fixed (See @[#solidity_storage_patterns]

  for ( uint idx=0;           ←  WALK OVER ARRAYS
     i<arr.length; idx++) {
     require(array3[i] ...);
  }

  ┌────────┬─────────────────────┬───────────────┬──────────────────────┬──────────────────┐
  │        │ Admited type        │ Creation      │ Resize               │ Delete           │
  ├────────┼─────────────────────┼───────────────┼──────────────────────┼──────────────────┤
  │Storage │  any                │ (just declare │- set/reassign .length│ delete myArray;  │
  │Arrays  │                     │  it)          │- push(el)            │ myArray.length=0;│
  ├────────┼─────────────────────┼───────────────┼──────────────────────┼──────────────────┤
  │Memory  │  any  but mapping   │ Use 'new'     │ Not allowed          │                  │
  │Arrays  │ (ABI comp. for      │ new uint[](7) │(fix size determined  │                  │
  │        │  public/extern fun) │ new bytes(len)│ at runtime)          │                  │
  └────────┴─────────────────────┴───────────────┴──────────────────────┴──────────────────┘

• MAPS (DICTIONARIES / HASH-TABLEs)
  key-type: almost any type except mapping, dynamic array, contract,enum,struct
  mapping public
     (string => uint) map1;   ← Keys can not be iterated. Manual support needed
                                More info: @[#solidity_storage_patterns]
                                • Care must put to not leave orphaned data
                                 in the state database, specially in self-destruction
                                 Code must manually clean mappings by DELETING EACH KEY.
  map1["charles"] = 1;        ← add/modify key.
  delete balances["charles"]; ←
  contract.map1("charles")    ← 'public' allows 3rd contracts read (not write) it.
  map1["non_existing_key"]    ← Returns 0. All non-set values are set to zero

  mapping (                   ← Nested mappings
     address => mapping (
        address => uint))
     public custodians;

•  MAP WALK-OVE
  - PROBLEM: Mappings are virtually initialized:
    - every possible key exists mapped to zero-byte-rep
    - keys are NOT stored in the map.
    - values are stored at the state-memory address == sha3(key)

  - Solution: @[#solidity_storage_patterns]

[[}]]

● Retrieving events quickly: [[{12_solidity,10_EVM.events,scalability.solidity,dev_framework.js]]
- Imagine the COMMON PROBLEM:
  - A given contract emits a given event sparsely, with
    an average of 1 event each 10.000 blocks.
  - We want to retrieve all events.
  - By default the client needs to query from block-zero
    to latest block. This can means query-times of more than
    a minute even in dedicated hardware.
  SOLUTION :
  - Save as contract state the block when an event has been
    emitted.
    The on the event add the information for the previous
    block where such event was emitted.
  - On client code run backward from last-to-first even
    using the state to retrieve the latest block, and then
    the event information to "jump" to the previous block.

 SOLIDITY:
contract MyContract {
   uint   previousBlock = 0;

   event MyEvent01(address indexed A,..., uint   previousBlock );
   //                                            └──────┬─────┘
   //               pointer to last event block helpsi ←┘
   //               external clients(etherjs,web3j,...)
   //               search quickly.

   function ....(...) ... {
     emit REC(msg.sender,... ,   previousBlock );
     lastBlockDREC = block.number;
   }
}

 CLIENT-SIDE :
(javascript pseudo-code example)
   /*
    *   Run events backward, from last to first
    */
   async function getFilters(LAST_BLOCK) {
     var LAST_BLOCK = await CONTRACT.  previousBlock ()
     while ( LAST_BLOCK > 0 ) {
       value = await CONTRACT.getFilter(/*1st block=*/LAST_BLOCK, LAST_BLOCK)
       console.log(value.toString());
        LAST_BLOCK = value.previousBlock
     }
   }
   getFilters(LAST_BLOCK)

[[}]]


● SOLIDITY GLOBALS: [[{12_solidity.101]]
 GLOBAL METHODS:
block.blockhash(uint blockNumber)
  returns (bytes32):
  hash of the given block - only works for 256 most
  recent blocks excluding current

 GLOBAL VARS:
  msg.sender (address)    : sender of the message (current call)
  tx.origin (address)     : sender of the transaction
                            (full call chain)
msg.sender vs tx.origin:
@[https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin]
"""
- With msg.sender the owner can be a contract.
- With tx.origin the owner can never be a contract.
  In a simple call chain A→B→C→D,  inside D msg.sender will be C, and tx.origin will be A.

- msg.sender is preferred for the flexibility it provides.
  Furthermore, for Serenity, even though it's a while out, Vitalik
  recommends avoiding tx.origin: How do I make my DAPP "Serenity-Proof?"
- Carefully consider if you really ever need to use tx.origin.
  Remember, you may not be the only user of your contract.
  Other people may want to use your contract and want to interact
   with it via a contract they've been written.

"""


block.coinbase (address): current block miner’s address
block.difficulty (uint) : current block difficulty
block.gaslimit (uint)   : current block gaslimit
block.number (uint)     : current block number
block.timestamp (uint)  : current block timestamp

https://ethereum.stackexchange.com/questions/7853/is-the-block-timestamp-value-in-solidity-seconds-or-milliseconds
msg.data (bytes)        : complete calldata
msg.gas (uint)          : remaining gas
msg.sig (bytes4)        : first four bytes of the calldata
                          (i.e. function identifier)
msg.value (uint)        : number of wei sent with the message
now (uint)              : current block timestamp
                          (alias for block.timestamp)
tx.gasprice (uint)      : gas price of the transaction



 GLOBAL Math.&amp;Crypto Functs
addmod(uint x, uint y, uint k)
  returns (uint): /* compute (x + y) % k */
mulmod(uint x, uint y, uint k)
  returns (uint): /* compute (x * y) % k */
keccak256(...)
  returns (bytes32): compute Ethereum-SHA-3 hash
                of the (tightly packed) arguments
  - See also <a href="https://ethereum.stackexchange.com/questions/10173/different-hash-values-for-keccak256-functions">keccak256 in web3js</a>
sha3(...)
  returns (bytes32): alias to keccak256()
sha256(...)
  returns (bytes32): compute SHA-256 hash of the
                      (tightly packed) arguments
ripemd160(...)
  returns (bytes20): compute RIPEMD-160 hash of
  the (tightly packed) arguments
ecrecover
  (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address):
    recover the address associated with the public key
    from elliptic curve signature or return zero on error
[[}]]


● Solidity String Manipulation: [[{101,12_solidity.strings]]
- Can be used as keys for mappings
- Concatenating strings str01, str02, str03, ...:
  string memory result = string(abi.encodePacked(str01, str02, str03, ...);
- uint256 ("Big Number") to string:
  function uint2str(uint256 _i) public pure returns (string memory _uintAsString) {
     if (_i == 0) { return "0"; }
     uint256 strLen;
     uint256 j;
     for (j = _i; j != 0; j /= 10 ) { strLen++; }
     bytes memory bstr = new bytes(strLen);
     uint256 strPosition = strLen;
     for (j = _i; j != 0; j /= 10 ) {
       strPosition -= 1;
       bstr[strPosition] = bytes1 ( uint8 ( 48 + ( j % 10 ) ) );
     }
     return string(bstr);
   }

 Comparing strings:
   sha3(      "string1" ) == sha3("string2")  ← sha3("...") translates to sha3(bytes("..."))
   ^^^^
   remember: sha3 is an alias for keccak256
   WARN :  Ethereum SHA3 != SHA3-NIST standard
   SHA3 Solidity  5f16f4c7f149ac4f9510d9cf8cf384038ad348b3bcdc01915f95de12df9d1b02
   Keccak-256     5f16f4c7f149ac4f9510d9cf8cf384038ad348b3bcdc01915f95de12df9d1b02
   SHA3-256-NIST  7f5979fb78f082e8b1c676635db8795c4ac6faba03525fb708cb5fd68fd40c5e

 check if string is empty:
<a TODO href="XXX">Check white-space paddings</a>
bool stringNotEmpty = bytes(myTestedString).length &gt; 0; // alt 1, check underlying bytes array length
                                            ^^^^^^^
                                length implemented for
                                bytes, not (yet) for string

bool stringNotEmpty = sha3 (myTestedString) != sha3("")    // alt 2, check sha3

 uint256 ←→ Strings:
    // https://ethereum.stackexchange.com/questions/6591/conversion-of-uint-to-string
    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
      if (_i == 0) {    return "0"; }
        uint j = _i;
        uint len;
        while (j != 0) { // calculate decimals
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
            bstr[k--] = byte(uint8(48 + _i % 10));
            _i /= 10;
        }
        return string(bstr);
    }
 bytes32 ←→ Strings:

As of feb 2021 you can do
bytes32 foo = "hello";
string memory bar = string(abi.encodePacked(foo));


 • STRING LIBRARIES:
  WARN: String manipulation inside contracts is discouraged. It wastes lot of   [[{20_QA.101}]]
         gas and is error-prone. Use them as last-resort.

  - @[https://github.com/Arachnid/solidity-stringutils]
     toSlice     (string self)                           internal returns (slice)
     copy        (slice self)                            internal returns (slice)
     toString    (slice self)                            internal returns (string)
     len         (slice self)                            internal returns (uint)
     empty       (slice self)                            internal returns (bool)
     compare     (slice self, slice other)               internal returns (int)
     equals      (slice self, slice other)               internal returns (bool)
     nextRune    (slice self, slice rune)                internal returns (slice)
     nextRune    (slice self)                            internal returns (slice ret)
     ord         (slice self)                            internal returns (uint ret)
     keccak      (slice self)                            internal returns (bytes32 ret)
     startsWith  (slice self, slice needle)              internal returns (bool)
     beyond      (slice self, slice needle)              internal returns (slice)
     endsWith    (slice self, slice needle)              internal returns (bool)
     until       (slice self, slice needle)              internal returns (slice)
     find        (slice self, slice needle)              internal returns (slice)
     rfind       (slice self, slice needle)              internal returns (slice)
     split       (slice self, slice needle, slice token) internal returns (slice)
     split       (slice self, slice needle)              internal returns (slice token)
     rsplit      (slice self, slice needle, slice token) internal returns (slice)
     rsplit      (slice self, slice needle)              internal returns (slice token)
     count       (slice self, slice needle)              internal returns (uint count)
     contains    (slice self, slice needle)              internal returns (bool)
     concat      (slice self, slice other)               internal returns (string)
     join        (slice self, slice[] parts)             internal returns (string)

  - @[https://github.com/blockapps/blockapps-sol/blob/master/util/contracts/Util.sol]
    stringToBytes32(string memory input) pure returns (bytes32)
    bytes32ToString(bytes32       input) pure returns (string )
    b32            (string memory input) pure returns (bytes32)
    i2b32          (uint          input) pure returns (bytes32)
    a2b32          (uint[]        input) pure returns (bytes32[])
    uintToString   (uint          input) pure returns (string str)
[[}]]

● Solidity: Date/Time [[{12_solidity.101.date_time]]
  - DateTime is stored as uint
  - now (uint) == block.timestamp
  - Next keyword constants are defined:
    minutes, hours, days, weeks

    constructor(...) {
      this.time_origin = now;
    }
    uint timeOutWindow  =  3 days; // (vs 3*days)

    function myTimeOutDependentFunction(...) returns (...) {
        if (  now  > (  time_origin + timeOutWindow )) throw;
        ... Do something ...
    }
[[}]]

● SOLIDITY FUNCTION MODIFIERS: [[{101,12_solidity.101.functions,10_EVM.gas]] #[solidity_functions_summary]
- Syntax sugar for function precondition checks:
@[https://en.wikipedia.org/wiki/Precondition]
- Commonly used to check basic "value security rules"
  (correct ownership, enough funds, ...)
- Not recomended, but still in wide use.
  Syntax:
   modifier inState (State _state)    { if (state != _state) throw;  _;  }
   modifier require (bool _condition) { if (!_condition) throw; _;       }

function confirmPurchase(<parameter_list types>)
      inState (State.Created)          // precondition
      require (msg.value == 2 * value) // precondition
                   VISIBILITY MODIFIERS (v0.5+)
                   ====================
      [internal] ← only this contract and child ones
      [private]  ← only this contract
      [external] ← will only ever be called externally            [evm.gas]
                   external is more efficient than public
                   since it also avoid copying parameters twice
                   (very important with big arrays!!!)
      [public]   ← will also be called internally.

                   MUTABILITY MODIFIERS
                   ====================
      [payable]  ← allows fun. to receive ether when called as:
                    myContractInstance.myPayableFunction.call.
                      value("ETH_TO_BE_SENT")("ADDITIONAL_DATA")
                    Ej: function deposit() payable {
                          deposits[msg.sender] += msg.value;
                        };
      [pure]     ← does NOT modify the contract storage
                   and storage can NOT be accesed
                   (utility libraries, ...)
      [view]     ← does NOT modify the contract storage
                   but storage can be accesed  ("getters")
      [constant]   (alias for pure)
    [returns ('return types')]
    {
      // (function body)
      ...
    }

Note:
     confirmPurchase(...) # Internal call
this.confirmPurchase(...) # External call
[[}]]

● ERROR CONTROL [[{12_solidity.error_control,transaction,10_EVM.101,01_doc_has.diagram,13_SLC.debugging,10_EVM.implementation.besu,10_EVM.events,13_SLC.testing,transaction,dev_framework.web3j,20_QA.error_control]]
@[https://solidity.readthedocs.io/en/v0.4.24/control-structures.html#error-handling-assert-require-revert-and-exceptions]

  Error Management:
  - Solidity uses state-reverting ("rollback") exceptions to handle errors:
    Capturing ("try-catching") Exceptions IS NOT POSSIBLE:
      EVM rollbacks any stat change in current call and all its sub/super-calls
      including any events emitted up until the rollback.
      (there is no safe way to continue execution while warrantying atomicity
       and reproducibility of results)
  - TX is still mined and TXReceipt status flaged with "fail" error, but
    the execution of the mined will not modify any state. TX will just consume
    gas and record information about the error.
    See Example failed TX mined:
  @[https://etherscan.io/tx/0x9f00a37416a64735b02ab76da4477ea297bfd4923b1564c1b3579d542b3f4071]


  └ assert( "my code-logic assertion");
    - Represent a condition that must never happen unless
      there has been a solidity programming error.
    - Check for conditions and throw an exception
      if the condition is not met
    - Should only be used to test for internal
      errors, and to check invariants
    - If used properly, analysis tools can
      evaluate your contract to identify
      the conditions and function calls which will
      reach a failing assert.
      Properly functioning code should never reach
      a failing assert statement
    - compiles to INVALID 0xfe instruction
    - The EVM automatically raise assert-like exceptions when
      - access array at index greater than array length (or negative)
      - access fixed-length bytes"N" at a too large or negative index
      - divide or modulo by zero (ex.: 5 / 0 , 23 % 0)
      - shift by a negative amount
      - convert a value too big|negative into an enum type
      - call to zero-initialized variable of internal function type
      - call assert with an argument that evaluates to false
      - call function not matching any func. in contract
    -  Consume all gas available to the call
    - Error "rethrow"/"bubble up" in sub-calls

  └ require("required cond.", "error messsage");
    - pre/post check in in/out-data to function
    - Check for conditions and throw an exception
      if the condition is not met
    - Should be used to ensure valid conditions,
      such as inputs, or contract state variables
      are met, or to validate return values from
      calls to external contracts
    - optionally a message-string can be provided
    - compiles to REVER 0xfd instruction
    - Error "rethrow"/"bubble up" in sub-calls
    -  Do not consume gas(v.Metrópolis+)  (Re-check this claim)

    - The EVM automatically throw requike-like exceptions when
      call a function via a message call but it does not
      finish properly (i.e. it runs out of gas, has no
      matching function, or throws an exception itself),
      except when a low level operation call, send,
      delegatecall or callcode is used.

  └ if ("business condtion") revert("error message");
    - business logic exceptions, like invalid request
      for current state.
    - can be used to flag an error and revert the
      current call.
    - It is possible to provide a string message
      containing details about the error that will
      be passed back to the caller.
    - Error "rethrow"/"bubble up" in sub-calls
    -  Do not consume gas(v.Metrópolis+)  (Re-check this claim)

  WARN : low level ops return false, no assert/require/revert exception is raised.
   Example of low levels conditions returning false:
   (or true when called account is non-existent,
    Existence must be checked prior to call)
   - create a contract using "new" but contract creation does not finish properly.
   - perform external function call targeting a contract that contains no code
   - contract receives Ether via public function without payable modifier
     (including constructor or fallback)
   - contract receives Ether via public getter function
   - .transfer() fails

☞ Solidity compiler automatically generate exceptions (assert or require/revert?) if:
  - If your contract receives Ether via a public function without payable modifier
    (including the constructor and the fallback function)
  - If your contract receives Ether via a public getter function
  - If you call a zero-initialized variable of internal function type
  - If a addressInstance.transfer() fails
  - The provided string in require/revert will be abi-encoded as if it
    were a call to a function Error(string). Ex:
    revert("Not enough Ether provided.");
    └───────────────┬───────────────────┘
    The following string of hexadecimal digits data  (vs byte array) will be
    set as error return data:
    (NOTE: no carry-return exists in real output. Fake layout just for clarity)

    0x08c379a0                                                       ← Function selector for Error(string)
    0000000000000000000000000000000000000000000000000000000000000020 ← String offset  ┐
    000000000000000000000000000000000000000000000000000000000000001a ← String length  │ String
    4e6f7420656e6f7567682045746865722070726f76696465642e............ ┐                ├─ABI encoding
    ................................................................ ├ String payload │
    ................................................................ ┘ (utf8 hex enc) ┘

  revert reason
  Since Solidity 0.4.22 the require() and revert() operation optionally
  take a revert reason as argument: Revert with reason.
  This is accessible for eth_calls in the result field.

  Clients libraries will eventually support fetching such value.
  Ex: web3j REF: @[https://github.com/web3j/web3j/issues/858]

  Have a method public String getRevertReason() on
  org.web3j.protocol.core.methods.response.EthCall that retrieves
  that revert reason.

  See also (future/rejected?) proposal Typed Errors EIP 838
  @[https://github.com/ethereum/EIPs/issues/838].
  Ex of proposal:
  contract MyToken {
    error InsufficientFunds(uint256 amount, uint256 balance);  // ← Strongly typed error

    function ... {
      if (! "assertCondition")
         throw InsufficientFunds(_amount, balances[msg.sender]);
      ...
    }
    ...
  }

  Related. Extracted from:
  @[https://besu.hyperledger.org/en/stable/HowTo/Send-Transactions/Revert-Reason/]

  besu requires the flag '--revert-reason-enabled' to include the revert reason in
  the TX receipt
    : It may use a significant amount of memory when connected to public  nets

  - When revert reason is enabled, the revert reason is included as an
   ABI-encoded string in the transaction receipt returned by eth_getTransactionReceipt.

    Important :
    revert reason is not included in the transactions receipts root hash.
    This means that the revert reason is only available to nodes that execute the
    transaction when importing the block.  That is, the revert reason is
    NOT available if using fast sync

  Example TX Receipt:
  {
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
       "from": "0x6273...57",
       "blockHash": "0xe72...0a",
       ...
       "revertReason" :"0x08c379a.....000"
     }                     ^
   }                       │
  ┌────────────────────────┘
  └─ Format: (Official  Solidity documentation),
     - ABI-encoded string consisting of:
       0x08c379a0                                                         // Error-Func.Sel.(string)
       0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
       0x000000000000000000000000000000000000000000000000000000000000001a // String length
       0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
         ^ Decodes to: "Not enough Ether provided"

     - Ex code extracting revert reason in Web3j:
       ...
       import org.web3j.protocol.core.methods.response.TransactionReceipt;
       import org.web3j.protocol.exceptions.TransactionException;
       import java.util.concurrent.CompletableFuture;

          try {
            // ... some code waiting for TX mining results
            CompletableFuture<SomeObjectDTO> futureResult = new CompletableFuture();
                             myContractProxy.doSendLog2BlockchainAsync(some_input_data, futureResult);
          } catch(Throwable e /* capture "everything */) {
            if (e instanceof TransactionException) {
              TransactionException te = (TransactionException) e;
              Optional<TransactionReceipt> tr = te.getTransactionReceipt();
              if (tr.isPresent()) {
                // https://dhondt.tech/blog/2019/1/Web3j-retrieve-revert-reason.html
                System.err.println"revert reason:"+tr.get().getRevertReason());
              } else {
                System.err.println("txReceipt not present");
              }
            }
          }
  #############################
  # try/catch (Solidity 0.8+) #
  #############################
  - Ex extracted from @[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/ERC1155.sol]

    try IERC1155Receiver(to).onERC1155Received(... )
        returns (bytes4 response) {
      if (response != IERC1155Receiver.onERC1155Received.selector) {
          revert("ERC1155: ERC1155Receiver rejected tokens");
      }
    } catch Error(string memory reason) {
        revert(reason);
    } catch {
        revert("ERC1155: transfer to non ERC1155Receiver implementer");
    }
[[}]]

● Solidity Best Patterns [[{12_solidity.101,20_QA.error_control,01_doc_has.tutorial,00_PM.WiP]]
  • Coding Convention List
    This section covers a series of recomendations in order to develop
    Solidity smart-contracts in order to improve the quality of code
    decreasing or eliminating common bugs as well as making code easier
    to read among developers.
     By following next coding convention among developers, we try to
    make code easier to read and understand. They are non normative and
    developers can use them as a reference.

 • Use some sort of convention agreement to prefix/suffix array types
    (e.g. suffix `_list`) and some prefix/suffix for map (key/value)
    structures (e.g, suffix `_map`). Note that in Solidity arrays and list
    are considered "similar" structures (vs arrays and list in Java, where
    ussually the later has better and more suitable properties than the
    former), since arrays are used scarcely, increasing slowly with incomming
    transactions and read by index most of the time.

 • Use `/* ... */` comments to make the map structure even more easy to
   understand.  Remember: Smart Contracts are LEGAL contracts reflecting
   rights and obligations. In next mapping it is not possible to understand
   what address and uint refer to. The variable 'balances' is a map,
   and array, something else (when using it later on in code)? What 'keys'
   refer to?

      mapping ( address , => uint ) balances;
      address[] keys;

   We can write it like:

      mapping (
        address /* effective identity address */
        => uint /* balances in tokens type 1  */ ) addressToBalance_map;

      address[] address_key_list /* keys used in addressToBalance_map */;

 • Variable types can easely become difficult to understand if
   not documented properly.  Use prefixes to be even more explicit about
   their types. Example:
    uint256 timeout ;    // ← Problem . Secs or milisecs or number of blocks ?
    uint256 ms_timeout ; // OK

 • In function declatarion use  multiple lines for visibility,
   mutability and returns keywords.

   Prefixing internal functions using C style underscore (`_`) can
   improve (somehow) readability in complex code.

    Alternative 1:                     Alternative 2 (PREFERRED)
    ==============                     =============
    function myFunction(            │  function _myFunction(
      uint256[] memory param1_list) │    uint256[] memory param1_lst)
      internal view returns         │  internal                     // visible inside S.C.
      (uint256[] memory)            │  view                         // mutability: View Only
                                    │  returns (uint256[] memory)   // return value/s

 • Use human-readable names:
   Prefer `_gasReceipt` to `_g` or `signature_lst` over `s_lst`.

 • Avoid named return values (even if allowed by Solidity syntax).

 • Error Control:
   · Use "require" to check input condition.
   · Use "if (condition) revert(...)" to check business logic conditions.
   · Use "assert" to check programming errors (theorically "asserts" must never
     assert to true in deployed production contracts.
   · KEY POINT:  Make precoditions execute in sequence (vs inside
                 concatenated 'if' statements). Never ever execute normal
                 flow inside an 'if' precontions.

     (VERY) WRONG.                      │ WRIGHT
     =============                      │ ============
     function ... {                     │ function ... {
       if (precondition1 == true) {     │   require(precondition1 == true, "...");
         if (precondition2 == true) {   │   require(precondition2 == true, "...");
           if (precondition3 == true) { │   require(precondition3 == true, "...");
             ... business logic         │   ... business logic  ...
           }                            │
         }                              │
       }                                │
     }                                  │  }



 • USING STATE MACHINEs:
   Many smart contracts can be reduced "somehow" to a description of "who is
   allowed to do what under which circumstances". This is basically an state-machine.
   Incomming Transfers are just events indicating the "who" in the signature.
   By clearly indicating the state machine the code will be much more readable,
   easier to mantain and less prone to errors.

 • FAIL-FAST: @[https://en.wikipedia.org/wiki/Fail-fast]
    As a rule of thumb, if a function doesn't know what to return it
   must revert the transaction (Remember: we are managing money). Add
   `OrThrow` prefix to make the intention clear to (third-parties)
   client code. Example:

     1 function getDelegatedAddressOrThrow(address _input_address)
     2 public
     3 external
     4 returns (address)
     5 {
     6     require (_input_address != 0, "BILLION_DOLAR_MISTAKE");
     7     address delegatedAddress = delegationDDBB[_input_address];
     8     require (delegatedAddress != 0, "INPUT_NOT_FOUND");
     9 }
    10
    11 function hasDelegatedAddress(address _input_address)
    12 public
    13 external
    14 returns (address)
    15 {
    16     require (_input_address != 0, "BILLION_DOLAR_MISTAKE");
    17     returns delegationDDBB[_input_address] != 0;
    18 }
    19
    20 function getDelegatedAddressOrDefault(address _input_address, address _default)
    21 public
    22 external
    23 returns (address)
    24 {
    25     require (_input_address != 0, "BILLION_DOLAR_MISTAKE");
    26     address delegatedAddress = delegationDDBB[_input_address];
    27     if (delegatedAddress == 0) return _default;
    28     return delegatedAddress;
    29 }

    In the previous code `getDelegatedAddressOrThrow` has no way to know
    if `_input_address` was correctly sent by the client (code outside
    Solidity control), or the value has not yet been updated (race
    condition, previous failure, ...). Code just "reverts and forgets".

    Client apps that want to know the value for a potentially
    unregistered / non-delegated address will check first calling to
    hasDelegatedAddress ("a la Python").

     It could be the case that client code has information enought to use
    a default value.  In that case we can add a `getDelegatedAddressOrDefault`
    to let client use a single query to the blockchain. This is faster,
    but potentially more error-prone.

      WARN: `error-free code` is better than `fast code`.
     Notice also how we protect against the billion-dolar mistake:
   @[https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions]
     from incoming client code data by always avoiding "ZERO" like values
     (that potentially means an unitialized/undefined/null variable in
      client code calling the smart-contract logic).

  • Use dependency injection extensively in constructors, spliting contracts into
    smaller ones. In practice, component injection is done manually in the
    deployment scripts.

  • Solidity (EVM actually) Limitations: [[{10_EVM.101]]
    - Stack effective size and EVM design by extension is very limited.
      When it grows beyond 16 elements old elements are not accesible
      anymore (compilation fails).
      This is enough to move balances from account to account, lock
      or do atomic swaps, ... but not much more.
    - Contract size is limited (in public/semi-public networks).
      Compiler will acept long contracts, but then the deployment will fail.
    - String support is limited (this is something good!, don't use them)
    [[}]]
[[}]]

● Solidty storage patterns [[{12_solidity.101,persistence.data_structure,20_QA.solidity,12_solidity.persistence]]
@[https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity]
Context:
   Simple and appropriate data organization can challenge Solidity newcomers.
   It wants us to organize everything in ways many of us aren’t accustomed to.
Q: Are there well-solved general patterns for routine on-chain data
   organization?

A: Here are some simple and useful patterns in increasing order of utility.
  WARN :
   Event logs omitted for brevity in example code.
   In real code they MUST be emitted for any state change.

 MAPPING WITH STRUCT         │SIMPLE LIST USING ARRAY  │STRUCT ARRAY WITH           │  MAPPED STRUCTS WITH      │ MAPPED STRUCTS WITH
                             │                         │ UNIQUE IDS                 │  INDEX                    │ DELETE-ENABLED INDEX  *1
── STRENGTHS ────────────────┼─── STRENGTHS ───────────┼── STRENGTHS ───────────────┼── STRENGTHS ──────────────┼── STRENGTHS ────────────────
 Random access by unique Id  │· Reliably chronological │· Random access by Row      │· Random access by Unique  │· Random access by Uniq.Id
 Assurance of Id Uniqueness  │  order of insertion     │  number                    │  Id or row number         │  or row number
 Enclose arrays, mappings,   │· Provides a count       │· Assurance of Id uniqueness│· Assurance of Id          │· Assurance of Id uniqueness
 structs within each "record"│· Random access by Row   │· Enclose arrays, mappings  │    uniqueness             │· Enclose arrays, mapping and
                             │  Number (not Id)        │  and structs with each     │· Enclose arrays/mappings" │  structs within each "record"
                             │                         │  "record"                  │  and structs within each  │· Count the records
                             │                         │                            │  "record"                 │· Enumerate the ids
                             │                         │                            │· List maintains decla-    │· Logically control the size of
                             │                         │                            │  ration order             │  the active list with delete
                             │                         │                            │· Count the records        │  function
                             │                         │                            │· Enumerate the Ids        │
                             │                         │                            │ · "Soft" delete           │
                             │                         │                            │   (by setting boolean val │
── WEAKNESS  ────────────────┼─── WEAKNESS  ───────────┼── WEAKNESS  ───────────────┼── WEAKNESS  ──────────────┼── WEAKNESS  ────────────────
· Unable to enumerate keys   │· No random access by Id │- No random access by Id    │ · Uncontrolled growth of  │· Marginally increased code
· Unable to count the keys   │· No uniqueness assurance│- Uncontrolled growth of    │   the list                │ complexity
· Needs a manual check to    │· No check for duplicates│  the list                  │                           │- Marginally higher store costs
  distinguish default from   │· Uncontrolled growth of │                            │                           │- Key list inherently unordered
  explicitly "all 0" record  │  list                   │                            │                           │
── EXAMPLE ──────────────────┼─── EXAMPLE ─────────────┼── EXAMPLE ─────────────────┼── EXAMPLE ────────────────┼── EXAMPLE ──────────────────
contract EntityDDBB {        contract EntityDDBB {     contract EntityDDBB {        contract EntityDDBB {       contract EntityDDBB {
│ struct EntityStruct {      │struct EntityStruct {    │struct EntityStruct {       │struct EntityStruct {      │ struct EntityStruct {
│   uint data;               │  address addr;          │  address addr;             │  uint data;               │   uint data;
│   bool isEntity;           │  uint    data;          │  uint    data;             │  bool exists;             │   uint lstPtr;
│ }                          │}                        │}                           │}                          │ }
│mapping                     │EntityStruct[]  public   │EntityStruct[] public ddbb; │mapping (address=>         │ mapping(address
│ (address => EntityStruct)  │  ddbb;                  │mapping(address => bool)    │         EntityStruct)     │    => EntityStruct)
│    public ddbb;            │                         │  knownEntity;              │    public ddbb;           │   public ddbb;
│                            │                         │                            │address[] public           │ address[] public list;
│                            │                         │                            │        entityLst;         │
│                            │                         │                            │                           │
│function                    │                         │function                    │function                   │function
│  exists(address addr)      │                         │  exists(address addr)      │exists(address addr)       │ exists(address addr)
│  public constant           │                         │    public constant         │    public constant        │     public constant
│  returns(bool isIndeed) {  │                         │    returns(bool) {         │    returns(bool){         │returns(bool) {
│  return  ddbb[addr].       │                         │  return knownEntity[addr]; │  return                   │ if(list.length == 0)
│            .isEntity;      │                         │                            │   ddbb[addr].exists;      │   return false;
│                            │                         │                            │                           │return ddbb[addr].lstPtr]==addr;
│}                           │                         │}                           │}                          │}

│                            │function getEntityCount()│function getEntityCount()   │function getEntityCount()  │function getEntityCount()
│                            │   public constant       │     public constant        │    public constant        │    public constant
│                            │   returns (uint) {      │     returns(uint) {        │    returns(uint) {        │ returns(uint entityCount) {
│                            │  return ddbb.length;    │  return ddbb.length;       │  return entityLst         │  return list.length;
│                            │}                        │}                           │          .length;         │}
│                            │                         │                            │}                          │
│                            │                         │                            │                           │
│                            │                         │                            │                           │
│function newEntity          │function newEntity       │function newEntity(         │function newEntity(        │function newEntity(
│    (address addr,          │   (address addr,        │    address addr,           │   address addr            │    address addr,
│     uint data )            │    uint data )          │     uint data )            |   uint data)              │    uint data)
│    public returns(bool) {  │   public                │    public                  │   public                  │ public
│  if(isEntity(addr)) throw; │returns(uint rowNumber) {│returns(uint rowNum) {      │returns(uint rowNumber) {  │ returns(bool success) {
│  ddbb[addr].data  = data;  │ EntityStruct memory aux;│  if(isEntity(addr)) throw; │  if(isEntity(addr)) throw;│  if(isEntity(addr)) throw;
│  ddbb[addr].isEntity =     │ aux.addr = addr;        │  EntityStruct memory aux;  │  ddbb[addr].data = data;  │  ddbb[addr].data = data;
│                 = true;    │ aux.data    = data;     │  aux.addr = addr;          │  ddbb[addr].exists        │  ddbb[addr].lstPtr =
│                            │ return ddbb.push(aux)-1;│  aux.data = data;          │     = true;               │    list.push(addr) - 1;
│                            │                         │  knownEntity[addr] = true; │  return                   │  return true;
│                            │                         │  return ddbb.push(aux)-1;  │  entityLst.push(addr)-1;  │
│}                           │}                        │}                           │}                          │}
│                            │                         │                            │                           │
│                            │                         │                            │                           │
│                            │                         │
│function updateEntity       │                         │function updateEntity       │function updateEntity      │function updateEntity(
│   (address addr, uint data)│                         │   uint rowNum, address addr,│(address addr, uint data) │    address addr,
│   public {                 │                         │   uint data                │    public {               │    uint data)
│  if(!isEntity(addr)) throw │                         │   public {                 │ if(!isEntity(addr)) throw;│public returns(bool success) {
│  ddbb[addr].data = data    │                         │ if(!isEntity(addr)) throw; │  ddbb[addr].data = data;  │  if(!isEntity(addr)) throw;
│}                           │                         │ if(ddbb[rowNum].addr!=addr)│                           │  ddbb[addr].data = data;
│                            │                         │    trhow;                  │                           │  return true;
│                            │                         │ ddbb[rowNumber].data =     │}                          │}
│                            │                         │                  data      │                           │
│                            │                         │}                           │                           │
│function delete             │                         │                            │                           │function delete
│  (address addr)            │                         │                            │                           │    (address addr)
│  public {                  │                         │                            │                           │  public
│  if(!isEntity(addr))       │                         │                            │                           │returns(bool success) {
│    throw ;                 │                         │                            │                           │ if(!isEntity(addr))
│  delete ddbb[addr];        │                         │                            │                           │  throw;
│}                           │                         │                            │                           │ uint rowToDelete =
│                            │                         │                            │                           │    ddbb[addr].lstPtr;
│                            │                         │                            │                           │ address keyToMov =
│                            │                         │                            │                           │   list[list.length-1];
│                            │                         │                            │                           │ list[rowToDelete] =
│                            │                         │                            │                           │   keyToMov;
│                            │                         │                            │                           │ ddbb[keyToMov].lstPtr
│                            │                         │                            │                           │   = rowToDelete;
│                            │                         │                            │                           │ list.length--;
│                            │                         │                            │                           │ return true;
│                            │                         │                            │                           │}
}                            }                         }                            }                           }
     * EXAMPLE Solidty version: 0.4.6
   *1  REF:
   Rob Hitchens@Medium  @[https://medium.com/@robhitchens/solidity-crud-part-2-ed8d8b4f74ec#.ekc22r5lf]
   Source Code          @[https://bitbucket.org/rhitchens2/soliditycrud/src/83703dcaf4d0c4b0d6adc0377455c4f257aa29a7/contracts/?at=master]
[[}]]

● Composed-keys in maps: [[{101,persistence.data_structure,20_QA.solidity,12_solidity.persistence]]
@[https://ethereum.stackexchange.com/questions/69727/map-multikey-how-to]
  • Alt1: create key like hash of N input composing keys
    Use events to trace input requests. e.j:
    bytes32 hashOfMultiKey = keccak256(abi.encodePacked(key1,key2));
    emit SomeEvent(key1, key2, bytes32 hashOfMultiKey, ...); ← event let observers track keys

      WARN : original keys are lost in contract state.

  • Alt2: Map of Map :
    mapping(                         ← allow to search by key1 or (key1,key2)
      bytes32            /*key1*/ =    More costly but keeps info.
        mapping( bytes32 /*key2*/
          => bytes32)
    );

    mapping(                         ← allow searchs by key2 or (key2,key1)
      bytes32            /*key2*/ =    (if key2 is not a subkey of A)
        mapping( bytes32 /*key1*/
          => bytes32)
    );
[[}]]

● Sorted Linked List: [[{101,persistence.data_structure,20_QA.solidity,12_solidity.persistence]]
@[https://github.com/vittominacori/solidity-linked-list]
• utility library for using sorted linked list data structures.
• Well maintained as of 2022-01
• Public methods:
  listExists | nodeExists | sizeOf
  get(Node|Adjacent|NextNode|PreviousNode|SortedSpot)
  insertAfter | insertBefore | remove
  pushFront | pushBack
  popFront  | popBack
[[}]]

• EnumerableSet: [[{101,persistence.data_structure,20_QA.solidity,12_solidity.persistence]]
@[https://docs.openzeppelin.com/contracts/2.x/api/utils#EnumerableSet] [[}]]

● Iterable map (arachnid gist) [[{101,persistence.data_structure,20_QA,12_solidity.persistence]]
@[https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1]
library itmap {
    struct entry {
        // Equal to the index of the key of this item in keys, plus 1.
        uint keyIndex;
        uint value;
    }

    struct itmap {
        mapping(uint => entry) data;
        uint[] keys;
    }

    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
        entry storage e = self.data[key];
        e.value = value;
        if (e.keyIndex > 0) {
            return true;
        } else {
            e.keyIndex = ++self.keys.length;
            self.keys[e.keyIndex - 1] = key;
            return false;
        }
    }

    function remove(itmap storage self, uint key) internal returns (bool success) {
        entry storage e = self.data[key];
        if (e.keyIndex == 0)
            return false;

        if (e.keyIndex < self.keys.length) {
                      // Move an existing element into the vacated key slot.
                      self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;
                      self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];
                      self.keys.length -= 1;
                      delete self.data[key];
                      return true;
                  }
              }

              function contains(itmap storage self, uint key) internal constant returns (bool exists) {
                  return self.data[key].keyIndex > 0;
    }

    function size(itmap storage self) internal constant returns (uint) {
        return self.keys.length;
    }

    function get(itmap storage self, uint key) internal constant returns (uint) {
        return self.data[key].value;
    }

    function getKey(itmap storage self, uint idx) internal constant returns (uint) {
        return self.keys[idx];
    }
}

contract Test {
    // Use itmap for all functions on the struct
    using itmap for itmap.itmap;

    // Declare an iterable mapping
    itmap.itmap mymap;

    function insert(uint key, uint value) {
        mymap.insert(key, value);
    }

    function get(uint key) returns (uint value) {
        return mymap.get(key);
    }
}
[[}]]

● QA: Static/Dyn. Code analysis [[{01_doc_has.comparative,security.101,12_solidity.qa]]
  by QuillAudits, security Firm
  @[https://blog.quillhash.com/static-and-dynamic-analysis-of-smart-contracts-vulnerabilities/]
  @[https://audits.quillhash.com]

  • STATIC ANALYSIS:

    STEP 1   ▸  STEP 2     ▸ STEP 3      ▸ STEP 4    ▸ STEP 5
    ────────    ──────────   ───────────   ─────────   ───────────────────────
    Solidity    compiler     Recover       functions   · known attacks detection
    Source      sol          meaninful     modifiers   · Gas optimizer linters
    Code        --ast-json   information   variables   · STATIC CODE ANALYSIS
                             from          ...           Find bugs that standar compiler
                             ast-tree                    is not able to detect

      KNOW ATTACKS TESTS                SEVERITY LEVEL    STATIC CODE ANALYSIS LIMITATIONS
      -----------------------------     --------------    --------------------------------
      - Reentrancy                      - High            - not a complete Sec tool.
      - uninitialized states            - Medium          - Only known attacks or
      - unused internal functions       - Low               predefined rules can
      - Functions Transferring ethers   - Informational     be scanned.
        (check modifiers/authenticity)
      - Ether lock
      - Gas optimization etc.


  • DYNAMIC ANALYSIS
    - Dyn.Ana. tests the code in a run-time setup
    - Dummy (or boundary) values are taken as input
      according to the conditions of function.

    - Most of the dynamic analysis tools use:
      - symbolic analysis
      - fuzzers
      - formal verification to secure smart contract.

  • SYMBOLIC ANALYSIS
    - analyzes a program to determine what inputs
      cause each part of a program function to execute.

    Compared to traditional functional testing:
    - function "input values" are used to test function i.e
      ‘123’, ‘Hello’ concrete values,
    - Symbolic analysis: no specific input is taken at present but a
      default value:
      - let's say ƛ is taken as an input after reaching at conditional
        statement it fork the state and two different values are taken.

    Ex: Our goal will be to see if we can use symbolic analysis
        to show that it is possible to get the result of the next function
        to be 100.

     01 function test(uint256 value) public pure returns(int) {
     02   uint result = 0;
     03   if (value > 100) {
     04     result += 100;
     05   }
     06   return result;
     07 }

      NORMAL DYNAMIC TESTING  | SYMBOLIC ANALYSIS
      (input = 50)            | (input = ƛ)
    --------------------------+-------------------------
      value  = 50 (line 1)    |        value  =  ƛ (line 1)
                              |
      value  = 50 (line 2)    |        value  =  ƛ (line 2)
      result =  0             |        result =  0
                              |
      value  = 50 (line 3)    |        value  =  ƛ (line 3)
      result =  0             |        result =  0
                              |
      value  = 50 (line 7)    | value  =  ƛ (line 7)       value  = ƛ    (line 4)
      result =  0             | result =  0 if ƛ<=100      result = 100  if ƛ>100
                              |
                              |                            value  = ƛ    (line 7)
                              |                            result = 100  if ƛ>100

     we use symbolic analysis to find the input values to execute function
     input_list [ <=100, >100 ]

  • FUZZING SMART CONTRACT
    - Type of testing in which seed inputs or set of inputs are taken
      to discover new inputs automatically  that might highlight coding
      errors or security loopholes in smart contracts, by inputting
      invalid or random data called FUZZ to the smart contract.
      After which the smart contracts are monitored for various path
      generated or error handling.

      Analyze     extract Data type   ABI signature   generate Fuzzing
      Byte Code → and signature of  → analysis      → inputs, based on  →
      + ABI       of functions                        first 3 steps

         Fuzzing      Vulnerability
       → proccess  →  analysis, based on
         starts       generated logs

      - fuzzer can be classified into three categories based
        on testing techniques:
         -  Black box testing
            The fuzzer didn't get any information about the contract
            performing millions of mutants( inputs ) while testing
            a smart contract.
            - PROS:
              - Millions of input values in few seconds is used to
                find loopholes in smart contracts.
            - CONS:
              - statement or code coverage is "random"

         -  White box testing
            fuzzer have information about smart contracts input values
            They use symbolic analysis to test smart contracts,
            - PROS:
              - cover most of the paths
              - It wil use multiple searching techniques to
                generate new paths like heuristic searching technique.
         -  Grey box testing
            fuzzer has partial knowledge of smart contracts
            They are the most popular fuzzers in finding the
            vulnerability of smart contracts.
            - lightweight testing approach that effectively
              detects bugs and security vulnerabilities.
            - greybox fuzzers randomly mutate program inputs
              to exercise new paths; this makes it challenging
              to cover code that is guarded by complex checks
            - PROS:
              - cover most of the paths
      Grey box Fuzzing and formal verification are a very popular way to
      secure smart contracts these days but didn’t get the edge yet,
      tools under these techniques are still under development or not
      production-ready.

      TODO: "...In upcoming articles, we will discuss what is formal verification
            and how formal verification can help in securing smart contracts..."

  REFS:
  @[https://arxiv.org/pdf/1807.03932.pdf]
  @[https://arxiv.org/pdf/1807.07875.pdf]
[[}]]

● QA: FORMAL PROOFs [[{20_QA.formal_verification,12_solidity.qa,00_PM.WiP]]
• External Links
  • @[https://github.com/pirapira/eth-isabelle]
  • @[https://github.com/pirapira/ethereum-formal-verification-overview]
  • @[https://gitter.im/ethereum/formal-methods]
  • @[https://en.wikipedia.org/wiki/Logical_harmony]
    Logical harmony, a name coined by Sir Michael Dummett, is a supposed
    constraint on the rules of inference (https://en.wikipedia.org/wiki/
    Rules_of_inference) that can be used in a given logical system(
    https://en.wikipedia.org/wiki/Logical_system)

● QA: FORMAL PROOFS. SMTChecker ACTIVATED BY DEFAULT IN SOLIDITY COMPILER 0.8.4+
  - ('pragma experimental SMTChecker;' in previous versions)
  @[https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst]
  - Perform automated mathematical-proof that source code fulfills a
    certain formal specification.  THE SPECIFICATION IS STILL FORMAL
    (JUST AS THE SOURCE CODE), BUT USUALLY MUCH SIMPLER.

  - other verification checks at compile-time are:
    - Arithmetic under/overflow.
    - Division by zero.
    - Trivial conditions and unreachable code.
    - Popping an empty array.
    - Out-of-bounds index access.
    - Insufficient funds for a transfer.

  - Ej:
    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.8.0;

    contract Overflow {
        uint immutable x;
        uint immutable y;

        function add(uint _x, uint _y)
        internal pure
        returns (uint) {
            return _x + _y;        <···┐ Commenting 'require(...)' will warn:
        }                              │ > ...
                                       │ > Overflow, val. larger than 2**256 - 1
        constructor                    │ > happens here. Counterexample:
        (uint _x, uint _y) {           │ > x = 1, y = 11579208923731619...639935
            (x, y) = (_x, _y);         │ > x + y returns 0
        }                              │ >
                                       │ > · Overflow TX trace
        function stateAdd()            │ >   ...
        public  view returns (uint) {  │ >     Overflow.stateAdd()
          require(                 <···┘ >      add( _x, _y)
            x < type(uint128).max);      >       return _x + _y;
          require(                       >              ^^^^^^^
            y < type(uint128).max);
          return add(x, y);
        }
    }

● QA: FORMAL PROOFS. Why3 Solidity
  - Why3: rich language platform for deductive program verification
         for specification and programming.
    - Relies on external theorem provers (automated and interactive)
    - Standard library of logical theories included (integer and
      real arithmetic, Boolean operations, sets, maps, ...).
    - Developers can write WhyML programs directly and get
      correct-by-construction OCaml programs through an automated
      extraction mechanism.
    - WhyML (OCaml dialect) also used as an intermediate language
      for verification of C, Java, or Ada programs.
    - Easy to extend.

    https://forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts
    """
     We just merged a first pull request that allows Solidity to be
     formally verified.
     Only a small subset of Solidity is supported for now ...
     already possible to verify a recursive binary search routine on arrays:
     https://gist.github.com/chriseth/0c671e0dac08c3630f47
     STEP 1) Add  special tags in *sol comments:
             ///@why3 ... to formulate assertions.
     STEP 2) *.sol -> solc --formal -o ... -> output -> why3
    """

    - Why toolkit GUI:
      "... why3 itself is only a frontend to "provers".
      STEP 1). Install prover (alt-ergo, Z3 ,...)
      STEP 2). $ why3 config --detect    (""" it should detect your prover.""")

    - Video Tutorial:
  https://www.youtube.com/watch?v=Mzh4fyoaBJ0&feature=youtu.be&list=PL9oaY6Y4QxRZybj86eGItGVApxLXVIXHz
    - See also:
      - Virt.Machine for interactive Theorem Provers
      @[http://fc17.ifca.ai/wtsc/Defining%20the%20Ethereum%20Virtual%20Machine%20for%20Interactive%20Theorem%20Provers.pdf]
      @[https://chriseth.github.io/notes/talks/formal_devcon2/#/]
      @[http://www.cs.umd.edu/~aseem/solidetherplas.pdf]
[[}]]

● QA: (Py)Slither Solidity source analyzer [[{security,20_QA,12_solidity]] @ma
  @[https://github.com/crytic/slither]
  - Detects vulnerables with LOW FALSE POSITIVES.
  - Identifies where the error condition occurs in the source code
  - Built-in 'printers' to report crucial contract information
  - Detector API to write custom analyses in Python
  - Ability to analyze contracts written with Solidity >= 0.4
  - Intermediate representation (SlithIR) for high-precision analyses
  - Correctly parses 99.9% of all public Solidity code
  - Average exec. time: < 1 sec/contract

  • Tools:
    -  slither-check-upgradeability : Review delegatecall-based upgradeability
    -  slither-flat   : Flatten a codebase
    -  slither-erc    : Check the ERC's conformance
    -  slither-format : Automatic patches generation

  • Ussage:
    $ slither .                  # ← Truffle/Embark/Dapp/Etherlime application

    $ slither .../Contract01.sol # Single solidity file:
[[}]]

● QA MythX SYMBOLIC/DYNAMIC/STATIC/FUZZING ANALYSIS into Truffle/VS.Code/Embark/Remix  [[{security,12_solidity.qa]] @ma
  - WHOLE SET OF MICRO-SERVICES TO HANDLE
    LINTING AND OTHER CHECKS.
  - @[https://docs.mythx.io/en/latest/index.html#]

  - REF: @[https://media.consensys.net/mythx-pro-will-provide-the-most-robust-security-platform-in-the-ethereum-ecosystem-85c3465999b3]
  - Provide symbolic analysis.
  - downloaded 420,000+ times.
  - "... there’s a strong need for interconnected suite of Security tools
     covering the surface area that can be utilized at all stages of the
    development lifecycle .... Enter MythX..."
  - Can be run as a SaaS service.
  - Free version: runs in "quick" mode,  between 30 and 120 secs.
                  Very useful for double checking small code changes on the fly
  - MythX Pro: Scan for many more of the SWC IDs (Smart Contract Weakness
               Classification Registry) and for a longer amount of time,
               to get into deeper analysis.
  - See also: Truffle Security extension:
  @[https://github.com/ConsenSys/truffle-security]
  - Minimum viable MythX client written in JavaScript.
    @[https://github.com/b-mueller/sabre]
  - MythX Python library and CLI tool
    @[https://github.com/dmuhs/PythX]
[[}]]

● Sec.Tool Index(consensys) [[{security.101,12_solidity.qa,security,00_PM.WiP]]
@[https://consensys.github.io/smart-contract-best-practices/security_tools/]
  • Visualization  @ma
    - @[https://github.com/ConsenSys/surya]: displays a number of visual outputs
      and information about the contracts' structure.
      Also supports QUERYING THE FUNCTION CALL GRAPH.
    - @[https://github.com/raineorshine/solgraph]:generate "DOT graph" for
      function control flow and HIGHLIGHT POTENTIAL SECURITY VULNERABILITIES.
    - @[https://github.com/ethereum/evmlab]: Rich tool package to interact
      with the EVM. Includes a VM, Etherchain API, and a trace-viewer.
    - @[https://github.com/fergarrui/ethereum-graph-debugger] @ma
      - Graphical EVM debugger displaying the entire program control flow graph.

  • STATIC AND DYNAMIC ANALYSIS
    - @[https://github.com/trailofbits/echidna]
      The ONLY AVAILABLE FUZZER for Ethereum software, using property-testing
      to generate malicious inputs that break smart contracts.
    - @[https://github.com/trailofbits/manticore] - Dynamic binary
      analysis tool with EVM support
      @[https://asciinema.org/a/haJU2cl0R0Q3jB9wd733LVosL]
    - @[https://github.com/melonproject/oyente] - Analyze code for common
      vulnerabilities, based on @[http://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf].
    - @[https://securify.chainsecurity.com/]: Fully automated online static analyzer
    - @[https://tool.smartdec.net]: Static analysis of Solidity source code for
      security vulnerabilities and best practices.
    - @[https://github.com/quoscient/octopus]: Security Analysis tool with support
      for EVM and (e)WASM.

  • WEAKNESS OSSCLASSIFCATION & TEST CASES
 - @[https://github.com/SmartContractSecurity/SWC-registry/]:
    SWC definitions and a large repository of crafted and real-world
    samples of vulnerable smart contracts.
 - @[https://smartcontractsecurity.github.io/SWC-registry/]
    SWC-registry repo published on Github Pages

  • TEST COVERAGE:
  @[https://github.com/sc-forks/solidity-coverage]: Code coverage for Solidity testing

  • LINTERS:
    - @[https://github.com/federicobond/solcheck]
      (written in JS, heavily inspired by eslint)
    - @[https://github.com/protofire/solhint]
      IT PROVIDES BOTH SECURITY AND STYLE GUIDE VALIDATIONS.
    - @[https://github.com/weifund/solint]
    - @[https://github.com/duaraghav8/Solium]
[[}]]

[[{101,10_EVM.101,13_SLC.debugging,12_solidity.troubleshooting]]
● fixing "stack too deep" error:
  - Problem Context: Compiler tries to access a variable var1 that is beyond
    "16 depth in stack".  Compilation fails with error "stack too deep".
    EVM stack can be bigger than 16 elements, but OPCODES just can work with the closer 16
    due to opcode limitations (DUP1, DUP2, ... DUP16).

  - Solution 1:
    Starting with Solidity 0.8+ ABIv2 is considered establed and we can use it to invoque
    functions using structs that groups a bunch of imput parameters saving stack space.

    ABIv1                        ABIv2
    ======                       =====
    function XXX(                struct InputParams{
         param1_in_stack,             param1,
         param2_in_stack,             param2,
         param3_in_stack,             param3,
         ... ) {                      ...
    }                            }

                                 function XXX (InputParams param1_in_stack )


  - Solution 2: ("Patchy" but it works when nothing else does).
    When var1 is still accesible, copy it again to var1_clone like
    function XXXX(uint param1_in_stack, ..., ... ,....)  {
       ...
       uint var1_clone = param1_in_stack;
       ...
       someMap[var1_clone] = ...; // ← At this point var1_clone is still on the stack
                                       but param1_in_stack is "too far away"
    }

       FUNCTION
       STACK FRAME
       -----------
     0 local var3  ←  Copy, for. ex, input arg1 here to have access once stacks grows "too much"
     1 local var2
     2 local var1
     ...
    15 input  arg3 ┐  Created at function call. Since those are the deepest in
    16 input  arg2 ├─ the stack, they are the first to cause "stack too deep" problems
    17 input  arg1 ┘
    17 'return value' ← return statement cleans the stack and places result values here

    - Opcodes use arguments at different levels in the stack. Deeper levels are pushed first.
      If an argument is pushed after another, it should appear in the function signature
      after the former as well, otherwise it would push the other one down the
      stack before it could be used.

    WARN:  (@[https://blog.aventus.io/stack-too-deep-error-in-solidity-5b8861891bae])
    "...more difficult cases arise when calling functions in othe
     contracts or libraries , since the opcodes CALL and DELEGATECALL take
     7 or 6 input arguments each, with a lot more possibilities of
     interaction between the opcode and function arguments..."

  - Other solutions: C&P from: https://soliditydeveloper.com/stacktoodeep

    // SPDX-License-Identifier: MIT
    pragma solidity 0.7.1;

    contract StackTooDeepTest1 {
       function addUintsUsingInternalFunc(
            uint256 a,uint256 b,uint256 c,
            uint256 d,uint256 e,uint256 f,
            uint256 g,uint256 h,uint256 i
        ) external pure returns(uint256) {
            return _addThreeUints(a,b,c)    <··┐
                 + _addThreeUints(d,e,f)    <··┤
                 + _addThreeUints(g,h,i);   <··┤
        }                                      ·
                                               ·
        function _addThreeUints             <··· Solution 3: Create auxiliar
           (uint256 a, uint256 b, uint256 c)      internal function
          private pure returns(uint256) {
            return a+b+c;
        }

        function addUintsUsingBlockScoping(
            uint256 a,uint256 b,uint256 c,
            uint256 d,uint256 e,uint256 f,
            uint256 g,uint256 h,uint256 i
        ) external pure returns(uint256) {
            uint256 result = 0;
            { result = a+b+c+d+e; }       <-··· Solution 4. Use block scoping.
            { result = result+f+g+h+i; }
            return result;
        }
    }
[[}]]

● Solidty Voting Example: [[{12_solidity.101]]
@[https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial]
  contract Voting {
    uint       public   MIN_QUORUM      ;
    uint       public   DEBATING_PERIOD ;
    address    public   FOUNDE          ;
    Proposal[] public proposals         ;
    uint       public numProposals      ;

    struct   Vote {
      int UpOrDown;
      address voter;
    }

    struct Proposal {
      Vote[]  votes       ;
      mapping (address
            => bool) voted;
      bytes32 data        ;
      string  description ;
      uint    creationDate;
      bool    active     ;
      boolean result;
    }

    constructor(
      uint _minQuorum, uint _debating_period) {
        FOUNDE            = msg.sender;
        MIN_QUORUM       = _minQuorum || 10;
        DEBATING_PERIOD  = _debating_period * 1 minutes
                           || 30 days;
    }

    function newProposal(
      bytes32 _data, string _descrip)
    returns (uint Y proposalID ) {
        Y proposalID   = proposals.length++;
        Proposal p     = proposals[Y proposalID ];
        p.data         = _data;
        p.description  = _descrip  ;
        p.creationDate = now;
        p.active       = true      ;
        numProposals   = Y proposalID +1;
    }

    function vote(
      uint _Y proposalID ,
      int _UpOrDown /*+1|-1*/)
    returns (uint   voteID ){
      if (_UpOrDown < -1 && _UpOrDown > 1 )
        revert("UpOrDown is not valid") ;
      Proposal p = proposals[_Y proposalID ];
      if (p.voted[msg.sender] == true) return;
        voteID  = p.  votes .length++;
      p.  votes[  voteID ] =
        /*new*/Vote( {
           UpOrDown: _UpOrDown,
           voter: msg.sender} ) ;
      p.voted[msg.sender] = true;
    }

    function executeProposal(
      uint _Y proposalID )
    returns (int   result ) {
      Proposal proposal = proposals[_Y proposalID ];
      if (   now > (proposal.creationDate + DEBATING_PERIOD )
          && proposal.active ){
         uint quorum = 0;
         for (uint i = 0; i <  proposal.  votes .length; ++i) {
           Vote v = proposal.  votes [i];
           quorum += 1;
           result += v.UpOrDown;
         }
         if (quorum < MIN_QUORUM ) {
           proposal.active = false;
           proposal.result = result &gt;=0 ? true : false;
         }
      }
    }
  }
[[}]]


[[{tokens]]
● Universal Token: [[{security.aaa,02_use_case.finance,00_PM.WiP]]
@[https://github.com/ConsenSys/UniversalToken] #[universal_token]
- "A Unique Standard for Centralized and Decentralized Finance Use Cases"
- Actively maintained as 2022-03-14
- Inspired by ERC-2020 and Hash Time Locked Contract and (HTLC) implementations.

- Certificate-based token transfers: [[{standards.TLS,integration.PKI,signature.multisignature]] @ma
@[https://github.com/ConsenSys/UniversalToken/blob/master/contracts/certificate/README.md]
  - Codefi Assets is an extension to ERC-1400 (extension to ERC-20) using the  data" payload
    to send a TLS CERTIFICATE GENERATED OFF-CHAIN:
    - At (EVM) TX execution, 'ec-recover' is used to recover the
      signature of the TLS certificate signer and then compared
      to the list of signatures authorized by the contract.
  -  Sort of multi-signature within 1 transaction. ← !!!   [[{20_QA.UX}]]
      signature of the investor (ethereum transaction signature)
    + signature of the issuer   (embedded certificate signature) [[}]]

  - Designed to enable issuance of  ANY type of asset or financial instrument :
      - DeFi derivative. - wholesale CBDC  - gaming asset.
      - loan             - ...             - Fund issuance
      - mortgage         - invoice         - ...
      - retail           - contract

- Delivery-vs-payment:
@[https://github.com/ConsenSys/UniversalToken/blob/master/contracts/tools/DVP.md]
  Use-case: allow secure token transfers/exchanges between 2 stakeholders
  ("holder1" and "holder2" in secondary market assets transfers.

[[}]]

● ERC-20 Fungible Token: [[{tokens.ERC20]]
  - REF:
    -@[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md]
    -@[https://theethereum.wiki/w/index.php/ERC20_Token_Standard]
    - Problems with the Standard:
    @[https://edcon.io/ppt/two/Dmitry%20Khovratovich_Secure%20Token%20Development%20and%20Deployment_EDCON.pdf]
  - Standard interface to Fungible Assets Contracts that
    different wallets  will understand out-of-the-box. A list of
    ERC20 compliant wallets can be found at:
  @[https://tokenmarket.net/what-is/ethereum-token-wallets/]

  • ERC-777 Fungible Token (ERC-20 Extension) :
    - extension backward compatible with ERC-20 including:
      - operators to send tokens on behalf of another contract|external acct.
      - send/receive hooks to offer token holders extended control, eg:
        allow holder to reject|ban tokens from given addresses.
    - It takes advantage of ERC-820 to find out whether and where to
      notify contracts|external-acct when they receive tokens as
      well as to allow compatibility with already-deployed contracts.
    - Master Tessis @[https://github.com/0xjac/master-thesis]

    - introduced to establish an evolved Token standard which learned
      from misconceptions like approve() with a value and the
      send-tokens-to-contract-issue.

    - Makes use of new standard ERC-820:
      Pseudo-introspection using a registry contract which allows for
      registering meta-data for contracts to provide a simple type of
      introspection. This allows for backwards compatibility and other
      functionality extensions, depending on the ITokenRecipient returned
      by a EIP-820 lookup on the to address, and the functions implemented
      by the target contract.

    - Adds lot of learnings from using ERC-20 Tokens, eg.
      white-listed operators, providing Ether-compliant interfaces with
      send(...), using ERC-820 (universal registry) to override and
      adapt functionality.

  • ERC-223 (ERC-20 Extension) :
    - REF: @[https://github.com/ethereum/EIPs/issues/223]
    - "...ERC20 token standard is leading to money losses for end users.
       The main problem is lack of possibility to handle incoming ERC20 transactions,
       that were performed via transfer function of ERC20 token..."

       "A" SENDING     CONTRACT send  1 Ether      , 1   Token       to "B"
       "B" DESTINATION CONTRACT is  NON-Ether aware, NON-Token aware.
       Result:
       A  →  B: 1ETH   ←   OK , rejected
       A  →  B: 1TOKEN ←   K  , possibly accepted since "B" can NOT recognize
                                incoming TX.
                                tokens stuck at the "B" balance

  • ERC-1400: ERC-20 Extension allowing to send arbitrary extra data. (ex. X.509 cert,
              used by Consensys "Universal Token". More info at See @[#universal_token])

  • ERC-621: ERC-20 + [increaseSupply,decreaseSupply] extension (vs original single issuance)
    - REF @[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-621.md]

  • ERC-827: ERC-20 Extension allowing executions of calls inside transfers/approvals.
  @[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-827.md]
[[}]]
● ERC-721 NFT [[{tokens.ERC721]]
  @[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md]
- Standard interface for non-fungible ("deed") tokens, represent the
  ownership right/obligation over digital or physical asset. Ex:
  - house ownership rights.
  - loans obligations.

- ERC-721 rights/obligations can be consigned to third party
  brokers/wallets/auctioneers ("operators").

- Genobank.io Example:
  """ Daniel Uribe from Genobank.io will talk about their mission of
      building a secure and decentralized P2P Genomic Network on the
      Ethereum blockchain.
       He will describe how they are using ERC721 and ERC1155 to record
      unique genomic variants along with the use of IPFS and proxy
      re-encryption to allow for private and secure sharing of DNA data.
      - ERC721 and ERC1155 for recording and transmitting genomic data
      - Proxy re-encryption to secure data and protect privacy
      - The Ethereum blockchain to keep track of the informed consents
  """
[[}]]
● ERC-1155 NFTs + FT + batch [[{tokens.ERC1155,02_use_case.nft_marketplace,12_solidity.tokens]]
 - Standard interface for contracts managing multiple token types.

                 ┌·>     4000  Gold Coins , non-inflactionary ┐
                 ├·>    10000  FIAT Coins ,     inflactionary │ FT Tokens can be used as
                 ├·>     3000       Bonus , non-inflcationary ├ payments mechanism in different
                 ├·>      ...                                 │ legal contexts.
                 ├·>      ...                                 ┘
    ERC-1155  1 ←│
                 ├·>  100 NFT type 1      ,                   ┐ 100 NFT are still unique.
                 ├·>    1 NFT type 2      ,                   │ in the sense that each of
                 ├·>    1 NFT type 2      ,                   ├ them can have a distinct
                 ├·>      ...                                 │ traceable history (or Serial
                                                              ┘ number)

  - NOTE: Some Multiplayer Games Have LOTS of different Items/Tokens
          - Runescape: 35,000+
          - World of Warcraft: 100,000+ different items!
          - Overwatch, Team Fortress 2: 1000's of skins + items.

  - Natively supported by MetaMask (probably other wallets)

  - Without ERC-1155:
    - for each token and item type we require deploying a separate contract
      (74000+ deployed tokens since 2015).
    - Fungible and non-fungible tokens are not very compatible with each other.

  - With    ERC-1155:
    - configuration data per Token ID.
    - Atomic Multi-Transfers / Swaps get much simpler.
    - functions 'transfer','approve','melt','trade' take arrays as
      parameters allowing for tens/hundreds of operations in a single TX.

  - compliant implementations MUST aslo implement ERC-165 "supports" Interface
    function and return "true" for 0xd9b67a26 interfaceID argument.

   @[https://eips.ethereum.org/EIPS/eip-1155]
     - NOTE 1: `_operator`: address of an account/contract approved to make the transfer (SHOULD be msg.sender)
     interface ERC1155 /* is ERC165 */ {
         event TransferSingle( address indexed _operator, address indexed _from, address indexed _to,
                               uint256 _id              , uint256 _value );
         event TransferBatch ( address indexed _operator, address indexed _from, address indexed _to,
                               uint256[] _ids           , uint256[] _values);

         event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved );

         event URI( string _value, uint256 indexed _id);

         function safeTransferFrom(
           address _from, address _to,
           uint256 _id, uint256 _value,
           bytes calldata _data
         ) external;

         function safeBatchTransferFrom(
           address _from, address _to,
           uint256[] calldata _ids, uint256[] calldata _values,
           bytes calldata _data
         ) external;

         function setApprovalForAll(
           address _operator, bool _approved
         ) external;

         // VIEW:

         function balanceOf( address _owner, uint256 _id )
         external view returns (uint256);

         function balanceOfBatch(
                  address[] calldata _owners, uint256[] calldata _ids )
         external view returns (uint256[] memory);

         function isApprovedForAll( address _owner, address _operator )
         external view returns (bool);
     }

     ERC-1155 Token Receiver : MUST be implemented by S.C. accepting transfers.
     // ERC-165 identifier: 0x4e2312e0.

     interface ERC1155TokenReceiver {  // Receiver "hook"
       function onERC1155Received(
         address _operator, address _from,
         uint256 _id, uint256 _value,
         bytes calldata _data)
       external returns(bytes4);

       function onERC1155BatchReceived(
         address _operator, address _from,
         uint256[] calldata _ids, uint256[] calldata _values,
         bytes calldata _data
       ) external returns(bytes4);
     }

  • ERC-1155 MICRO-HOW TO:
    * PRESETUP) Get test ethers:
      ▸ https://faucet.rinkeby.io
        ▸ click "Give me ethers" (Follow instruction in page)

    * STEP 1) Create standard metadata (needed by wallets, marketplaces, ...)
      accesible from public URL:
      ▸ https://"meta"/.../0000...(64 hex zero-left padded) ..0000000001.json
        {
           "name" : "MY_FUNGIBLE_OR_NFT_TOKEN_NAME_1" ,
           "description" : "Lorem Ipsum ..." ,
           "image" : "https://imageURL/MY_FUNGIBLE_OR_NFT_TOKEN_NAME_1.png"
        }

      ▸ https://"meta"/.../0000...(64 hex zero-left padded) ..0000000002.json
        {
           "name" : "MY_FUNGIBLE_OR_NFT_TOKEN_NAME_1" ,
           "description" : "Lorem Ipsum ..." ,
           "image" : "https://imageURL/MY_FUNGIBLE_OR_NFT_TOKEN_NAME_2.png"
        }

    * STEP 2) Create Solidity code: (Example implementation with OpenZepellin)
      ▸ REF: https://www.youtube.com/watch?v=SXp0sWmtuPc

        │ // SPDX-Licence-Identifier: MIT
        │ pragma solidity >=0.8 <0.9.0;
        │
        │ import "@openzepellin/contracts/token/ERC1155/ERC1155.sol";
        │
        │ contract MyCollectibles is ERC1155 {
        │   constructor() ERC1155("https://.../{id}.json") {
        │     _mint( msg.sender, 1 /* Id NFT Type 1 */, 10 /* Cantidad */, "");
        │     _mint( msg.sender, 2 /* Id NFT Type 2 */, 20 /* Quantity */, "");
        │   }
        │ }

    ▸ STEP 3) Use remix+Metamask or truffle deployments or ... to deploy to
      Rinkeby | MainNet | Private Net | ...

    ▸ STEP 4) Use some existing or custom "marketplace" to see the tokens.
      e.g:
      - @[https://rinkeby.rarible.com]
      - @[https://testnets.opensea.io/]  (Rinkeby)


  • ERC-1155 vs MarketPlaces&Exchanges: [[{02_USE_CASE.finance.liquidity_provision]]
                                        [[ 02_USE_CASE.finance.trading]]
    - ERC-1155 is short of an standard for an accountancy book. 
      It does not mandate any way to shell/buy the tokens reflected 
      in the accountancy book. MarketPlaces and Exchanges will be,
      in general, of any type and with no standard in mind. 
      An curated example of a real decentralized exchange supporting
      ERC-1155 "books" can be niftyswap:
      C&P from https://github.com/0xsequence/niftyswap             

      Implementation of the decentralized uniswap protocol                                         
       for ERC-1155 tokens. (Uniswap was designed for ERC-20 tokens)
     - Designed to favor ease of use.
     - Provide guaranteed access to liquidity on-chain.
     
     Context: 
     - Most exchanges maintain an order book and facilitate matches 
       between buyers and sellers.
     - Niftyswap smart contracts hold liquidity reserves of various
       tokens and trades are executed directly against these reserves.
     
     - Prices are set automatically using the constant product
       market maker mechanism, which keeps overall reserves in relative 
       equilibrium: Reserves are pooled between a network of liquidity 
       providers who supply the system with tokens in exchange for a 
       proportional share of transaction fees.
    [[}]]
[[}]]

[[tokens}]]

● Checking Signatures On-Chain [[{12_solidity,signature.multisignature,00_PM.WiP,20_QA.UX]]
- ECDSA signature == 65 byte array ( v (1), r (32), s (32) ).
  - web3.eth.sign (and others) can be used to insert extra signatures
    in a new transaction (other than the signed transaction itself)
  - OpenZepellin "recover(bytes32 hash, bytes signature) → address" allows
    to recover the original public address and apply any dessired
    business logic.  (e.g, deny transaction if less than N correct
    signatures are in place, ...)
   @[https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA]

  NOTE:  Most wallets will hash the data to sign and add the prefix
    '\x19Ethereum Signed Message:\n'. When attempting to recover
    the signer of an Ethereum signed message hash, 'toEthSignedMessageHash'
    is preferred.
  WARN :
[[}]]

● EIP-1271 [[{signature.multisignature,20_QA.UX]]
@[https://github.com/ethereum/EIPs/issues/1271]
- It should be implemented by contracts which desire to sign messages
 ("wallets", DAOs, multisignature wallets, etc.).
  Applications will call this method if signer is a contract (vs EOA).

- External "Dapps" can allow users to sign off-chain messages
  vs  directly requesting users to do an on-chain transaction.
  - Examples include decentralized exchanges with off-chain orderbooks
    like "0x" and "etherdelta".
- These Dapps usually assume that the message will be signed by
  the same address that owns the assets. However, one can hold assets
  directly in their regular account (controlled by a private key) or
  in a smart contract that acts as a wallet (e.g. a multisig contract).

- Current design of (many) smart contracts prevent contract based accounts
  from interacting with them, since contracts do not possess private keys
  and therefore can not directly sign messages.

- This proposal outlines a standard way for contracts to verify if a
  provided signature is valid when the account is a contract:

  - this is more than just validating signatures. We are actually
  asking the question:
  "GIVEN THIS ACTION, DOES THE CALLER HAVE THE ABILITY TO IT,
   GIVEN THIS PROOF?"

  - 'isValidSignature':
     Implementations can call arbitrary methods to validate a given signature.
    which COULD BE CONTEXT DEPENDENT (e.g. time based, state based,...).
    SIGNATURE SCHEME DEPENDENT (e.g. ECDSA, multisig, BLS), etc.
[[}]]


● EIP-2981: NFT Royalty Payments [[{02_use_case.royalty,tokens.ERC1155,tokens.ERC721]]
#[ERC_1155_summary]
- Current state (no-standard):
  Artist → MarketPlace: "Do you support royalty payments?"
  Artist ← MarketPlace: "Yes we do, but if your NFT is sold
                         on another marketplace then we cannot
                         enforce this payment."
  Artist → MarketPlace: "Don't you share royalty info with others?"
  Artist ← MarketPlace: "No, we DO NOT"

  """ It is believed that the NFT marketplace ecosystem will voluntarily
      implement this royalty payment standard since NFT buyers
      will assess the royalty payment as a factor when making NFT
      purchasing decisions. """

- Standard proposal designed to support ongoing funding of original
  NFT-creator or rights-holder to receive some quantity in future
  re-sales of its art-work.
  interface IERC2981 is IERC165 {
      function royaltyInfo( uint256 _tokenId, uint256 _salePrice)
      external view returns (
          address receiver,
          uint256 royaltyAmount
      );
  }
  NOTE: it's not restricted to any other standard appart of ERC-165.

- ROYALTY PAYMENT MUST BE VOLUNTARY (by Marketplace), vs triggered by
  "transferFrom()" like mechanism, since such transfer can just mean
  movement to a different wallet of the same owner (vs new sale or
  change of ownership).

- Marketplaces → SC: royaltyInfo()?
- Marketplaces ← SC: royalty payment information
                     ===========================
                     - royaltyAmount to pay for a given sale price.
                       as a (calculated) percentage of _salePrice.
                     - recipient address

 - royaltyInfo is not aware of _salePrice monetary-unit.
 - marketplaces MUST calculate final royalty price in the same monetary-unit
   used by the _salePrice.
 - if the calculated royaltyAmount is zero, no further processing is expected.
 - calculus of percentage is left un-specified mut marketplaces SHOULD
   implement it, with next restriction:
   - It must be based on predictable variables (vs using block.timestamp,
     block.number, ...) and must not make assumptions about the unit
     of exchange.
   - Examples:
   - It can be a fixed inmutable percentage.for any future sale.
   - Percentage drops linearly over time.
   - Based on min/max thresholds.
[[}]]

● EIP 1056: Lightweight Identity [[{02_use_case.identity,standards.W3C_DID,00_PM.TODO]]
 -  WARN: Unstable, likely to change.
  """ ...As we have been developing identity systems for the last couple of
  years at uPort it has become apparent that the cost of identity
  creation is a large issue. The previous Identity proposal ERC-725
  faces this exact issue. Our requirements when creating this ERC is
  that identity creation should be free, and should be possible to do
  in an offline environment (e.g. refugee scenario). However it must
  also be possible to rotate keys without changing the primary
  identifier of the identity. The identity system should be fit to use
  off-chain as well as on-chain..."""
[[}]]

● ERC-725: Lightweight Identity [[{02_use_case.identity,standards.W3C_DID,00_PM.TODO]]
@[https://erc725alliance.org/]
- Note: Current Identity Systems in Ethereum include
  (ref: https://w3c-ccg.github.io/did-method-registry/#the-registry)
  · did:erc725:    PROVISIONAL  Ethereum    Markus Sabadello,
                                            Fabian Vogelsteller
                                            Peter Kolarov
  · did:uport:     DEPRECATED   Ethereum    uPort
  · did:ethr:      PROVISIONAL  Ethereum    uPort
  · did:dom:       PROVISIONAL  Ethereum    Dominode
  · did:jolo:      PROVISIONAL  Ethereum    Jolocom
  · did:selfkey:   PROVISIONAL  Ethereum    SelfKey
  · did:pistis:    PROVISIONAL  Ethereum    Andrea Taglia
                                            Matteo Sinico
  · did:vaultie:   PROVISIONAL  Ethereum    Vaultie Inc.
  · did:gatc:      PROVISIONAL  Ethereum,   Gataca
                                Fabric,
                                Alastria
  · did:signor:    PROVISIONAL  Ethereum
                                Hashgraph   Cryptonics  Signor DID Method
- What is ERC 725?
  Proposed standard for self-sovereign identity (superseeded by EIP 1056?)
  - Identity is described by a proxy-SC that can be controlled by
    multiple keys and other smart contracts describing humans,
    groups, objects and machines.
  - ERC 735: associated standard to add|remove claims to an ERC-725 SC.
[[}]]

● ERC 780: Ethereum Claims Registry [[{02_use_case.identity,00_PM.backlog]]"
- proposal to allows persons, smart contracts, and machines to issue
  claims about each other, as well as self issued claims with the aim
  of providing a central point of reference for on-chain claims on
  Ethereum.
[[}]]

● EIP-1484: Digital Identity Aggregator [[{00_PM.backlog]]
  Identity management and aggregation framework.
  - Identities are represented via a singular Identity Registry SC.
    that can be associated to Ethereum addresses in a variety of
    meaningful ways.
  - Enables arbitrarily complex identity-related functionality.
  - They can natively support ERC-725 and ERC-1056 identities,
    and can be fully powered by meta-transactions.
[[}]]

● EVM/Solidity libraries: [[{12_solidity.101]]
@[https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736]
- Library benefits:
  - saving substantial amounts of gas
  - can make for a more secure environment (if reused libraries are audited).

- In Solidity, a library is a different type of contract
  (library myLib {...} vs contract myContract {...}) ,
  - It doesn't have any storage or ether.
  - It doesn't allow payable functions or  fallback functions.

  - It can be seen as a sort of a reusable code deployed at a
    given well-known address in the EVM that can called by
    any contract without the need to deploy it again.

- EVM DELEGATECALL instruction is used to call the function,
  causing the calling context to be passed to the library,
  as if it was code running in the contract itself.

  context kept by delegatecall:
  · this       <- address of calling-contract-invoquing-the-function.
  · msg.sender
  · msg.value
  · msg.sig
  · msg.data
  · msg.gas

 - Library linking happens at deploy time (vs storage level):
   - once setted it's linked for always:

   STEP 1) Compilation phase:
        contract A is compiled, leaving a placeholder for the lib.address:

    0073  __ C  _____________________________________ 630dbe671f
             C                                          ^^^^^^^
             C                                          0dbe671f is the function
             C                                          signature for a()

    * Before deploying the contract the placeholder must be
      replaced with the address of the deployed library in
      the blockchain.

- PROBLEM With Events sent by Libraries:
  Only problem is, right now (March 2017), the contract ABI does
  not reflect the events that the libraries it uses may emit.
   This confuses clients such as web3, that won't be able to
  decode what event was called or figure out how to decode its
  arguments.
  HACK: duplicate event definition in contracts.


● Popular libraries:
  • Modular network: [[{persistence.data_structure,12_solidity.strings]]
  @[https://github.com/modular-network/ethereum-libraries]
   - ArrayUtils, BasicMath, CrowdSale,
     LinkedList, StringUtils,
     Token, Vesting and Wallet.

   - OpenZeppelin: Roles, ECDSA, MerkleProof, SafeERC20,
     ERC165Checker, Math, SafeMath, Address, Arrays.
   @[https://github.com/OpenZeppelin/openzeppelin-solidity]

   - Dapp-bin:
   @[https://github.com/ethereum/dapp-bin/blob/master/library/]
     - IterableMapping :
     - DoublyLinkedList:
     - StringUtils [[{12_solidity.strings}]]
   [[}]]
[[}]]

● Development Tools List:
 @[https://ethereum.org/developers/#other-tools]
 @[https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/README.md]
 @[https://www.reddit.com/r/ethdev/comments/9jw839/long_list_of_ethereum_developer_tools_frameworks/]

● MetaMask Wallet Browser/Mobile wallet [[{wallet.metamask,dev_framework.js,security.aaa]]
  WARN,WARN,WARN:  (Update 2019-12) Metamask management problems:
@[https://metamask.github.io/metamask-docs/]

  - [[{00_PM.risks]]
    REF: https://www.bitcoininsider.org/article/79962/updated-metamask-contributor-says-project-lacks-support-consensys
   """... A contributor of major Ethereum browser extension Metamask has
     reported that the MetaMask team is “totally overwhelmed” and not
     being prioritized by its parent company ConsenSys.

     The post, titled “Help MetaMask out of its Activity-Trap,” goes
     on to say that the MetaMask team has a number of unsolved issues and
     its inner workflow structure is neither transparent nor
     decentralized. The post reads:

     “One cannot follow development via the public issue-tracker,
      simply because the team uses an internal tracker and internal
      ‘meetings.’ This is not transparent. This is not decentralized.
      MetaMask is a critical value-moving piece of Ethereum. It is written
      in JavaScript, nearly completely untyped. The code is of low quality,
      full of technical debt (both, in terms of code and architecture)..."""
   [[}]]

- Injects a window.ethereum web3 provider into the current web page
  when the extension is enabled.  (See also notes on eip-1193 standarization).
- It handles account management and  client-node management.
- Support for different hardware-wallets, while isolating them from the site context.
  (vs storing keys on central server, local storage, ..)
- API Reference
  · Ethereum_Provider ← "web3 provider object"
  · JSON_RPC_API
  · Experimental_APIs

- Calling a Contract from Web Browser with Metamask and ethjs
@[https://medium.com/metamask/calling-a-smart-contract-with-a-button-d278b1e76705]
(ethjs: lightweight alternative to web3.js)
  - PRE-SETUP) $ npm install ethjs

  - ethjs JS how-to)
   const Eth = require('ethjs-query')
   const EthContract = require('ethjs-contract')
   const CONTRACT_ADDRESS = '0xdea...'
   const CONTRACT_ABI = [{
          "name": "transfer", "inputs": [ ...  ], "outputs": [ ... ],
          ...
        }]

   function initContract (contract) {
     const MiniToken = contract(CONTRACT_ABI)  // <- Proxy JS object to real remote ABI
     const miniToken = MiniToken.at(address)   // <- Point to correct address.
   }

   function startApp(web3) {
     const eth = new Eth( web3.currentProvider  )
                          └──────────────────┴─ Injected by MetaMask
     const contract = new EthContract(eth)
     initContract(contract)
   }

   window.addEventListener('load', function() {
     if (typeof web3 === 'undefined') { return; }
     startApp(web3);
   })

   function onButtonCliced (miniToken) {
       miniToken.transfer(
         toAddress, value, { from: addr })
         .then( txHash => {
            console.log('Transaction sent')
            console.dir(txHash)
            waitForTxToBeMined(txHash)
          })
         .catch(e => { ... })
   }

● MetaMask Mobile [[{00_PM.TODO}]]
@[https://mobile.metamask.io/]

● What's new MetaMask
  • ver 8 (major upgrade)
  @[https://medium.com/metamask/announcing-metamask-version-8-9126dc2df98]

  - Unparalleled Privacy Control:
    select one or more accounts to associate with
    a website or create a new account just for that site .
  - EIP-2255 (site) permissions system. [[{qa.UX]]
       proposed standard interface for granting wallet security-sensitive
       asking "just once" in order to get permissions like:
       - "Reveal wallet address to a given site".
       - "Switch to preferred network".
       - "Sign a cryptographic challenge".
       - "Grant a token allowance to our contract".
       - "Send TXs to our contract".
       - ...
       - Users can "uncheck" permissions individually [[}]]
  - New features for Developers:
    - Allow websites to en/de-crypt messages intended for Web3 users:
      - For "Now"(20??) decryption requests require user confirmation:
        => mostly ideal for decrypting infrequent, important messages.
    - Enable web sites to implement custom connect buttons.
      (e.g.: allow user to seamlessly land on a site, install MetaMask,
       and be automatically redirected back to your application)

    - ERC-1193 Provider API:
      for consistency across clients and applications.
      Instead of (old) ethereum.sendAsync(options, callback)
      pattern everywhere, you now get a nice and simple
      const result = await ethereum.request({ method, params }).
      If you’re a developer that relies on the window.web3 object
      injected by MetaMask, you’ll need to implement changes before we
      remove the injected web3 object or your site will break.
      If you’re a developer that only relies on your own version of
      ethers or web3, you won’t need to take any action — just keep it
      up to date.
      IF CHOOSING A NEW CONVENIENCE LIBRARY, WE  RECOMMEND ETHERS. [[{01_doc_has.comparative}]]

    - Cutting Edge Security:
      The (new) LavaMoat tool helps raise the bar of security for
      nearly any JavaScript project by using  Secure EcmaScript
      to confine every third-party dependency in a piece of JS
      code at build time.

  • Lattice1 Metamask Integration (2021-11) [[{wallet.hardware,wallet.metamask]]
    @[https://consensys.net/blog/news/metamask-x-lattice1-the-hardware-wallet-designed-for-ethereum-users-is-now-supported/]
    - Lattice1 (by GridPlus): hardware wallet for Ethereum users.
    - MetaMask / Lattice1 is done through Wi-FI (vs USB).
    - Lattice1 aims to solve 3 big crypto security problems:
      - Leaking private keys:
        SafeCards securely back up seeds onto PIN-protected cards.
        Every SafeCard is essentially a physical carrier of an
        HD wallet seed that looks like a traditional credit/debit card.
      - Signing messages unintentionally:
        - big touch screen interface and human-readable markup.
        - supports for NFTs.
        - "enhanced" smart contract interaction.
      - great user experience in integrating with MetaMask.
[[}]]

● EIP-712 (Typed human-friendly signing): [[{20_QA.UX.wallet,wallet.metamask,wallet.lattice1,00_PM.TODO]]
  "Ethereum typed structured data hashing and signing"
 @[https://eips.ethereum.org/EIPS/eip-712]
- See also @[#eip-191]
- Introduction by Koh Wei Jie:
@[https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26]
  Ethereum wallets like MetaMask will soon introduce the EIP712
- It will ALLOWS WALLETS TO DISPLAY DATA IN SIGNING PROMPTS in
  a structured and readable format.
   USERS WILL NO LONGER NEED TO SIGN OFF ON INSCRUTABLE HEXADECIMAL
  STRINGS, WHICH IS A PRACTICE THAT CAN BE CONFUSING AND INSECURE.

- Related:
  - Lattice 1 GridPlus Hardware Wallet:
  @[https://blog.gridplus.io/latice1-firmware-v0-10-6-da18ec10f5b]

  - 1st with Native EIP-712 Support for Use with Uniswap V3, Polygon, and More!

 ... When Uniswap V3 launched, liquidity providers were unable to
  migrate their positions because Uniswap uses a new message type
  (EIP712) which is not yet supported on legacy hardware wallets using
  MetaMask and their assets were stuck. Not an issue for Lattice1
  owners... Competitors have publicly shared that even when they do
  support the feature, they will not be using their device's secure
  enclave and will instead create hashes in your computer's web
  browser. Never use your hardware wallet to blindly sign unknown
  hashes.

- Reference Implementation/Ussage @ 0xProject:
  https://github.com/0xProject/0x-monorepo/blob/development/
  ├─ contracts/utils/contracts/src/LibEIP712.sol
  ├─ contracts/utils/contracts/test/TestLibEIP712.sol
  ├─ contracts/coordinator/contracts/src/MixinCoordinatorApprovalVerifier.sol
  ├─ contracts/coordinator/contracts/src/libs/LibEIP712CoordinatorDomain.sol
  ├─ contracts/coordinator/contracts/src/libs/LibCoordinatorApproval.sol
  ├─ contracts/coordinator/contracts/src/MixinSignatureValidator.sol
  ├─ contracts/coordinator/contracts/src/Coordinator.sol
  ├─ contracts/exchange─libs/contracts/src/LibZeroExTransaction.sol
  ├─ contracts/exchange─libs/contracts/src/LibEIP712ExchangeDomain.sol
  ├─ contracts/exchange─libs/contracts/src/LibOrder.sol
  ├─ contracts/exchange─libs/contracts/test/TestLibEIP712ExchangeDomain.sol
  ├─ contracts/exchange─libs/contracts/test/TestLibOrder.sol
  ├─ contracts/exchange─libs/contracts/test/TestLibZeroExTransaction.sol
  ├─ contracts/dev─utils/contracts/src/DevUtils.sol
  ├─ contracts/exchange/contracts/src/interfaces/IExchangeCore.sol
  ├─ contracts/exchange/contracts/src/interfaces/ISignatureValidator.sol
  ├─ contracts/exchange/contracts/src/MixinTransactions.sol
  ├─ contracts/exchange/contracts/src/MixinSignatureValidator.sol
  ├─ contracts/exchange/contracts/src/MixinExchangeCore.sol
  ├─ contracts/exchange/contracts/src/Exchange.sol
  ├─ contracts/exchange/contracts/test/TestWrapperFunctions.sol
  ├─ contracts/exchange/contracts/test/TestTransactions.sol
  ├─ contracts/exchange/contracts/test/TestValidatorWallet.sol
  ├─ contracts/zero─ex/contracts/src/fixins/FixinEIP712.sol
  ├─ contracts/zero─ex/contracts/src/features/MetaTransactionsFeature.sol
  ├─ contracts/zero─ex/contracts/src/features/ISignatureValidatorFeature.sol
  ├─ contracts/zero─ex/contracts/src/features/SignatureValidatorFeature.sol
  ├─ contracts/zero─ex/contracts/src/features/IMetaTransactionsFeature.sol
  └─ contracts/exchange─forwarder/contracts/src/interfaces/IExchangeV2.sol

[[}]]

● META-TRANSACTIONS [[{wallet.metamask,10_EVM.gas,transaction,00_PM.TODO]]
@[https://defirate.com/meta-transactions/]
- meta transactions allow users to interact with a public
  blockchain without paying a transaction fee:
  - Users no longer have to understand the inner workings  [[{qa.UX]]
    of public blockchains and market dynamics for TX fees. [[}]]

- At its core, they are NEARLY IDENTICAL TO REGULAR NETWORK TXS
  BUT WITH THE ADDITION OF A PROXY CONTRACT, known as "relayer".
- Users still use their signature to sign TXs, then
  the signed TX is now managed by the relayer who
  pays the gas and sends the transaction to the
  receiving address.
[[}]]

● LedgerHQ Hardware Wallet: [[{wallet.hsm,20_QA.UX,security]]
@[https://github.com/LedgerHQ]
- LedgerJS examples: @[https://github.com/LedgerHQ/ledgerjs-examples]
- High activity on Github, including (non-complete list):
  - ledger-live-common : JS core for the Ledger Wallet apps
  - lib-ledger-core    : C++
  - TRX Ledger         : C, app-exchange
  - SWAP application   : C
  - ledger-wallet-daemon: Scala web server exposing Core API through
                         simple REST API
  - ledger-live-mobile : react-native, bluetooth
  - ledger-live-desktop: electron
  - wallet             : JS
  - openpgp-card-app   : C, OpenPGP Card Application
  - app-terra          : C, Nano S/Nano X
  - app-ethereum       : C, Wallet App for Ledger Blue and Nano S
  - app-bitcoin        : C, Bitcoin wallet app for Ledger Blue and Nano S
  - ledger-updater     : JS, Standalone firmware update / app install
  - ledger-scala-template: template for scala projects
  - ledger-dev-doc     : Python, Ledger developer docs.
  - ledger-app-store-front: JS
  - ledger-manager-chrome: Scala, Ledger Manager Chrome application
  - ledger-wallet-chrome: JS, Ledger Wallet Chrome application
  - ledgerctl          : Python Lib. to control Ledger devices

  - Does it support EIP-712(Typed human-friendly signing) ??
[[}]]

● Web3JS API [[{dev_framework.js.web3_js]]
- Ussage Ex. (works on browser/browser js console, web3.js v1+):

 const ctr = new web3.eth.Contract(abiDef, ctrAddress) // ← Create local JS "proxy"
 const txId = await ctr.methods.playGame().\           // ← playGame transparently creates
              send({from: sendingAccount               //   JSON-RPC, signs and sends.
                    value: amountInWei })              //   JSON-RPC, signs and sends.

@[https://github.com/ethereum/wiki/wiki/JavaScript-API]
- See also web3 alternatives: etherlime, ethers(recomended by MetaMask)
@[https://medium.com/limechain/etherlime-framework-8cbb270944d6]
  eth_accounts                                eth_getTransactionCount
  eth_blockNumber                             eth_getTransactionReceipt
  eth_call                                    eth_hashrate
  eth_coinbase                                eth_mining
  eth_compileSolidity                         eth_newBlockFilter
  eth_estimateGas                             eth_newFilter (includes log/event filters)
  eth_gasPrice                                eth_sendTransaction
  eth_getBalance                              eth_sendRawTransaction
  eth_getBlockByNumber                        eth_sign
  eth_getBlockByHash                          eth_syncing
  eth_getCode (only supports block "latest")  eth_uninstallFilter
  eth_getCompilers                            net_listening
  eth_getFilterChanges                        net_peerCount
  eth_getFilterLogs                           net_version
  eth_getLogs                                 miner_start
  eth_getStorageAt                            miner_stop
  eth_getTransactionByHash                    rpc_modules
  eth_getTransactionByBlockHashAndIndex       web3_clientVersion
  eth_getTransactionByBlockNumberAndIndex     web3_sha3

 • Web3JS Recipe: Calc. keccak256/sha3 of N-inputs:
   keccak256(abi.encodePacked(str1, addr1,...))   ←  Solidity (Which version is
   keccak256(string1, address1,...            )   ←  Solidity  the correct one?)

   web3.utils.soliditySha3(                       ←  Web3.js, Alt 1 : Easiest way
       { type: 'string',  value: myString01     },
       { type: 'bytes32', value: myBytes32value },
       ...
   )

   web3.sha3(                                     ←  Web3.js Alt 2 : Manual hard way
      web3.utils.toHex("test1") + "0A...20 bytes.."   ← 1st arg: ensure input is equal
                                                        to the tightly packed
      └───────┬───────────────┘     └──────┬──────┘     args in Solidity keccak256
     tightly pack string to Hex     Don't  pack address
                                    or hex strings (Remove 0x)
      ,
      {encoding:"hex"} );                             ← 2nd argument. Encode like hex input

 • Web3JS Recipe: Convert Input string to ABI representation
   web3.eth.abi.encodeParameter(
      "bytes32",web3.utils.fromAscii( str01 ));
[[}]]

● web3.js vs eth.js Comparative: [[{01_doc_has.comparative,dev_framework.js.web3_js,dev_framework.js.eth js]]
@[https://blog.infura.io/ethereum-javascript-libraries-web3-js-vs-ethers-js-part-i/]
Ethereum JavaScript Libraries: web3.js vs. ethers.js (Part I)
- Both libraries work!!

- Web3.js:
  - 2015
  - Ethereum Foundation Community.
  - It has a good API reference.
  - GLP v3
  - Support remote JSON-RPC.
  - current (2020-06) version: 1.2.9
  - 6 core modules:
    - web3: main class. "Core functionality"
    - web3-eth: API to interact with SC/EOA/nodes,
                mined blocks/TXs. Ex:
      - web3.eth.getBalance
      - web3.eth.signTransaction
      - web3.eth.sendSignedTransaction
      - ...
    - web3-shh: Whisper protocol. Broadcast messages
               for low-level asynch. communication.Ex:
      - web3.shh.post      : posts whisper msg to Net.
      - web3.shh.subscribe : creates subscription
      - ...
    - web3-bzz: Swarm decentralized storage API. Ex:
      - web3.bzz.upload   :   Upload files|folders to Swarm
      - Web3.bzz.download : Download files|folders from "
    - web3-net: Fetch Net. properties of node.
        - web3.???.net.getID       : return network ID
        - web3.???.net.getPeerCount: returns peer number
               └─┴─ := eth|shh|bzz
    - web3-utils: Ex:
      - web3.utils.toWei
      - web3.utils.hexToNumberString
      - web3.utils.isAddress  ← check if string is a valid address.

- Ethers.js: (Recomended by MetaMask for new WebApps)  [[{security.101]]
  - 2018:
  - Compatible with Truffle according to:
    https://ethereum.stackexchange.com/questions/50632/can-i-use-ether-js-with-truffle
    """ ...
       Truffle use Web3 by default and its injected inside as (hardcoded) global dependency.
       You CAN install ether.js as dependency:
         $ truffle init
         $ npm install --save ethers

       and then use it in truffle tests:
         var ethers = require('ethers');
       
       It is NOT compatible with "truffle develop" since only web3 would be injected.
   """

  - Looks to be more "proffesional".  C&P from:
    https://docs.ethers.io/v5/api/providers/   
     The default provider is the safest, easiest way to begin developing 
     on Ethereum, and it is also robust enough for use in production.
     
     It creates a FallbackProvider connected to as many backend services 
     as possible. When a request is made, it is sent to multiple backends 
     simultaneously. As responses from each backend are returned, they are 
     checked that they agree. Once a quorum has been reached (i.e. enough 
     of the backends agree), the response is provided to your application.
     
     This ensures that if a backend has become out-of-sync, or if it has 
     been compromised that its responses are dropped in favor of responses 
     that match the majority.
  [[}]]
  - JS + TypeScript
  - small, compact library.
  - "Simple" and "intuitive".
  - large number of test cases.
  - Good "Getting Started" documentation.
  - current (2020-06) ver.:  5.0.3.
  - MIT License.
  - Modules:
    - Ethers.provider
      - abstract connection to node/network.
      - sending signed TXs ("writes") and read-queries.
        - ethers.providers.InfuraProvider:  Infura "client"
        - ethers.provider.getBalance
        - ethers.provider.resolve ← resolve ENS to address

  - Ethers.contract
    - deploy S.C.
    - listen for events emitted
    - call functions
    - get S.C. information
    - Ex:
      - ethers.ContractFactory.fromSolidity:
        Creates "factory" for deployment of S.C. using
        as input:
        - Solc output or
        - Truffle generated JSON file
      - ethers.Contract : ← interact with deployed S.C.
  - Ethers.utils
    - formatting data , process user inputs.
    - Ex:
      - ethers.utils.getContractAddress: Address from deployment TX
      - ethers.utils.computeAddress    : pub/priv: key to address
      - ethers.utils.formatEther       : Wei s to decimal string
  - Ethers.wallets
    - connect to existing wallet, create new one, sign TXs.
    - Ex:
      - ethers.wallet.createRandom
      - ethers.wallet.sign
      -  ethers.wallet.getBalance
    - Equivalent to web3.eth.accounts, but in web3js doc it
      warns: "This package has NOT been audited and might
      potentially be unsafe. Take precautions to clear memory
      properly, store the private keys safely, and test TX
      receiving/sending properly before using in production!"

  Comparative in STATs:
              starts|Used by|Maintainers|Test   |Size |Unpacked
                    |(repos)|           |support|     |
  -   Web3.js:~8,800|51.300 |3 of 12    |       |     |10.6MB
  - ethers.js:~1,500|18.500 |1(Richard  |"WINS" |284kb| 3.5MB
                               Moore)
  - ethers.js has surpassed web3.js in weekly downloads (even if its younger)

  Documentation:
  -   Web3.js: extensive API ref, Short "Getting Started"
  - Ethers.js: extensive API ref, Good “Getting Started”  ← Winner
[[}]]

● Truffle Framework [[{dev_framework.js.truffle,12_solidity,13_SLC.testing,20_QA,13_SLC.debugging]]
  - Truffle Framework Full Journey: @[https://www.truffleframework.com/]
  - Truffle Framework Code reference:
    - https://github.com/trufflesuite/truffle/tree/develop/packages
    - https://github.com/trufflesuite/truffle/tree/next/packages/contract-tests/test
      ├─ errors.js: Error control example for "Out of gas", "revert reason". [[{20_QA.error_control}]]
      ├─ events.js: Example tests showing how to test for expected  future/past events [[{13_SLC.testing,10_EVM.events}]]
      ├─ abiV2.js
      ├─ cloning.js
      ├─ customoptions.js
      ├─ deploy.js: Example code showing deploy timeout control
      │             pre-flight gas-cost-estimation [[{10_EVM.gas}]]
      │             .on("confirmation",...) block-depth confirmation number
      ├─ deprecated_keys.js
      ├─ linking.js: Examples linking lib-to-lib, selective-relink, lib-to-SC,
      │             triggering compilations from JS code,
      ├─ methods.js
      ├─ networkObject.js
      ├─ networks.js
      ├─ separation.js
      └─ util.js


$ mkdir fibonacci                          ● CREATE NEW BARE TRUFFLE PROJECT
$ cd fibonacci
$ truffle init
 (Next files will be created)
 + ./contracts/Migrations.sol              <- WARN: DON'T TOUCH THIS FILE
 + ./migrations/1_initial_migration.js     <- WARN: DON'T TOUCH THIS FILE
 + test/               
 + build/contracts/                        <- WARN: build/contracts/ MUST BE VERSIONED IN GIT.
                                              - Important compilation metadata is recorded here as JSON.
                                              - On successful deployments ("migrations") the JSON is 
                                                updated (.network[$chainId]). Ej:
                                                $ cat build/contracts/ERC20.json | jq ".networks"
                                                {
                                                  "1": {                          <- ChainID (1 == "MainNet")
                                                    "events": {},                 <- Events emitted
                                                    "links": {                    <- Info to any library linked during 
                                                      "somelinkedlib": "0x3c5..."    deployment
                                                    },
                                                    "address": "0x77f90...",      <- Deployed SC address. Needed by clients.
                                                    "transactionhash": "0x603..." <- Can be used to find block number 
                                                  }
                                                  "111": { ...  }                 <- Some testnet.
                                                }

 + truffle-config.js                       <- Config remote Nodes and wallets used for
     ...                                      testing and deployment. By default the test network
     networks: {                              localhost:8545 is configured using existing wallets
       development: {                         managed by node (probably ganache)
         host: "127.0.0.1",
         port: 8545,
         network_id: "*"
       }
     }
$ editor contracts/Fibonacci.sol                       Create alphabetically ORDERED deployment script
$ editor migrations/2_deploy_contracts.js           <- to deploy the new S.C.
  const LibA = artifacts.require('LibA')      ┌······· require: similar to node.js "require" but it reads
  const B    = artifacts.require("Fibona..")  ·        *.json ABI (generated at compile time) as input and
                         └──────┴─············┘        returns autogenerated JS proxy code in charge of

UPDATE: 2022-07-25: artifacts.require is meant to be used in tests ONLY.
        Use "truffle-contract" in production code like:
        const contractBuilder = require("truffle-contract");
        const JSON = require("ABI/MyContract.json");
        const MyContract = contractBuilder(JSON);
        const deployedInstance = MyContract.deployed()
        ...

  module.exports = function(      deployer, network, accounts injected by truffle at migrate-time
        deployer,                 <- REF: https://github.com/trufflesuite
                                            /truffle-deployer/blob/develop/index.js
                                     Object with info about network, web3 (wallet) provider,
                                     basePath (== options.basePath || process.cwd())
        network,                  <- injected by truffle at migrate-time
        accounts                  <- ("wallets") defined in truffle-config.js
  ) {                                or retrieved from node
    if (network == "test") {
       deployer.deploy(LibA);     ← Deploy runs synchronously. Code waits until transaction has been mined
                                    in blockchain.
       deployer.link(library, A)  ← ☞ Link must be done before deployment
                                    (Ignored if contract doesn't rely on the library)
                                    @[https://github.com/trufflesuite/truffle/tree/master/packages/contract]
       deployer.deploy(A)         ← Set "A".address after correct deployment
       deployer.deploy(B,           overriding any previous one.
              A.address,          ← First constructor argument of B (A instance)
              { overwrite: true } ← Other options: gas, from
          );
       );
    } else if (network == "prod") {
       // Fetch A address from "somewhere"
       deployer.deploy(
           B, A.address,
            { overwrite: false } );
    }
  };

$ truffle compile                         <- Generates build/contracts/*.json, to be
                                             used by JS code to genetare JS "proxy" objects.
$ truffle migrate                         <- Migrate (deploy) to default net. in truffle-config.js
$ editor test/TestFibonacci.js            <- test S.C. behaviour as seen by external JS clients
                                             (front-end Dapps). Sort of "functional" tests.
                                             test js code ussually deploy new S.C. isolated from
                                             real ones, but any test is free to reuse already
                                             deployed contracts, libraries, ...
                                             The deployment JS code will mostly similar to the code
                                             used in migrations/*js

$ truffle test                            <- Execute tests.
$ truffle deploy                          <- Deploy contract. It will deploy Migrations.sol
                                             (if not yet done) to keep trace of deployments.
• TRUFFLE: DEBUG MINED TX
  NOTE: Trufle 5.1 introduces also debugging from JS tests:
  PRESETUP) node defined in truffle-config.js up-and-running
  $ truffle console
  truffle(dev)> compile --all             <- Optional. Recompile all if needed.

  truffle(dev)> migrate                   <- In case of error, check also node logs for related info
  > ...                                      (TX hash can help to match errors in truffle console with
  > migration: 1_initial_migration.js        node logs)
  > ...
  > migration: 2_deploy_contracts.js
  > ...
  truffle(dev)> Fibonacci.deployed()
       .then(instance =>                  <- instance is a JS "proxy" to a deployed contract.
          instance.generateFib(10))       <- automatically generates signed TX + JSON/RPC remote call
  > { tx: '0xf47f...41c',
  >   receipt:
  >    { transactionHash: '0x1234....',   <- Use it to identify MINED transaction.
  >      blockHash: ...,
  >      logs: [...],
  >      status: '0x01',
  >      gasUsed: 298373,
  >      ...
  >    },
  >   logs: [...]                         <- logs == "emitted events"
  > }

  truffle(dev)> debug   0x1234...         <- 0x1234... == receipt.transactionHash
  > Gathering transaction data...
  > Addresses affected:
  >  0x33b217190... - Fibonacci
  > ...
  > Fibonacci.sol:                     ┌─ Debugger Commands───────────────────────────────────┐
  > ...                                │ v) print vars:val  b)TOGGLE      BREAKPOINT          │
  > 3: contract Fibonacci              │ n) step next       c)CONTINUE to BREAKPOINT          │
  >    ^^^^^^^^^^^^^^^^^^              │ o) step over       +:˂expr˃) ADD  WATCH EXPRESSION   │
  debug(dev:0xf4...)> n                │ i) step into       -:˂expr˃) DEL  WATCH EXPRESSION   │
  > 8:   function generateFib ...      │ u) step out        :˂expr˃ ) EVAL       EXPRESSION   │
  >      ^^^^^^^^^^^^^^^^^^^^^^^^^^    │                    ?       ) LIST WATCH EXPRESSION/S │
  >                                    │                                                      │
  (Move until reaching the for-loop)   │ ;)step  instruct.                          h) help   │
  debug(dev:0xf4...)>  v               │ p)print instruct.                          q) quit   │
  >         i: 0                       └──────────────────────────────────────────────────────┘
  >         n: 10
  > fibseries: []
  debug(dev:0xf4...)>  +:{ i, fibseries } <- new watch expression shown after instruction
  debug(dev:0xf4...)> n
  > ...
  > ...
  > fibseries: [1, 1, 2, 3, ..., 55]

• TRUFFLE RECIPES:
  $ truffle compile --all     <- force recompile all of the contracts.
  $ migrate --reset           <- Reset existing migrations/migration state.


• Truffle Migrations Explained: [[{devops.smart_contract.migration]]
  (Summary from Bernard Peh post: https://medium.com/@blockchain101/demystifying-truffle-migrate-21afbcdf3264)

  - Migrations.sol instance is used to "bookmark" LAST SUCCESFUL MIGRATION:
    ...
    contract Migrations {                     ┌·· On truffle console value can be check like:
      uint public last_completed_migration; <·┘   | Migrations.deployed().then( sc =>
      ...                                         |   sc.last_completed_migration.call()
                                                  |   .then(v => console.log(v) ) )
      function setCompleted(uint completed) <···· Invoqued whenever a migration/*.js script
      public {                                    is completed successfully.
        last_completed_migration = completed;
      }
      ... (upgrade ) ...
    }

  1ST MIGRATION EXECUTION                            2ND UPGRADED METACOIN MIGRATION
  migration SETUP:                                   migration SETUP:
  └./migrations/1_initial_migration.js               └./migrations/1_initial_migration.js
  └./migrations/2_deploy_contracts.js                └./migrations/2_deploy_contracts.js
                └───────┬────────┘                   └./migrations/3_deploy_upgraded_metacoin.js
                ┌───────┘                                          └───────────┬───────────────┘
                │                                        ┌─────────────────────┘
                ...                                      ...
                deployer.deploy(ConvertLib);             // deployer.deploy(ConvertLib); ← Commented (Save gas)
                deployer.link(ConvertLib, MetaCoin);     deployer.link(ConvertLib, MetaCoin);
                deployer.deploy(MetaCoin);               deployer.deploy(MetaCoin);


  (or --reset flag added)
  $ truffle migrate                               $ truffle migrate
  > Compiling ...                                 > ...
  > ...                                           > last_completed_migration == 2 → start at migrations/3_*.js
  > Running migration:  1_initial_migration.js    > (☞Migration and ConvertLib skipped)
  >   Deploying Migrations...                     > Running migration:  3_deploy_upgraded_metacoin.js
  >   ... 0x68fe0...   (deploy TXhash)            > Replacing MetaCoin...
  >   Migrations: 0x213....(Contract address)     > ... 0xe9d0481...      (deploy TX hash )
  > Saving successful migration to network...     > MetaCoin: 0xf55...    (Contract address)
  >   ... 0xe2807...   (setCompleted() TXhash)    > Saving successful migration to network...
  > Saving artifacts...                           > ... 0xcf8f9...         (setCompleted TX hash)
  > Running migration:  2_deploy_contracts.js     > Saving artifacts...
  >   Deploying ConvertLib...
  >   ... 0xce792...       (deploy TXhash )
  >   ConvertLib: 0x13e... (Contract address)
  >   Linking ConvertLib to MetaCoin
  >   Deploying MetaCoin...
  >   ... 0x2fcab...       (deploy TXhash )
  >   MetaCoin: 0x0d9...   (Contract address)
  > Saving successful migration to network...
  >   ... 0xe2807...       (setCompleted() TXhash)
  > Saving artifacts...
[[}]]


• Truffle Framework: Security: [[{security,20_QA,00_PM.TODO.NOW]]
@[https://github.com/ConsenSys/truffle-security]
  - MythX Security Analysis Plugin for Truffle Framework
  - adds automated smart contract security analysis to the
    Truffle framework.
  - Compatible with Truffle 4.0 or higher.
[[}]]

• Truffle Framework: IPFS/Filecoin: [[{scalability.offchain,infrastructure.storage.offchain,00_PM.TODO]]
@[https://www.trufflesuite.com/blog/announcing-collaboration-with-filecoin]
[[}]]


• Truffle Framework: migrating to web3 v1.0 [[{00_PM.TODO}]]
@[https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4]
 "... Unfortunately Truffle uses the 0.20.x version of Web3.js
      instead of vs v1.0+, providing a more easier to work with API (e.g.:
       PromiEvents
[[dev_framework.js.truffle}]]


● Web3J JAVA SDK: [[{dev_framework.java.web3j,10_EVM.events]]
  - https://docs.web3j.io/
  - https://docs.web3j.io/getting_started.html
  - https://github.com/web3j/sample-project-gradle/blob
      /master/src/main/java/org/web3j/sample/Application.java
  - https://docs.web3j.io/infura.html Using infura

- Web3J recipes:
  - SYNC vs Future vs RXJAVA(recomended)
    └ SYNC. REQUESTS
      Web3ClientVersion web3ClientVersion = web3.web3ClientVersion()
          .send().getWeb3ClientVersion();

    └ CompletableFuture (Future ON ANDROID): [[{architecture.async]]
      Web3ClientVersion web3ClientVersion =
         web3.web3ClientVersion()
         .sendAsync().get/*block thread*/();

    └ RXJAVA OBSERVABLE:
      web3.web3ClientVersion()
          .observable().subscribe(x -> {
          String clientVersion =
              x.getWeb3ClientVersion();
      });                                    [[}]]


  - Transact (write/change state) vs Call (Read-only) with S.C. Wrapper:
    └ TRANSACT WITH A SMART CONTRACT WRAPPER: (changes status in blockchain, needs mining)
    · TransactionReceipt transactionReceipt = contract.someMethod("param1", ...).send /*block*/();
    ·
    └ CALL A SMART CONTRACT WRAPPER: (local query to "view" or "pure" solidity code, no mining needed)
      Type result = contract.someMethod(param1, ...).send();

• 'web3j' Wrapper command line client around web3j library:
  $ web3j version|wallet|solidity ... [[{00_PM.TODO}]]

• Web3J (event) FILTERS: REF: https://docs.web3j.io/filters.html
  - Provide notifications of Ethereum-events
  - Based on RXJava
  - NOTE: Standard Ethereum filter-classes:
          - Block filters
            - provide only block-hash.
              a second request(block-hash) needed to fetch the actual block
          - Pending TX filters
            - provide only TX-hash.
              a second request(TX-hash) needed to fetch the actual TX
          - Topic filters  (aka SmartContract event-logs):
            - WebSockets
            - JSON-RPC poll

  - web3j's managed Filter implementation:
    - Provides a fully asynchronous event based API
      for working with filters.
    - Based on RxJava's Flowables which provides a consistent API
      for working with events, which facilitates the chaining
      together of JSON-RPC calls via functional composition.
      Subscription subscription =
        //  start listening for new events
        web3j .blockFlowable (false)        .subscribe(block -> { ... }); ← Listening for new blocks
        web3j .transactionFlowable()        .subscribe(   tx -> { ... }); ← Listening for new mined TXs
        web3j .pendingTransactionFlowable() .subscribe(   tx -> { ... }); ← Listening for new pending-to-mine TXs
                                                                           (TXs added to local-node queue)
        web3j .replayBlocksFlowable(blck0, blck1, <fullTxObjects>) .subscribe(block -> { ...  });
        //  Replay history (block/TX) filters  (in a range blck0 to blck1 of blocks):
        web3j .replayBlocksFlowable      (blck0, blck1, <fullTxObjects>) .subscribe(block -> { ... });
        web3j .replayTransactionsFlowable(blck0, blck1                 ) .subscribe(tx -> { ... });
        //  Replay history (block/TX) filters and provide notification (via the submitted Flowable) once you’ve caught up
        web3j .replayPastBlocksFlowable  (blck0,        <fullTxObjects>, <onCompleteFlowable>) .subscribe(blck -> { ... });
                                                                        ^^^^^^^^^^^^^^^^^^^^                    ^^^^^^^
                                                                        listen here for                        listen here for
                                                                        future events                          past events
        //  Replay history (block/TX) filters and continue listening for new events
        web3j .replayPastAndFutureBlocksFlowable( block0, <fullTxObjects>). subscribe(block -> { ... });
            (.replayPastAndFutureTransactionsFlowable)                                        ^^^^^^^
                                                                                         listen here for
                                                                                         past and future events

        NOTE:simpler alternatives exits providing onley block/tx hashes
     ...
     subscription .unsubscribe() ; ← end subscription

• Web3J TOPIC FILTERS:
 EVM (Smart-Contract) events stored in the TX log of the blockchain.
 - Since code changing the blockchain status (write TXs) are executed
   "at will" (maybe one second later, maybe one hour later) EVM code
   notifies of any return value from calls to smart-contracts functions
   using those events.
   - Note that a solidity function can return a value, but this value
     is just useful to other calling function executed during the TX,
     not to the external web3 client that send the original signed TX
     maybe long time ago. This client only have to oportunity to know
     the TX status by listening for EVM topic log event (filters in web3j)

  STEP 1:
    EthFilter filter = new EthFilter( block0 , block1 , <optional-contract-address>)
                       [ .addSingleTopic (...) | .addOptionalTopics (..., ...) | ...];
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                     - specify topics of interest and initial/end block.
                     - individual topics represent indexed parameters on the smart contract
                     - If no topics are added, all EVM events taking place in the network
                       will be captured.
  STEP 2:
      Subscription subscription =
        web3j .ethLogFlowable(filter) .subscribe(log -> { ... });

Java Implementation Note:
- blockFlowable itself is composed of two of separate JSON-RPC calls:

public Flowable<EthBlock> blockFlowable(
      boolean fullTransactionObjects, long pollingInterval) {
  // STEP 1: Create flow of block-hash events
  return this.ethBlockHashFlowable(pollingInterval)
    .flatMap(blockHash ->
      // STEP 2: Map each returned blockHash by using JSON-RPC to query for new block
      web3j.ethGetBlockByHash(blockHash, fullTransactionObjects).flowable()
    );
}


REF:
Integration-Tests
@[https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/core/FlowableIT.java]
Manual filter API:
@[https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/EventFilterIT.java]

- Web3J: fetch receipt logs:
@[https://www.programcreek.com/java-api-examples/?class=org.web3j.protocol.core.methods.response.TransactionReceipt&method=getLogs]
private void sendTransferTokensTransaction(...)  {
    Function function = transfer(to, qty);
    String functionHash = execute(credentials, function, contractAddress);
    TransactionReceipt transferTransactionReceipt = waitForTransactionReceipt(functionHash);
    assertThat(transferTransactionReceipt.getTransactionHash(), is(functionHash));
    List<Log> logs = transferTransactionReceipt.getLogs();
    assertFalse(logs.isEmpty());
    Log log = logs.get(0);

    List<String> topics = log.getTopics(); // verify event called with expected function params
    assertThat(topics.size(), is(3));

    Event transferEvent = transferEvent();

    // check function signature - we only have a single topic our event signature,
    // there are no indexed parameters in this example
    String encodedEventSignature = EventEncoder.encode(transferEvent);
    assertThat(topics.get(0), is(encodedEventSignature));
    assertThat(new Address(topics.get(1)), is(new Address(credentials.getAddress())));
    assertThat(new Address(topics.get(2)), is(new Address(to)));

    // verify qty transferred
    List<Type> results = FunctionReturnDecoder.decode(
            log.getData(), transferEvent.getNonIndexedParameters());
    assertThat(results, equalTo(Collections.singletonList(new Uint256(qty))));
}


See Also:
<span xxsmall>SpringBoot ERC-20 RESTfull ex:</span>
@[https://github.com/blk-io/erc20-rest-service/blob/master/src/main/java/io/blk/erc20/Controller.java]
[[}]]



● Web3 GO [[{dev_framework.go,10_EVM.events,00_PM.WiP]]
<span title>Web3 GOLang</span>
  ===================================================
• ethclient package. Connecting to node (ws/http/ipc)
  ===================================================
@[https://medium.com/coinmonks/web3-go-part-1-31c68c68e20e]

  cl, err := ethclient.Dial(“/tmp/geth.ipc”)          // Ex.1:  Use local node
                                                      // (or http://$IP:$PORT for remote node)
                                                      // cl wraps a raw rpc.Client

  infura := “wss://goerli.infura.io/ws/v3/xxxxxx”     // Ex.2: Use infura
  cl, err := ethclient.Dial(infura)
  //
  ctx := context.Background()               ← Retrieve a block by number
  block, err := cl.BlockByNumber(
                   ctx, big.NewInt(123))
  //
  addr := common.HexToAddress("0xb02A2...") ← Get Balance of an account (nil means at newest block)
  balance, err := cl.BalanceAt(ctx, addr, nil)
  //
  tx := new(types.Transaction)
  err = cl.SendTransaction(ctx, tx)         ← Send transaction: It will fail. tx is unsigned&empty
  //
  progress, err := cl.SyncProgress(ctx)     ← Get sync progress for node

• accounts package:
  Ex. Create raw transaction.
  nonce, err := cl.NonceAt(ctx, addr, nil)   ← Retrieve the pending nonce for an account
  to  := common.HexToAddress("0xABCD")
  amount := big.NewInt(10 * params.GWei)
  gasLimit := uint64(21000)
  gasPrice := big.NewInt(10 * params.GWei)
  data := []byte{}
  tx := types.NewTransaction(nonce,          ← Create new raw unsigned transaction
     to, amount, gasLimit, gasPrice, data)

                                               Sign TX with in-memory priv.key
                                               ===============================
  PK := "0x..."                              ← (p)rivate (K)ey as hex.formated string
  pk := crypto.ToECDSAUnsafe(                ← convert hex.string to ECDSA private key
            common.FromHex(PK))
  signedTx, err := types.SignTx(tx,          ← Sign tx (Discourages, better use the
          types.NewEIP155Signer(nil), pk)      TransactOpts object).
  addr := crypto.PubkeyToAddress(            ← ex. Obtain public key from private key.
          pk.PublicKey)
  opts := bind.NewKeyedTransactor(pk)        ← ex. create TransactOpts object from
                                               in-memory priv.key

                                               Sign TX with offchain wallet/keystore
                                               ===============================
  ks := keystore.NewKeyStore(".../keystore", ← Open Keystore
        keystore.StandardScryptN,
        keystore.StandardScryptP)
  acc, err := ks.NewAccount("password")      ← Create an account in key Store
  accs := ks.Accounts()                      ← List all accounts in Key Store
  ks.Unlock(accs[0], "password")             ← Unlock account[0]
  ksOpts, err := bind.NewKeyStoreTransactor  ← Create TransactOpts object.
                 (ks, accs[0])
  sigTx, err := ksOpts.Signer(               ← Use it to sign TXs.
    types.NewEIP155Signer(nil),                TransactOpts Also needed to interact
    senderAddr, tx)                             with S.C. using auto-generated bindings.


  =======================================================
• bind/abigen packages. Interacting with Smart Contracts:
  =======================================================
@[https://medium.com/coinmonks/web3-go-part-2-aebdcb8d926e]
  It avoid to interact manually with ABI.
  • abigen, (included in full installation of geth)
    $ abigen --pkg coolcontract \
      --sol CoolContract.sol  \               ← Input solidity contract.
     --out ./coolcontract/CoolContract.go     ← autogenerates (lot of useful) methods to deploy
                                                and interact with the contract.

• For any interaction we need an Object implementing <<ContractBackend>>.
   backend, err := ethclient.Dial("/tmp/geth.ipc") ← returns ethclient.Client implementing
                                                     <<ContractBackend>>
   addr := common.HexToAddress("0x0..")            ← deployed S.C. address as hex.string
   ctr, err := contract.NewContract(addr, backend) ← Bind to already deployed contract
                                                     (contract: generated by abigen)
                                                     To deploy new contract instead:
                                                     addr, tx, ctr, err :=
                                                         coolcontract.DeployCoolContract(
                                                             transactOpts, backend)
                                                     _, err = bind.WaitDeployed(ctx, backend, tx)

   callOpts := &bind.CallOpts{
                  Context: ctx, Pending: false
               }
   bal, err := ctr.SeeBalance(callOpts)           ← Call pure/view (read-only) function.
                                                    no mining needed.
   tx, err := ctr.Deposit(transactOpts)           ← Execute transaction (mining needed)
   receipt, err := bind.WaitMined(ctx, backend, tx)
   if receipt.Status != types.ReceiptStatusSuccessful {
     panic("Call failed")
   }

  ================
• Event listening:
  ================
@[https://medium.com/coinmonks/intro-to-web3-go-part-3-d4f08a32c0ae]
  └ filtering for (OLD!!!) events: (abigen autogenerated Filter<EventName> )
      create bind.FilterOpts with start/end block arguments.
      WARN: only works on full (archive) nodes.
      WARN: It does not work on Infura.
     filOpt := &bind.FilterOpts{              ← Indicate start/end block
                 Context: ctx,
                 Start: 9000000,              ← Tune start/end to avoid DoS on node.
                 End: nil
               }
     itr, err := ctr.FilterDeposited(filOpt)  ← Filter"EventName" Autogenerated by 'abigen'
     for itr.Next() {
         event := itr.Event
         fmt.Printf(event.Addr.Hex())
     }
  └ listening for (FUTURE!!!) events:
    watchOpts := &bind.WatchOpts{
                    Context: ctx,
                    Start: nil
                 }
    channel := make(chan               ← STEP 1) Setup (async) channel for (FUTURE) results
       *coolcontract.CoolContractDeposited)
    go func() {                        ← STEP 2) Start goroutine listening for events
       sub, err := ctr.WatchDeposited( ← Watch"EventName" autogenerated by 'abigen'
          watchOpts, channel)
        defer sub.Unsubscribe()
    }()
    event := <-channel                 ← Receive events from channel

   TIP: to retrieve both historical and future events,
        create subscription goroutine BEFORE filtering old states.
        Wait for a bit so you’re certain it gets scheduled.
        WARN: otherwise you might loose events.

   └ parsing events from types.Log  (useful in some scenarios): (TODO)
     log := *new(types.Log)
     event, err := ctr.ParseDeposited(log)

  ========================================
• TESTING (using go-ethereum as a library)
  ========================================
@[https://medium.com/coinmonks/intro-to-web3-go-part-4-5a21bc71fddc]
  low-code simulated blockchain for unit tests embedded in go-etherum.

  (accounts/abi/bind/backends/)backends.SimulatedBackend implement
  <<ContractBackend>> (replacing ethclient.Client node connection).

  backend := backends.NewSimulatedBackend(
             core.DefaultGenesisBlock().Alloc,
             9000000)
  bal, err := backend.BalanceAt(
              ctx, common.HexToAddress("0x.."), nil)

  faucetSK, err := crypto.GenerateKey()
  faucetAddr := crypto.PubkeyToAddress(faucetSK.PublicKey)
  addr := map[common.Address]core
       .GenesisAccount{
          common.BytesToAddress([]byte{1}):
            {Balance: big.NewInt(1)}, // ECRecover   precompiles
          common.BytesToAddress([]byte{2}):
            {Balance: big.NewInt(1)}, // SHA256      precompiles
          common.BytesToAddress([]byte{3}):
            {Balance: big.NewInt(1)}, // RIPEMD      precompiles
          common.BytesToAddress([]byte{4}):
            {Balance: big.NewInt(1)}, // Identity    precompiles
          common.BytesToAddress([]byte{5}):
            {Balance: big.NewInt(1)}, // ModExp      precompiles
          common.BytesToAddress([]byte{6}):
            {Balance: big.NewInt(1)}, // ECAdd       precompiles
          common.BytesToAddress([]byte{7}):
            {Balance: big.NewInt(1)}, // ECScalarMul precompiles
          common.BytesToAddress([]byte{8}):
            {Balance: big.NewInt(1)}, // ECPairing   precompiles
          faucetAddr:
            {Balance: new(big.Int)
                      .Sub(new(big.Int)
                      .Lsh(big.NewInt(1), 256) ,
                      big.NewInt(9))
            },
       }
  alloc := core.GenesisAlloc(addr)
  backend := backends.NewSimulatedBackend(
          alloc, 9000000 /* gas limit*/)

  observations: All precompiles need to own some ether to remove
                purging-account differences among nodes.

  BalanceAt/BlockByNumber/deploy+interact with contracts work as
  ussual with ethclient.Client.

• Overwrite SendTransaction to behave like ethclient.SendTransaction:
  simulated blockchain allows for interesting scenarios:
  - By skipping Commit() after every transaction, TX-per-block
    can be tunned.
  - Rollback() can abort all pending (not commited) transaction
    (simulate TXs dropped from TX pool).
[[}]]

● C# [[{dev_framework.C#]]
<span xsmall>Nethereum</span>
@[https://nethereum.readthedocs.io/en/latest/]
PRE-SETUP
$  dotnet add package Nethereum.Web3

 Sending Ethers
using System;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Hex.HexTypes;
using Nethereum.HdWallet;

bool useSoftWallet = true // ← false => Use HW Wallet
if (useSoftWallet) {
  // Alt 1: Use  private key/Software wallet  to init web3 instance.
  var account = new Account(
      "0x... 32 bytes- private key in Hex format ");

  var web3 = new Web3(account);
} else {
  // Alt 2: Use  HW Wallet  to init web3 instance
  string Words = "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal";
                  string Password = "password";
  var wallet = new Wallet(Words, Password);
  var account = wallet.GetAccount(0);
  var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";
  var web3 = new Web3(account);
}
var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";

var TXManager = web3.Eth.GetEtherTransferService();
var TX = await TXManager
    .TransferEtherAndWaitForReceiptAsync(
       toAddress, Web3.Convert.ToWei(1));
 // alt: Specify gas amount
 // .TransferEtherAndWaitForReceiptAsync(
 //    toAddress, Web3.Convert.ToWei(1), 2);


• C# Handling Events:
@[https://nethereum.readthedocs.io/en/latest/nethereum-events-gettingstarted/]
- Events ("emit" in solidity code) write data to the transaction receipt logs.

...
var  transactionReceipt = await transferHandler.SendRequestAndWaitForReceiptAsync(contractAddress, transfer);
var transferEventOutput = transactionReceipt.DecodeAllEvents<TransferEventDTO>();

Contract Filters and Event Logs

- get all changes of the logs (providing a filter message)
- or create filters and retrieve changes which apply to our filter message periodically.

TO ACCESS THE LOGS:
 - CREATE A TRANSFER EVENT HANDLER FOR OUR CONTRACT ADDRESS
 - CREATE AN EVENT DEFINITION.(TransferEventDTO).

var   transferEventHandle   = web3.Eth.GetEvent<TransferEventDTO>(contractAddress /* null to retreive all signature-matching-events from any contract */ );
    ^^^^^^^^^^^^^^^^^^^^
var emptyFilter01 =   transferEventHandle  .CreateFilterInput(); // By default from block cero to current block

var allTransferEventsForContract = await   transferEventHandle  .GetAllChanges(emptyFilter01);

var   fromToIndexFilterInput01  =   transferEventHandle  .CreateFilterInput<string, string>(account.Address, receiverAddress2);
var       toIndexFilterInput01  =   transferEventHandle  .CreateFilterInput<string, string>(null, receiverAddress2);
var   toManyIndexFilterInput01  =   transferEventHandle  .CreateFilterInput(null, new []{receiverAddress2, receiverAddress});
var allEventsFromTo  = await   transferEventHandle  .GetAllChanges(  fromToIndexFilterInput01 );
var allEventsTo      = await   transferEventHandle  .GetAllChanges(      toIndexFilterInput01 );
var allEventsToMany  = await   transferEventHandle  .GetAllChanges(  toManyIndexFilterInput01 );

var   fromToIndextFilterID  = await   transferEventHandle  .CreateFilterAsync(fromToIndexFilterInput01);
var allNewEventsFromTo   = await   transferEventHandle  .GetFilterChanges(  fromToIndextFilterID );
</pre>

[[{}]]"dev_framework.C#,devops.C#">
<span xsmall>Nuget packages</span>
@[https://nethereum.readthedocs.io/en/latest/nugets/]
- Standalone packages targeting Netstandard 1.1, net451, Netstandard 2.0, Netcoreapp 2.1
  and where possible net351 to support Unity3d.
 (Nethereum.Portable deprecated)
Windows:                                Windows/Mac/Linux users
PM > Install-Package Nethereum.Web3     dotnet add package Nethereum.Web3
 Main Libraries
Project Source                    Description
Nethereum.Web3                    Web3-RPC, contract inter./deployment/TX, en/de-coding, event filters
Nethereum.Unity
Nethereum.Geth                    Geth support for Admin, Debug, Miner
Nethereum.Quorum
Nethereum.Parity                  Parity  non-generic RPC API support
 Core Libraries

Project Source                  Description
Nethereum.ABI                   Encoding/decoding of ABI Types, functions, events of Ethereum contracts
Nethereum.EVM                   Ethereum Virtual Machine API
Nethereum.Hex                   HexTypes for encoding and decoding String|BigInteger...
Nethereum.RPC
Nethereum.JsonRpc.Client
Nethereum.JsonRpc.RpcClient
Nethereum JsonRpc IpcClient
Nethereum.RLP                   RLP encoding and decoding
Nethereum.KeyStore              Keystore generation|en/de-cryption (Web3 Secret Storage definition)
Nethereum.Signer                Nethereum signer library to sign and verify messages,
                                RLP and transactions using an Ethereum account private key
Nethereum.Contracts             Core library to interact via RPC with Smart contracts
Nethereum.IntegrationTesting    Integration testing module
Nethereum.HDWallet              Generates an HD tree of Ethereum compatible addresses from
                                a randomly generated seed phrase (using BIP32 and BIP39)

 Smart contract API Libraries
Project Source                  Description
Nethereum.StandardTokenEIP20    Nethereum.StandardTokenEIP20 Service
Nethereum.Uport                 Uport registry library
Nethereum.ENS                   Ethereum Name service library
 Utilities
Nethereum.Generator.Console     collection of cli utilities to interact with Ethereum/account management
 Training modules
Project                         Description
Nethereum.Workbooks             Xamarin Workbook tutorials including executable code
Nethereum.Tutorials             Tutorials to run on VS Studio
 Code templates
Source                          Description
Keystore generator              Keystore file generator
Faucet                          Web application template for an Ether faucet
Nethereum Flappy                The source code files for the Unity3d game integrating with Ethereum
Nethereum Game Sample           Sample game demonstrating how to integrate Nethereum with UrhoSharp's
                                SamplyGame to build a cross-platform game interacting with Ethereum
Nethereum UI wallet sample      Cross platform wallet example using Nethereum, Xamarin.Forms and MvvmCross,
                                targeting: Android, iOS, Windows Mobile, Desktop (windows 10 uwp), IoT
                                with the Raspberry PI and Xbox.
[[}]]

● web3.py [[{dev_framework.python.web3_py,00_PM.TODO]]
@[https://github.com/ethereum/web3.py]
[[}]]

● Brownie [[{dev_framework.python.brownie,13_SLC.testing,20_QA,00_PM.TODO]]
  @[https://eth-brownie.readthedocs.io/en/latest/]
  @[https://eth-brownie.readthedocs.io/en/stable/tests-hypothesis-property.html]
  @[https://github.com/HyperLink-Technology/brownie]
- simple python framework for testing, deploying and interacting with SCs.

- PROPERTY-BASED TESTING — Brownie v1.6.5 documentation [[{00_PM.TODO.now}]]

- See Also:
  - Effective Smart Contract Testing with Brownie:
@[https://medium.com/coinmonks/effective-smart-contract-testing-developer-revert-comments-c7a6f250df0f]
[[}]]


● SCALABILITY SOLUTIONS: [[{101,scalability.zkp,privacy.zkp,scalability.layer2]] #[layer2_scalability_summary]
                         [[dev_framework.remix,01_doc_has.diagram,layer2.rollup.optimistic]]
                         [[,layer2.rollup.zk,00_PM.WiP]]

• Layer 1 Scalability Solutions include:
  · DDBB (storage) Sharding.
  · Multi-signature aggregation.
    (e.g.: EIP-191: Signed Data  Standard,...)
  · EVM improvements.
  · eWASM runtime.

• State channels:
  · Account-to-Account offchain state channel periodically
    synchronized within MainNet. Ussually the state reflects
    the balance of two peer accounts, but it could be
    anything else. It highly increases the TX/sec by offloading
    as much TX as desired from main network, but requires
    collaboration and monitoring by both peers.

• Layer 2 Side chain Scaling:
  · Similar to L2 Rollups with with lower security.
    They "sync" to L1 through peer "escrow" contracts on each
    network (L1 and L2) in charge of syncrhonizing escrows.
    They can use more centralized consensus (consortium IBFTv2,
    ...).
    Rollups require L2 each block update to be "notarized" (optimistic
    rollups) or probed (zk-rollups). Side-chains can "sync" at
    will every N blocks.
    "sidechain" term is often used to imply that an INDEPENDENT
    blockchain has a relationship with another blockchain.
  · bridge contracts types can be divided into:
    · Single organisational: 1        owner  custody locked funds in escrow.
    · Multi organisational : N-of-M   owners custody locked funds in escrow.
    · Crypto-economic      : "moving" owners custody locked funds in escrow
                             relative to the weight of their assets.

• Layer 2 Rollups Scaling:
  · "Children" networks protected by MainNet.
  · Many different methods exist to sync with MainNet,
  • As of 2021, optimistic rollups (bundling L2-chain blocks) is the working solution.
    In a near future zk-Rollups will "replace" them:
    • optimistic-Rollups provide passive security while zk-Rollups
      provide active security.
    • optimistic-Rollups need to submit a "zipped" version of data
      to L1 blockchain while zk-Roolups have to potential to send only a
      proof of the full block allowing for theorical performance upgrades of
      tens of thousands TX/s.
    • zSNARKS provides also for enhanced privacy. (but scalability features
      are even more important).
    • optimistic-Roolups are more compatible with Layer 1 "MainChain".
      zk-SNARKs L2 chains require new signatures schemas not compatible with
      L1, requiring also changes in wallets (Metamask,...) to avoid the need
      of intermediate "custom" DApp wallets.

      Scalability L2 Comparation:
      REF: @[https://www.youtube.com/watch?v=qwtOJvFo6vs]
                          ┌─────────┐
                          │ Honesty │← Active Security.
                          │  Proofs │  No false transitions can be submitted.
                          └────┬────┘
                               ├ ZKP (zk-Rollups: Validium, 0x, ...)
                               │
                               ├ Sign.Aggregation
                               │
                               │
                               │      Merkle
    ┌────────┐ Compression     │      Trees      ZKP ┌─────────┐
    │  Data  │──────┴─────┬────┼───┬──────┴────┬──┴──│  Data   │
    │On Chain│           Gas   │Acummulators   VC    │Off-Chain│
    └────────┘         golfing │                     └─────────┘
                               ├  Rollback
                               ├  Slashing
                               │
                               ├  Optimistic Rollups/Watch-Towers: monitoring TXs.
                               │  W.T can fail but they can compete with each other
                               │  e.x.: Plasma, Optimistic, ...
                               │
                           ┌───┴────┐
                           │ Fraud  │← Passive Security. Fix problem after detection.
                           │ Proofs │  All TX are accepted as valid and Watch-Towers
                           └────────┘  need to probe the opposite.


    • Accumulators can only test "SET membership".
    • Merkle trees improve over accumulators by having an "index" that can be mapped to a balance.
    • Factors commitments mix the advantages of accumulators and Merklet trees.
    • ZKP improves all over the previous techniques (Accumulators/Merkle Trees, ...)
[[}]]

● Serenity/Eth v2.0 nomenclature [[{scalability.101,consensus.ethereum2]]
- REF: @[https://medium.com/alethio/ethereum-2-0-terms-demystified-8398357429d7] 2019-08-13

 BEACON CHAIN                       │ SHARDS
 - one chain to rule them all       │ - 1024 of them
 - proof-of-stake chain             │ - semi independent chains
 - includes beacon blocks           │ - include shard blocks
 - consensus layer for "everything" │ - periodically the state of the shard blocks
 - manages validators               │   is recorded on the beacon chain through
 - applies rewards and penalties    │   crosslinks
 - serves as an anchor point for the│ - once a block on the beacon chain is finalised,
  shards through cross-links        │   the shard blocks referenced in the included
                                    │   crosslinks are considered finalised
                                    │ - each shard has a committee of validators
                                    │   attesting blocks
                                      ^
                           @[https://blog.ethereum.org/2020/03/27/sharding-consensus/]
 CROSSLINKS                    │ SLOT                            │ EPOCH
 - summary of the shard's state│ period of time in which a block │ a number of slots(64 "now")
 - only reference of the shards│ proposer propose a block for    │ after which validators are
   in the beacon chain         │  attestation                    │ reshuffled in committees
                               │ - slots might be empty          │
                               │ - slots are filled with attested│
                               │   blocks                        │

 VALIDATORS                                    │ BLOCK PROPOSERS
 - users that have deposited 32th in the       │ - random validators chosen by the beacon
   validator deposit contract and run a        │   chain to propose blocks for
   validator node                              │   validation/attestation
 - they can be inactive (don’t run as an       │ - there will be one block proposer per slot
   actual validator yet), active (validating), │   for the beacon chain and one proposer
   pending (opted into becoming a validator    │   per slot for each of the shards
   but stuck in the entry queue) and exiting
   (no longer want to validate and stuck in
   the exit queue)

 ATTESTATIONS               │ COMMITTEES                        │ ETH2 OR BETH
 - votes in regards to the  │ ─ random groups of validators     │ ─ base currency of beacon chain
   validity of a shard block│   chosen by the beacon chain to   │ ─ will be obtained initially
   or beacon                │   attest the validity of blocks   │   from rewards and by locking
                            │   (beacon+shard)                  │   ETH1 in the validator deposit
                            │ ─ target of minimum 128 validators│   contract
                            │   per committee                   │


- VALIDATOR DEPOSIT CONTRACT
  - smart contract on the POW chain
    (in our case, the Ethereum Mainnet)
  - once ETH1 funds are locked in this
    smart contract, and event log is emitted
    that should be read by the beacon chain
    and the same amount of ETH2 should be
    allocated to the account, now considered
    a validator
  - this mechanism might change in the future
  - until phase 2 ends the transfer of ETH1
    to ETH2 is a one way street, can’t get
    ETH1 back, but there is an escape hatch
    to sell your stake once transfers
    between validators become possible


● Scalability: Istambul Bizantine Fault Tolerant(IBFT)  [[{consensus.IBFT]]
@[https://github.com/ethereum/EIPs/issues/650]
- Target banks and fin.instutions, replacing PoW
  since validator scalability is not required.
- Hash settlement finality and minimum latency.
- Deeply inspired by Clique PoA @[https://github.com/ethereum/EIPs/issues/225]
- also inspired by Hyperledger's SBFT, Tendermint, HydraChain, and NCCU BFT.

 ROUND                                        ROUND STATE
Consensus round. A round starts with         Consensus messages of a specific
the proposer creating a block proposal       sequence and round, including
and ends with a block commitment or          pre-prepare message, prepare message,
round change.                                and commit message.

 PROPOSAL                                  SEQUENCE
New block generation proposal which is    Sequence number of a proposal. A
undergoing consensus processing           sequence number should be greater than
                                          all previous sequence numbers.
                                          Currently each proposed block height is
                                          its associated sequence number.

 BACKLO                                    CONSENSUS PROOF:
The storage to keep future consensus      The commitment signatures of a block
messages due to the async nature of the   that can prove the block has gone
network.                                  through the consensus process.

 SNAPSHOT:
The validator voting state from last
epoch

  VALIDATION ROUND LOOP
  [validators] → [validators]:  enter  validator.state NEW-ROUND
  [validators] → [validators]:  pick one (round-robin by default or sticky) as
                                the   PROPOSE
    PROPOSE    →  PROPOSE    :  propose new block proposal
    PROPOSE    →  network    :  broadast   block-proposal + PRE-PREPARE message
  [validators] → [validators]:  enter  validator.state PRE-PREPARED
  [validators] → network     :  broadcast   PREPARE message
                                (make sure all validators are working on the
                                 same sequence and the same round)
  [validators] → [validators]:  wait for (2F + 1) PREPARE messages
                                then enter  validator.state PREPARED
  [validators] → network     :  broadcasts   COMMIT message .
                                (inform peers that validator accepts proposed block
                                and is going to insert the block to the chain)
  [validators] → [validators]:  wait for (2F + 1) COMMIT messages
                                enter  validator.state COMMITTED
                                insert the block to the chain
                                enter  validator.state FINAL-COMMITTED
  [validators] → network     :  broadcasts   ROUND-CHANGE message
  [validators] → [validators]:  wait for (2F + 1) ROUND-CHANGE messages
                                then enter  validator.state NEW-ROUND


  RUNNING ISTANBUL BFT VALIDATORS&AMP;NODES:
  $ geth  --datadir "/eth" init "/eth/genesis.json"                   // ← Initialize the data folder as (PRE-SETUP)
  $ geth --datadir "/eth" --mine --minerthreads 1 --syncmode "full"   // ← Start-up validators
  $ geth --datadir "/eth"                                             // ← Start-up regular nodes

  ISTANBUL OPTIONS:
  --istanbul.requesttimeout value  round in milliseconds (default: 10000)
  --istanbul.blockperiod    value  Default min.difference between two consecutive
                                   block's timestamps in seconds (default: 1)

  NODEKEY AND VALIDATO
  To be a validator, a node needs to meet the following conditions:
  - Its account (nodekey-derived) address MUST be listed in extraData's validators section
  - validator nodekey is used as priv.key to sign consensus messages

  Encoding:
  Before encoding you need to define a toml file with vanity and validators fields
  to define proposer vanity and validator set. Please refer to example.toml for
  the example. The output would be a hex string which can be put into extraData
  field directly.  Command:
  $ istanbul encode --config ./config.toml

  Decoding:
  Use --extradata option to give the extraData hex string. The output would show
  the following if presents: vanity, validator set, seal, and committed seal.
  Command:
  $ istanbul decode --extradata <EXTRA_DATA_HEX_STRING>
  to define proposer vanity and validator set. Please refer to example.toml for
  the example. The output would be a hex string which can be put into extraData
  field directly.  Command:
  $ istanbul encode --config ./config.toml

  genesis.json
  - config field is required, and the pbft subfield must present. Ex:
  - See also genesis.json helper tools at:
  @[https://github.com/getamis/Istanbul-tools]
  {
    "config": {
      "chainId": 2016,
      "istanbul": { "epoch": 30000, "policy" 0 }
    },
    "timestamp": "0x0",
    "parentHash": "0x000...000",
    "extraData": "0x0000...000f89af85494475...aad0312b84100000...0c0",
    "gasLimit": "0x47e7c4",
    "mixhash": "0x6374...6e6365",
    "coinbase": "0x333...33333",
    "nonce": "0x0",
    "difficulity": "0x0",
    "alloc": {}
  }
[[}]]

● Casper PoS (Ethereum 2) [[{scalability.consensus.ethereum2,01_doc_has.comparative]]
PoS: Proof-of-Stake:
@[https://consensys.net/blog/blockchain-explained/what-is-ethereum-2/]
- Reducing mining hardware requirements and scalates TX/s.
- Consensus continues to have eventual transaction finality.
  (mined transactions can appear and dissapear and we need to wait
  for N blocks to have statistical confirmation).

-  PoW             PoS
   miners       →  validators
   electricity  →  stake

"MINING":
 validator → deposit SC : commit 32 ETH as "skin in the game"
             *1           into the official deposit contract
 ...
 network → network      : randomnly select new validator
                          to propose and attest to blocks
 validator → network    : correctly propose and attest to blocks
 network → validator    : reward

 *1  Ethereum Foundation Eth2 deposit contract:
     https://github.com/ethereum/eth2.0-specs/tree/dev/deposit_contract

- if a validator fails to stay online and execute their share of
  computational responsibilities, block reward will moderately decrease
  as to incentivize validators to stay online.

 - Byzantine validators trying to compromise the network
   (i.e. validate incorrect data history), will be punished
   with some/all of their 32 staked ETH.

 - In order for the beacon chain to launch its genesis block,
   at least 524,288 ETH must be staked on the network, divided
   among a minimum of 16,384 validators (these numbers were decided
   upon to ensure sufficient security and decentralization).
 - Staking rewards will not be distributed until this threshold
   is reached, which is partially why some altruistic behavior is
   needed among the early participants in phase 0.

   WARN: beacon chain will not be particularly useful to the majority
         of Ethereum users in  Phase 0 ;
         - it will be unable to process transactions, execute smart
           contracts, or host dapps.
           This is by design , ensuring Proof of Stake undergoes
           considerable testing as a live, functioning network before
           dapps and users begin transacting by the millions on a
           daily basis.

  Phase 0:
  - Original Ethereum 1.0 blockchain will continue to run
    in parallel and receive upgrades during Phase 0.

  Phase 1:
  - Implementation of shard chains.
  - Ethereum will be partitioned into 64 separate (shard) chains,
    coordinated by a beacon chain.

  Phase 1.5:
  - merging of the original PoW Ethereum with PoS chain.
    It will be brought into Ethereum 2.0 and exist as one
    of the 64 shard chains alongside the beacon chain
    with no break in continuity or data history.
    - ETH holders will not have to undergo any sort of
      token transfer or swap between Ethereum 1.0 and 2.0.

  Phase 2:
  - currently (2020-05) less defined.
    Enable ether accounts, transactions, transfers and withdrawals,
    and smart contract execution.
[[}]]

● Scalability L2 polygon.Network [[{scalability.layer2.polygon,layer2.rollup.optimistic,00_PM.TODO]] #[polygon_summary]
- Scanner: @[https://polygonscan.com/]
- Polygon solves pain points associated with Blockchains, like high gas
  fees and slow speeds, without sacrificing on security. This
  multi-chain system is akin to other ones such as Polkadot, Cosmos,
  Avalanche etc, but with at least three major upsides:

  + It is able to fully benefit from Ethereum’s network effects
  + It is inherently more secure
  + It is more open and powerful

- Polygon is both a protocol and a framework for building and connecting
  Ethereum-compatible blockchain networks, featuring:

  + One-click deployment of preset blockchain networks
  + Growing set of modules for developing custom networks
  + Interoperability protocol for exchanging arbitrary messages with Ethereum
    and other blockchain networks
  + Modular and optional "security as a service".
  + Adaptor modules for enabling interoperability for existing blockchain networks.

- See POLYGON (MATIC) - Ethereum's Internet Of Blockchains Explained - Layer 2 [Video]
@[https://www.youtube.com/watch?v=IijtdpAtOt0%20%20POLYGON%20(MATIC)%20-%20Ethereum%27s%20Internet%20Of%20Blockchains%20Explained%20-%20Layer%202]

- TODO: Looks like different Polygon networks can connect
        through side-chains or rollups.
  extracted from https://blog.infura.io/offchain-protocols-sidechains-and-rollups/
  "... Polygon side-chain uses a crypto-economic bridge ...
        (⅔)+1 of stake to appoint validators who post periodic
        checkpoints about network's state to bridge contract  ..."
[[}]]

● Scalability L2 Plasma.io [[{scalability.layer2,layer2.plasma,00_PM.TODO]]
@[https://plasma.io/]
Authors: Joseph Poon and Vitalik Buterin
- framework for incentivized and enforced execution of smart contracts which
  is scalable to a significant amount of state updates per second (potentially
  billions) enabling the blockchain to be able to represent a significant
  amount of decentralized financial applications worldwide. These smart
  contracts are incentivized to continue operation autonomously via network
  transaction fees, which is ultimately reliant upon the underlying blockchain
  (e.g. Ethereum) to enforce transactional state transitions.
_____________________________

https://plasma.io/plasma.pdf
The orchestrated transaction processing paradigm using the interplay between
rootchains, plasma chains, and child chains through a combination of fraud-
proof mechanism designs and fidelity bond incentive structures help satisfy
dynamics between the block-withholding and mass withdrawal surfaces. It also
allows for further cryptoeconomic structures to be filled using mechanisms
from systems like Casper or Truebit for mirroring concepts used in erasure
coding in terms of the data availability problem that is prevalent in the
space. For a multichain architecture, Ethereum would be able to combine the
database coordination and throughput capabilities of a distributed database
system with the public chain compatible capabilities of an actual blockchain.
_____________________________

https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
Through technical evaluations of tools like Plasma and formats of obtaining
consensus in Casper, it is apparent that database management tools like
MapReduce and Abstract Rewrite Systems will be implemented in Ethereum. In
Plasma, MapReduce is an integral part of assembling the coordination of an
account based system and a bitmap-UTXO commitment structure of a multichain
setup.
  ...
Plasma shares quite a bit of influence from a heavily cryptoeconomic
incentive structure focused platform called Truebit which was designed to
increase the offchain computational capabilities of the Ethereum network. By
architecting the Truebit system around a verification game in which Solvers
of the overall consensus mechanism can be challenged by Verifiers which
obtain a reward if they identify a nefarious counterparty, an internal
cryptoeconomic ?checks and balances? of the system is created to incentive a
dominant strategy of behaving fairly. As Plasma through the influence of
TrueBit is focused on creating a multichain interoperability network, the
internal enforcement of the system is paramount toward achieving information
and consensus fidelity.
_____________________________
• Plasma Chamber Framework: Dev framework guaranteing security/scalability/usability using Plasma.
@[https://github.com/cryptoeconomicslab/plasma-chamber]
   https://www.cryptoeconomicslab.com/

• Minimal Viable Plasma:
@[https://ethresear.ch/t/minimal-viable-plasma/426]

• Lead DAO: https://leapdao.org/: More Viable Plasma design with SC like functionality.
[[}]]


● EEA: Enterprise Integration Layout [[{standards.eea,01_doc_has.diagram,integration]]
REF: https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43
┌─ APPLICATIONS ────────────────────────────────────────────────────────────────────────────
│
│  DAPPS            ┌──────────────────┐  ┌─────────────────────────────┐
│                   │   Applications   │  │  Explorers, Monitoring & BI │
│                   └──────────────────┘  └─────────────────────────────┘
│
│  INFRA CONTRACTS  ┌────────┐  ┌────┐*4 ┌──────────┐    ┌────────┐  ┌────────────┐
│  & STANDARS       │IDENTITY│  │RBAC│   │NETWORK   │    │TOKEN   │  │ETHEREUM    │
│                   └────────┘  └────┘   │GOVERNANCE│    │STANDARS│  │NAME SERVICE│
│                                        └──────────┘    └────────┘  └────────────┘
┌─ TOOLING ───────────────────────────────────────────────────────────────────────────────────
│
│  Permisions &     ┌───────┐2  ┌──────────────┐2     ┌───┐3   ┌─────────────────────────────┐3
│  Credentials      │WALLETS│   │KEY MANAGEMENT│      │HSM│    │PERMISSIONING/AUTHENTICATION │
│                   └───────┘   └──────────────┘      └───┘    └─────────────────────────────┘
│
│  INTEGRATION&     ┌───────────┐2                    ┌──────────────────────────┐3 ┌────────┐3
│  DEPLOYMENT       │INTEGRATION│                     │ENTERPRISE MANAGEMENT SYS.│  │ORACLES │
│  TOOLS            │LIBRARIES  │                     └──────────────────────────┘  └────────┘
│                   └───────────┘
│
│                   ┌────────┐2   ┌───────────┐2
│  CLIENT           │JSON/RPC│    │INTER─CHAIN│
│  INTERFACES       └────────┘    └───────────┘

┌─ PRIVACY ──────────────────────────────────────────────────────────────────────────────────
│                  ┌────────┐2    ┌────────────────────┐3  ┌───────────────────┐3
│                  │ON-CHAIN│     │PRIVATE-TRANSACTIONS│   │OFF+CHAIN          │
│                  └────────┘     └────────────────────┘   │(TRUSTED EXECUTION)│
│                                                          └───────────────────┘
│
│NOTE: private (node─to─node) eea TX can NOT be used to prevent double─spending:
│      only for notarization like (ballots, ...) use─case scenarios were there will
│      probably be a "controller node" to wich all information arrives, (even if it's
│      just partially visible to other nodes):
│    @[https://stackoverflow.com/questions/56906115/private─transaction─validation─in─quorum]
│      To prevese privacy and double─spending, Zero Knowledge Proofs must be used.

┌─ SCALING ──────────────────────────────────────────────────────────────────────────────────
│                  ┌─────────────────┐2       ┌──────────────────┐2
│                  │ON+CHAIN(LAYER 2)│        │OFF+CHAIN(COMPUTE)│
│                  └─────────────────┘        └──────────────────┘

┌─ CORE BLOCKCHAIN ──────────────────────────────────────────────────────────────────────────
│  STORAGE/LEDGER  ┌────────────┐      ┌────────┐      ┌─────────┐2       ┌─────────────┐3
│                  │ON+CHAIN    │      │ON+CHAIN│      │OFF+CHAIN│        │ON+CHAIN     │
│                  │PUBLIC STATE│      │STORAGE │      │STORAGE  │        │PRIVATE STATE│
│                  └────────────┘      └────────┘      └─────────┘        └─────────────┘
│
│  EXECUTION       ┌───┐         ┌─────┐2     ┌───────────┐2      ┌──────────┐3
│                  │EVM│         │SYNC │      │PRECOMPILED│       │TRUSTED   │
│                  └───┘         └─────┘      │ CONTACTS  │       │ EXECUTION│
│                                             └───────────┘       └──────────┘
│
│  CONSENSUS       ┌─────────┐             ┌─────────┐3
│                  │PUBLIC   │             │PRIVATE  │
│                  │CONSENSUS│             │CONSENSUS│
│                  └─────────┘             └─────────┘
┌─ NETWORK ──────────────────────────────────────────────────────────────────────────────────
│   NETWORK         ┌──────┐2         ┌───────────────┐3
│   PROTOCOL        │DEVP2P│          │ENTERPRISE P2P │
│                   └──────┘          └───────────────┘

1: Yellow Paper
2: Public     Ethereum
3: Enterprise Ethereum
4: Solidity libraries like Zeppelin allows for RBAC
   fine-grained access into the on-chain smart-contracts
   Standard RBAC in EEA/Quorum expected for mid/late 2019
[[}]]

● Alethio,Rakr (IA auditing) [[{qa.auditing,13_SLC.monitoring,security,integration.data,02_use_case.finance.fraud]]
@[https://aleth.io]
@[https://media.consensys.net/alethio-lighting-up-the-blockchain-with-real-time-stats-a80bb30576db]
@[https://media.consensys.net/using-machine-learning-to-understand-the-ethereum-blockchain-1778485d603a]

_ Alethio's analytics platform helps users visualize,
  interpret, and react to blockchain data in real time.


""" Current blockchain explorers provide little clarity into the evolving ecosystem.
 They are often geared towards developers and leave average users in the dark.

 How do we access real time block data, analyzing the application layer,
 detecting anomalies, or monitoring the statistical signals that translate to larger KPIs.
"""

- UNSUPERVISED LEARNING
  - find patterns in large data sets.
  - reduce complex dataset to simpler high-level patterns/themes.
  - By reducing a large dataset into a small number of common themes,
    one can learn what it means for a particular transaction or account
    point to be "normal". ( anomaly detection ), or compared to a recent
    historical average ( novelty detection ).
  - As of 2019-03 Alethio offers an anomaly detection system for
    TXs, blocks, and accounts.
    - ranking algorithms
    - influence analysis like page rank.

 SUPERVISED LEARNIN
- there must be some large initial set of data for which the value
  of the labels or responses is known.
  - Rakr:
    - gather external data about accounts (metadata) for the
      purposes of machine learning.
    - Rakr hopes to provide a platform for gathering and sharing
      this valuable metadata.
  - two common subcategories:
    - prediction:
      - use historical data to estimate future value
      - account type:
        - decentralized exchange
        - DOS
        - Ponzi scheme
      - Price prediction (training input: "large set" of historical prices).
    - classification:
      - use historical data and some given-entity data
        to classify the given-entity. (labeling)

  -  raw data ("the set of knowns") can be used to extract features
     for accounts (total balance, average TX frequency/age/...)

  - Alethio recently added semantic lifting to expand the set of "knowns"
    beyond the protocol layer to include application-level data, such as
    whether a contract is a token, and to which standard it complies.

 In Practice
Ex: Ponzi model developed by Alethio:
- First model, to expand to more general fraud models in near term.
- feature extraction pipelines built during this model development effort
  can be reused to classify any account according to one of the labels
  in the (growing) Rakr database. (exchange, art DAO, ICOs, casino, fraud, DoS-alike, ...)
- ... we envision a blockchain where every account and entity is enriched with
  useful classifications and properties, whether empirical and created by humans,
  or predicted and created by statistical models.

Keep an eye out for the next article by Paul Lintilhac, which will give an exposition of one of
Alethio’s recent data science initiatives: the Ponzi Model.
[[}]]

• Eventeum: [[{evm.events,integration.data,00_PM.low_code,00_PM.radar]]
@[https://github.com/ConsenSys/eventeum]
- Project status: Stall.  https://github.com/eventeum/eventeum/issues/176

Eventeum: listen for specified (SmartContract/Blocks) event emissions
          and broadcasts (Kafka/HTTP/RabbitMQ) them to the middleware layer.

 Features : Static/Dynamic Configuration, HA, Resilient to node failures,  blochain Fork Tolerance

 PREREQUISITES       |  BUILD
 - Java 8            |  $ git clone https://github.com/ConsenSys/eventeum
 - Maven             |  $ cd eventeum
 - Docker (optional) |  $ mvn clean package

 RUNNIN
  Alt 1: MongoDB, Ethereum, Zookeeper,           │ Alt 2: Docker                                 │ Alt 3: all-in-one
         Kafka, Rabbit nodes already in place    │ $ cd server ;                                 │ TEST ENVIRONMENT
  $ cd server                                    │ $ docker build . -t kauri/eventeum:latest     │ $ cd server
  $ export SPRING_DATA_MONGODB_HOST=host..:port  │ $ export SPRING_DATA_MONGODB_HOST=host...:port│ $ docker-compose \
  $ export ETHEREUM_NODE_URL=http://host...:port │ $ export ETHEREUM_NODE_URL=http://host..:port │   -f docker-compose.yml \
  $ export ZOOKEEPER_ADDRESS=zookeeper-host:port │ $ export ZOOKEEPER_ADDRESS=host...:port       │   build
  $ export KAFKA_ADDRESSES=kafka-host:port       │ $ export KAFKA_ADDRESSES=host...:port         │ $ docker-compose \
  $ export RABBIT_ADDRESSES=rabbit-host:port     │ $ export RABBIT_ADDRESSES=host...:port        │   -f docker-compose.yml \
                                                 │                                               │   up
  $  java -jar target/eventeum-server.jar        │ $  docker run -p 8060:8060 kauri/eventeum     │
 ────────────────────────────────────────────────┴───────────────────────────────────────────────┴─────────────────────────
  CONFIGURING NODES
(application.yml)
 ethereum:
   nodes:
     - name: default               ← node 1
       url: http://mainnet:8545
     - name: sidechain             ← node 2
       url: wss://sidechain/ws
     - name: sidechain             ← ...
       ...
 eventFilters:                     ← HARDCODED EVENTS
   - id: RequestCreated
     contractAddress: ${CONTRACT_ADDRESS:0x..}
     eventSpecification:
       eventName: RequestCreated
       indexedParameterDefinitions:
         - position: 0
           type: BYTES32
         - position: 1
           type: ADDRESS
       nonIndexedParameterDefinitions:
         - position: 2
           type: BYTES32
     correlationId:
       type: NON_INDEXED_PARAMETER
       index: 0



┌─────────────────────────────────────────────────────────────── ┌──────────────────────────────────────────────────────────
│  DYNAMIC REGISTE                       │ SUCCESS               │  DYNAMIC UNREGISTE                │ SUCCESS
│  REQUEST                               │ RESPONSE              │  REQUEST                          │ RESPONSE
│ ───────────────────────────────────────┼────────────────────── │ ──────────────────────────────────┼──────────────────────
│ URL    : /api/rest/v1/event-filter     │Code: 200              │ URL:/api/rest/v1/event-filter/{id}│Code: 200
│ Method : POST                          │Content:               │ Method    : DELETE                │Content: N/A
│ Headers: content-type application/json │ { "id": "id" }        │ Headers   : N/A
│ URL    : -                             │                       │ URL Params: N/A
│ Params                                 │                       │ Body      : N/A
│ Body                                   │
│ {                                      │
│  "id": "event-id",                     │
│  "contractAddress": "0x1...Af4d2",     │
│  "eventSpecification": {               │
│   "eventName": "TestEvent",            │
│                                        │
│   "indexedParameterDefinitions": [     │
│     {"position": 0, "type": "UINT256"},│
│     {"position": 1, "type": "ADDRESS"} │
│   ],                                   │
│   "nonIndexedParameterDefinitions": [  │
│     {"position": 2, "type": "BYTES32"},│
│     {"position": 3, "type": "STRING"}  │
│   ]                                    │
│  },                                    │
│                                        │
│  "correlationIdStrategy": {            │
│    "type": "NON_INDEXED_PARAMETER",    │
│    "parameterIndex": 0 }               │
│ }                                      │


 BROADCASTEST MESSAGES FORMAT
 (to kafka topic|rabit exch)

SMART-CONTRACT EVENT                        |BLOCK EVENT FORMAT
--------------------------------------------+------------------
{                                           |{
 "id":"unique-event-id",                    | "id":"0x79...",
 "type":"CONTRACT_EVENT",                   | "type":"BLOCK",
 "details":{                                | "details":{
   "name":"DummyEvent",                     |  "number":257,
   "filterId": {SOME_UUID},                 |  "hash":"0x797...",
   "indexedParameters":[                    |  "timestamp":12345678
    {"type":"bytes32","value":"BytesValue"},| },
    {"type":"address","value":"0x00..."}    | "retries":0
   ],                                       |}
   "nonIndexedParameters":[
    {"type":"uint256","value":10},
    {"type":"string","value":"StringValue"}
   ],
   "transactionHash":"0xe4...",
   "logIndex":0,
   "blockNumber":258,
   "blockHash":"0x65...",
   "address":"0x....",
   "status":"UNCONFIRMED",
   "eventSpecificationSignature": "0x....",
   "id":"unique-event-id"
 },
 "retries":0
}

 CONFIGURATION ENV VARs
(alternatively use application.yml)
Env Variable                             Default
SERVER_PORT                              8060
ETHEREUM_BLOCKSTRATEGY                   POLL^|PUBSUB
ETHEREUM_NODE_URL                        http://localhost:8545
ETHEREUM_NODE _HEALTHCHECK_PPOLLINTERVAL 2000 (ms)
EVENTSTORE_TYPE                          DB
BROADCASTER_TYPE                         KAFKA^|HTTP|RABBIT
BROADCASTER_CACHE _EXPIRATIONMILLIS      6000000     time that a message should live within eventeum broadcast cache.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 During this time eventeum guarants that duplicate messages are NOT broadcast
BROADCASTER_EVENT _CONFIRMATION _NUMBLOCKSTOWAIT               12
BROADCASTER_EVENT _CONFIRMATION _NUMBLOCKSTOWAITFORMISSINGTX  200  After a fork, a TX may disappear,
                                                                   This params indicates the number of
                                                                   blocks to wait on the new fork,
                                                                   before assuming that an event emitted
                                                                   during this transaction has been INVALIDATED.
BROADCASTER_MULTIINSTANCE                false      If multiple eventeum instances exits, set this param to true
                                                    so that the eventeum communicates added/removed filters to other
                                                    instances, via kafka.
BROADCASTER_HTTP_CONTRACTEVENTSURL       ...        URL to post to smart-contract events when BROADCASTER_TYPE=HTTP
BROADCASTER_HTTP_BLOCKEVENTSURL                     URL to post to new-blocks     events when BROADCASTER_TYPE=HTTP
ZOOKEEPER_ADDRESS                        localhost:2181
KAFKA_ADDRESSES                          localhost:9092  ← CSV list of addresses
KAFKA_TOPIC_CONTRACT_EVENTS              contract-events   The kafka topic name for broadcast contract event messages
KAFKA_TOPIC_BLOCK_EVENTS                 block-events      The kafka topic name for broadcast block event messages.
KAFKA_REQUEST_TIMEOUT_MS                 20000             The duration after which a request timeouts.
KAFKA_ENDPOINT_IDENTIFICATION_ALGORITHM  null              The endpoint identification algorithm to validate server hostname using server certificate.
KAFKA_SASL_MECHANISM                     PLAIN             The mechanism used for SASL authentication.
KAFKA_USERNAME                           ""                username used to connect to a SASL secured Kafka cluster.
KAFKA_PASSWORD                           ""                password used to connect to a SASL secured Kafka cluster.
KAFKA_SECURITY_PROTOCOL                  PLAINTEXT         Protocol used to communicate with Kafka brokers.
KAFKA_RETRIES                            10                number of times a Kafka consumer will try to publish a message before throwing an error.
KAFKA_RETRY_BACKOFF_MS                   500               The duration between each retry.
SPRING_DATA_MONGODB_HOST                 localhost         mongoDB host (used when event store is set to DB).
SPRING_DATA_MONGODB_PORT                 27017             mongoDB post (used when event store is set to DB).
RABBIT_ADDRESS                           localhost:5672    property spring.rabbitmq.host (The rabbitmq address)
RABBIT_EXCHANGE                          ThisIsAExchange   property rabbitmq.exchange
RABBIT_ROUTING_KEY                       thisIsRoutingKey  property rabbitmq.routingKeyPrefix

(See more info about INFURA Support Configuration in original link)

 ADVANCED CONFI

 Kafka Broadcasting Correlation Id Strategies
Each subscribed event can have a correlation id strategy association with it,
during subscription.
- A correlation id strategy defines what the kafka message key for a
  broadcast event should be, and allows the system to be configured so that
  events with particular parameter values are always sent to the same
  partition.

- Currently supported correlation id strategies are:
  - Indexed Parameter Strategy: An indexed parameter within the event
    is used as the message key when broadcasting.
  - Non Indexed Parameter Strategy: An non-indexed parameter within the
    event is used as the message key when broadcasting.

 EVENT STORE
- Eventeum utilises an event store in order to establish
  the block number to start event subscriptions from,
  in the event of a failover.

- For example, if the last event broadcast for event with id X
  had a block number of 123, then on a failover, eventeum will
  subscribe to events from block 124.

2 supported event store implementations:
  - MongoDB:
    Env Variable             Default    Description
    EVENTSTORE_TYPE          DB         MongoDB event store enabled
    SPRING_DATA_MONGODB_HOST localhost  The mongoDB host
    SPRING_DATA_MONGODB_PORT 27017      The mongoDB post

  - REST Service:
    (see original link for more info)

 EMBEDDING EVENTEUM
Eventeum can be embedded into an existing Spring Application
via an annotation following next steps.

STEP 1:  Add Kauri repo to the pom.xml:
  <repositories>
    <repository>
      <id>bintray-consensys-kauri</id>
      <url>https://consensys.bintray.com/kauri</url>
    </repository>
  </repositories>

STEP 2: Add eventeum-core dependency to pom.xml:
  <dependency>
    <groupId>net.consensys.eventeum</groupId>
    <artifactId>eventeum-core</artifactId>
    <version> LATEST_EVENTEUM_VERSION </version>
  </dependency>

STEP 3: Within your Application class or a
  @Configuration annotated class, add the
  @EnableEventeum annotation.

Known Caveats / Issues
- In multi-instance mode, where there is more than
one Eventeum instance in a system, your services are
required to handle duplicate messages gracefully, as each
instance will broadcast the same events.
[[}]]

● Camel Connector [[{evm.events,integration.data,dev_framework.java,00_PM.TODO]]
@[https://github.com/bibryam/camel-web3j]
@[https://github.com/apache/camel/blob/main/components/camel-web3j/src/main/docs/web3j-component.adoc]
@[https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43]

• Sample 1: Listen for new mined blocks and send the block hash to
             a jms queue:

  from("web3j://http://127.0.0.1:7545?operation=ETH_BLOCK_HASH_OBSERVABLE")
      .to("jms:queue:blocks");

• Sample 2: Use block hash code to retrieve the block and full TXs details:
  from("jms:queue:blocks")
    .setHeader(BLOCK_HASH, body())
    .to( "web3j://http://127.0.0.1:7545?"
       + "operation=ETH_GET_BLOCK_BY_HASH&"
       + "fullTransactionObjects=true");

• Sample 3:
  from("direct:start")
    .to("web3j://http://127.0.0.1:7545?"
      + "operation=ETH_GET_BALANCE&"    ← Read balance
      + "address=0xc8CDce..&"             ← for address
      + "atBlock=10");                    ← at given block
[[}]]

● EXTERNAL STORAGE (IPFS,...) [[{scalability.offchain,01_doc_has.comparative,dev_framework.ipfs]]
                              [[infrastructure.storage.offchain,privacy.offchain]]
                              [[scalability.offchain,00_PM.TODO]]
- TODO: Compare with alternative Storage "providers": IPFS , Maidsafe, Storj
- IPFS is just a protocol like http. It is unmotivated (don't have tokens).
- Eris is permissioned blockchain thing and use IPFS underneath.
- Storj, SAFE Network, Sia and Filecoin: motivated storage networks with
  different underlying protocols and design decisions.
- Swarm is an organizational idea. A philosophical structure.
  ""serverless hosting incentivised peer-to-peer storage and content distribution""
  ""From the end user's perspective, Swarm is not that different from WWW,
    except that uploads are not to a specific server. The objective is to peer-to-peer
    storage and serving solution that is DDOS-resistant, zero-downtime, fault-tolerant
    and censorship-resistant as well as self-sustaining due to a built-in incentive
    system which uses peer to peer accounting and allows trading resources for payment.
    Swarm is designed to deeply integrate with the devp2p multiprotocol network layer
    of Ethereum as well as with the Ethereum blockchain for domain name resolution,
    service payments and content availability insurance. """"""

""""""Two major features of swarm that sets it apart from other decentralised
distributed storage solutions (bittorent, zeronet, IPFS) are 'upload and
disappear' and the incentive system. The former refers to fact that Swarm
does not only serve content, but it also provides a cloud storage service.
Unlike related systems, you do not only publish the fact you host content,
but there is a genuine sense in which you can just upload stuff to the swarm
and potentially disappear (drop off as a node, disconnect or just operate
without storage entirely) right away. Swarm aspires to be the generic storage
and delivery service catering for all usecases ranging from serving low
latency realtime interactive web applications as well as acting as guaranteed
persistent storage for rarely used content. The incentive system makes sure
that participating nodes following their rational self interest nontheless
converge on an emergent swarm behaviour that is beneficial for the entire
system as well as economically self-sustaining. In particular, it allows
nodes in the network to pool their bandwidth and storage resources in the
most efficient way to collectively provide services. """""""
here are two kinds of accounts in Ethereum which share the same address space
: External accounts that are controlled by public-private key pairs (i.e.
humans) and contract accounts which are controlled by the code stored
together with the account.
[[}]]

● Vue+Ethereum+IPFS DApp Starter: [[{00_PM.low_code,scalability.offchain,dev_framework.ipfs,20_QA.UX,00_PM.TODO]]
@[https://github.com/redacademy/vue-ethereum-ipfs] [[}]]

● External Inputs (Oracles): [[{101,integration.*,10_EVM.i/o.oracles,12_solidity]]
                             [[02_use_case.finance,security,02_use_case.integrity,00_PM.WiP]]
- The evm and SmartContract by extension just have access to
  internal (current-state) blockchain data. Oracles are used when we
  need logic that depends of external-to-blockchain events, playing the
  role of "input" devices.
- Oracles in practice are "trusted" smart-contracts whose internal data/status
  is the result of a list of minimum threshold "N" of "M" different Signatures,
  or some sort of voting. Each signature can have a different reputation/weight.
- For example we trust a deployed Oracle that claims that a vehicle
  with ID:ABCDEF had an accident because map( hashOfCAR_ID =>
  carStatus) ddbbStatus is updated only after at least N signatures of
  M trusted signers have been sent claiming such accident is true.

- Companies like ChainLink offer "professional oracle services for MainNet
  and other networks.

• chain.link Oracles:
  - "Pole position" in Secutiry Dapps in @[https://www.stateofthedapps.com/]
     with 1.700+ votes.
  @[https://chain.link/]
  - smart contracts connected to real world data, events and payments.
  - Chainlink network provides reliable tamper-proof inputs and outputs
    (aka  ORACLES ) for complex smart contracts on any blockchain,

• Provable.xyz Oracles: https://provable.xyz/
  The ProvableTM blockchain oracle for modern DApps.
  Enabling the shift of traditional services such as finance, gambling,
  and insurance into decentralization.

• band-protocol:
@[https://bandprotocol.com/]
  cross-chain data oracle platform that aggregates and connects real-world
  data and APIs to smart contracts.
[[}]]

● GraphQL [[{integration.data,integration.graphql,architecture,00_PM.WiP]]
- Extracted from @[https://graphql.org/]
  """GraphQL is a  query language  for APIs and a runtime
     for fulfilling those queries with your existing data.
     ... simplifies API evolution, and enable powerful dev
     tools."""

- @[https://github.com/ConsenSys/ethql]
  (Available in Geth 1.9+, Besu 1.2+, and others)
    EthQL has the potential to avoid the sync from blockchain to a
    conventional SQL database for creating reports.

  Example GraphQL Queries
@[https://github.com/ConsenSys/ethql/wiki/Example-Use-Cases]
   Query a single block (5000000)
<a TODO href="https://ethql-alpha.infura.io/graphql?query=%7B%0A%20%20block(number%3A%205000000)%20%7B%0A%20%20%20%20hash%0A%20%20%20%20transactions(filter%3A%20%7B%20withInput%3A%20true%20%7D)%20%7B%0A%20%20%20%20%20%20index%0A%20%20%20%20%20%20hash%0A%20%20%20%20%20%20from%20%7B%0A%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20to%20%7B%0A%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20decoded%20%7B%0A%20%20%20%20%20%20%20%20...%20on%20ERC20Transfer%20%7B%0A%20%20%20%20%20%20%20%20%20%20tokenContract%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20symbol%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20from%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20account%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%09address%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20tokenBalance%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20to%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20account%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20value%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">[fiddle]</a>
  Example Query
  {                                                   QUERY:
    block(number:   5000000 ) {                     ← SELECT ... FROM block 5000 ...
      hash                                                    ^                   ^
      transactions                                  ← transactions                ·
        (filter:   { withInput: true } )            ← WHERE input Data exists  ····

      {                                             ← SUBQUERY OVER QUERY RESULTS:
                                                      SELECT ... FROM FIRST_QUERY
        index                                                                      ^
        hash                                                                       ·
        from { address }                              WHERE from=address AND to=address
        to   { address }
        decoded {
          ... on ERC20Transfer {                    ← for those that can be decoded as
                                                      token transfers, return.
            tokenContract { symbol }                  ← token symbol
            from {                                    ← sending address
              account { address }
              tokenBalance                            ← sending address token balance
            }
            to {  account { address } }               ← receiving address
            value
          }
        }
      }
    }
  }

  Information on specific blocks
  {
    blocks(numbers: [1000, 1001,])   {        ← SELECT ... FROM BLOCK in (1000,1001)
                                                       ^
      transactionsRoles(from:"0xF5b...") {    ← transactions.gasPrice WHERE from = 0xF5b...
        gasPrice   ←···········································┘
      }
    }
  }

  Information on a range of blocks
  {
    blocksRange(numberRange: [54000, 54005])   ← SELECT ... FROM BLOCK in numberRanger
    {                                                   ^
                                                        └··········┐
      transactions {                                               │
        hash                                      tx.hash  ········┤
        value                                     tx.value ········┤
        from {                                                     │
          address                                 tx.from.address··┤
          balance                                 tx.from.balance··┤
        }                                                          │
        to { address }                            tx.to  .address··┘
      }
    }
  }

  Information on an account
  for account "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d".
  {                                 ← SELECT ... FROM BLOCKCHAIN   ...
                                              ^                     ^
                                              ·    ┌────────────────┴──────┐
   account(address: "0x06012..."){            ·  ← WHERE account="0x6012..."
     storage{                                 ·
       value(at: 0)                   account.storage.value at index 0
     }
   }
  }

  Information on a TX
  {
    transaction(hash: "0x7cc...") {   ← For TX with hash 0x7cc... return:
      logs {                          ← fetch the log topics
        topics
        decoded {                     ← and attempt to decode the TX to reveal
          event                         ← event
          entity                        ← entity
          standard                      ← Standard information
        }
      }
    }
  }
• GraphQL over HTTP:
@[https://besu.hyperledger.org/en/stable/HowTo/Interact/APIs/GraphQL/]

  - Reduce overhead for common queries.
    Ex:
    Non-GraphQL                 GraphQL:
    ----------------------      ------------------
    - query   each receipt      - single query for
      in a block


- The Besu GraphQL schema describes the GraphQL implementation for
  Ethereum. Enable the GraphQL service using command line options.

Note

GraphQL is not supported over WebSockets.

Access the GraphQL endpoint at http://<HOST>:<PORT>/graphql.
Configure <HOST> and <PORT> using graphql-http-host and
graphql-http-port. The default endpoint is
http://127.0.0.1:8547/graphql.
GraphQL requests with cURL

Hyperledger Besu JSON-RPC API methods with an equivalent GraphQL
query include a GraphQL request and result in the method example.

Example

The following syncing request returns data about the synchronization
status.

curl -X POST -H "Content-Type: application/json" \
 --data '{ "query": "{syncing{startingBlock currentBlock highestBlock}}"}'
 http://localhost:8547/graphql

GraphQL requests with GraphiQL App

The third-party tool, GraphiQL, provides a tabbed interface for
editing and testing GraphQL queries and mutations. GraphiQL also
provides access to the Besu GraphQL schema from within the app.

Besu does not execute pending transactions so results from account,
call, and estimateGas for Pending do not reflect pending transactions.

Example
Pending Transaction Count

curl -X POST -H "Content-Type: application/json" \
  --data '{ "query": "{pending {transactionCount}}"}' \
  http://localhost:8547/graphql

Pending Transactions

curl -X POST -H "Content-Type: application/json" \
 --data '{ "query": "{pending {transactions{hash}}}"}' \
 http://localhost:8547/graphql
[[}]]

● TheGraph Protocol [[{integration.graphql,scalability.graph,10_EVM.events]]
                    [[00_PM.low_code,dev_framework.the_graph,20_QA.UX,00_PM.TODO]]
- "Before The Graph, teams had to develop and operate proprietary
  indexing servers. This required significant engineering and hardware
  resources and broke the important security properties required for
  decentralization."

- TheGraph can be part of Sharding scalability future:
@[https://money.yahoo.com/graph-positioned-unshackle-ethereum-2-180403603.html]
  "...  Vitalik’s idea is effectively ‘rollups on top of
   sharding’, but this creates its own issue – where will the
   historical data from all these shards be stored?

   ...problem: where exactly all this sharding data go?
   Vitalik suggested institutional volunteers, DAOs, block
   explorers, and torrents as theoretical solutions – but only
  one project was name-dropped:
   Protocols like The Graph can create incentivised marketplaces
  where clients pay servers for historical data with Merkle proofs of
  its correctness.  This creates an incentive for people and
  institutions to run servers that store historical data and
  provide it on demand.

- popular services already using TheGraph protocol:
  Uniswap:
  Sintetics:
  Decentraland:
  Aragon:

- TODO:
@[https://thegraph.com/docs/developer/create-subgraph-hosted]
@[https://medium.com/intech-conseil-expertise/create-your-graph-node-to-query-complex-data-from-blockchain-via-graphql-6f08fbd494c5]

By Kebin Thizy @[https://medium.com/@thizy.kevin]
- GitHub repo: @[https://github.com/investorid/subgraph-experiment]

-  "The Graph protocol is a decentralized protocol for
    indexing and querying data from blockchains, starting
    with Ethereum. It makes it possible to query data that is
    difficult to query directly.”

- it knows about the entities it indexes.
  composed of subgraphs, carefully developed by the community.
- There is a global instance of TheGraph that accepts subgraph definition.

  Example reference Smart Contract storing Identity claims
   Ex:
   claim type 1: id-holder is French   , attested/signed by issuer_i1
   claim type 2: holder is over 18     , attested/signed by issuer_i1
   claim type 3: has not bank debts    , attested/signed by issuer_i2
   claim type 3: ...                   , attested/signed by issuer_i3
   ...
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   For each contract instance, for each claim type,
   fetch all claims attested/signed by same issuer_iN

  └ Without Graphs:
    for contract in identityContractInstances:     ←   A loop for each instance
       for claim_type in type1 type2 ...:          ←   A loop for each type
           fetch claims where issuer = issuer_iN
  └ With GraphQL and the Graph protocol:
  -  A single GraphQL query suffices .

- PRE-SETUP (opinionated, using docker, and NodeJS)
  - $ git clone https://github.com/graphprotocol/graph-node.git
    $ cd graph-node
    $ sudo docker-compose up # ← Start up Graph instance/PostgreSQL/IPFS
                                 needs ports 4001, 5001, 8000, 8001, 8020,
                                             8080 and 5432

  - $ yarn init                      # ← Init NodeJS project (create 'package.json')
    $ yarn add --dev \               # ← Install graph* NodeJS package dependencies
           @graphprotocol/graph-cli
           @graphprotocol/graph-ts
    $ vim package.json
    {
      "scripts" : {
        "codegen"      : "graph codegen",
        "create-local" : "graph create domain/graph-name --node http://127.0.0.1:8020",
        "build"        : "graph build",
        "deploy-local" : "graph deploy domain/graph-name --debug --ipfs http://localhost:5001 --node http://127.0.0.1:8020/",
        "watch-local"  : "graph deploy domain/graph-name --watch --debug --node http://127.0.0.1:8020/ --ipfs http://localhost:5001"
      }
    }
                                       ^^^^^^^^^^^^^^^^^
                              - Replace domain/graph-name to mirror
                                the SubGraph. Ex: investorid/id

     $ cp ${ContractABI_json} ./abis        # ← alt 1: Copy ABIs
     $ yarn add --dev @investorid/solidity  # ← alt 2: use a package (prefered)
  Creating the Graph:

   subgraph.yaml : meta-data describing the SubGraph:
                   Declares ABI to be used and scanned
                   by the graph node.
   | specVersion: 0.0.3
   | description: Decentralized IDs over Ethereum
   | repository: https://github.com/investorid/investorid-subgraph
   | schema:
┌→ |   file: ./schema.graphql    ← entities used by the SubGraph and exposed via GraphQL.
·  | dataSources:
·  |   - kind: ethereum/contract
·  |     name: Identity
·  |     network: http://localhost:8545
·  |     source:
·  |       abi: Identity
·  |     mapping:
·  |       kind: ethereum/events
·  |       apiVersion: 0.0.3
·  |       language: wasm/assemblyscript
·  |       file: ./src/handler/identity.ts
·  |       entities:   ←················· Any entity used by event handlers
·  |         - Identity                   must be declared in here
·  |         - Key
·  |       abis:
·  |         - name: Identity
·  |           file: ./node_modules/@investorid/solidity/build/contracts/Identity.json
·  |       eventHandlers: ←·············· all event to be scanned/handled must
·  |                                      be declared here
·  |         - event: KeyAdded(indexed bytes32,indexed uint256,indexed uint256)
·  |           handler:  handleKeyAdded
·  |         - event: KeyRemoved(indexed bytes32,indexed uint256,indexed uint256)
·  |           handler:  handleKeyRemoved
·                                  ·
└  schema.graphql
   | type Identity @entity {
   |   id: ID!
   |   address: Bytes!
   |   keys: [Key!]! @derivedFrom(field: "identity")  ← reverse property
   | }                                                  more info at:
   |                                                  @[https://thegraph.com/docs/graphql-api]
   | type Key @entity {
   |   id: ID!
   |   keyType: BigInt!    ← BigInt, Bytesis a custom type
   |   key: Bytes!
   |   purposes: [Int!]!
   |   identity: Identity!
   | }

   .src/handlers/identity.ts  ← Event handlers:
                                To generated the referenced typings and
                                automated code parts referenced run
                                $ yarn run codegen
                                ouput:
                                → ../../generated/Identity/Identity
                                → ../../generated/schema

  | import { log, store, Address, Bytes }
  |   from "@graphprotocol/graph-ts";
  |
  | import {
  |   KeyAdded as KeyAddedEvent,
  |   KeyRemoved as KeyRemovedEvent,
  | } from '../../generated/Identity/Identity';
  |
  | import {
  |   Identity,
  |   Key,
  | } from '../../generated/schema';
  |
  | export function
  |          handleKeyAdded (event: KeyAddedEvent): void {
  |   let identity = Identity.load(event.address.toHexString());
  |   if (identity == null) {
  |     identity = new Identity(event.address.toHexString());
  |     identity.address = event.address;
  |
  |     identity.save();
  |   }
  |
  |   let key = Key.load(createKeyID(event.address, event.params.key));
  |   if (key == null) {
  |     key = new Key(createKeyID(event.address, event.params.key));
  |
  |     key.identity = identity.id;
  |     key.key = event.params.key;
  |     key.keyType = event.params.keyType;
  |     key.purposes = [event.params.purpose.toI32()];
  |
  |     key.save();
  |
  |     identity.save();
  |   } else {
  |     let purposes = key.purposes;
  |     purposes.push(event.params.purpose.toI32());
  |     key.purposes = purposes;
  |
  |     key.save();
  |     identity.save();
  |   }
  | }
  |
  | export function
  |          handleKeyRemoved (event: KeyRemovedEvent): void {
  |   let identity = Identity.load(event.address.toHexString());
  |   if (identity == null) {
  |     return;
  |   }
  |
  |   let key = Key.load(createKeyID(event.address, event.params.key));
  |   if (key == null) {
  |     return;
  |   }
  |
  |   let keyIndex = key.purposes.indexOf(event.params.purpose.toI32());
  |   if (keyIndex == -1) {
  |     return;
  |   }
  |   let purposes = key.purposes;
  |   purposes.splice(keyIndex, 1);
  |   key.purposes = purposes;
  |
  |   if (key.purposes.length === 0) {
  |     store.remove('Key', key.id);
  |   } else {
  |     key.save();
  |   }
  | }
  |
  | function createKeyID(identity: Address, key: Bytes): string {
  |   return identity.toHexString().
  |       concat('-').concat(key.toHexString());
  | }

  Implementation of event handlers
  Refer to The Graph documentation, to learn how to write mappings.

  - basics about mappings:
    - To create a new entity instance, call:
      <Entity>#create(<id>)  ← <id> is a string that must be generated.
    - To be able to retrieve instances from blockchain data,
      the IDs should be composed of addresses, hashes, etc...
    - To load an existing entity, call:
      <Entity>#load(<id>)
    - To save new entity|update existing one, call:
      <entity>.save()
    - To destroy and remove an entity from the store, call
      store.remove('EntityName', id)

  Running the subgraph

  $ yarn run build        ←·· Build SubGraph
  $ yarn run create-local ←·· Declare it  on local Graph node
  $ yarn run deploy-local ←·· Deploy  to the local Graph node
  $ yarn run watch-local  ←·· Optional: Watch deployig after
                                      each code update


  GraphQL UI for queries available at:
  http://127.0.0.1:8000/subgraphs/name/domain/graph-name/graphql
                                       └──────┬────────┘
                                       replace with name
                                       of the subgraph

Note: Whenever the Ethereum network has been reseted
      (Ganache restarted,...), the ./docker/data must
      be deleted:
      - required to clean the existing database
        that checks the genesis block for the
        current ethereum network.
[[}]]


● GETH [[{evm.implementation.geth,devops.network.bootstrap]]
 • GETH SETUP NODE: REF:  https://github.com/ethereum/go-ethereum
    STEP 1) Create  genesis.json
    {
      "config": {
            "chainId": 0,
            "homesteadBlock": 0,
            "eip155Block": 0,
            "eip158Block": 0
        },
      "alloc"      : {
      "0x00...01": {"balance": "111111"},
      "0x00...02": {"balance": "222222"}
      },
      "coinbase"   : "0x─20 bytes hex─",
      "difficulty" : "0x20000",
      "extraData"  : "",
      "gasLimit"   : "0x2fefd8",
      "nonce"      : "0x0000000000000042",
      "mixhash"    : "0x ..32bytes hex...",
      "parentHash" : "0x ..32bytes hex...",
      "timestamp"  : "0x00"
    }

    STEP 2) Initialize node
    $ geth init genesis.json   (init .../qdata/* files)

    STEP 3) (optional) Setup bootstrap node
     $ bootnode --genkey=boot.key
     $ bootnode --nodekey=boot.key

 • GETH layout:
  $DATADIR: (← defined by geth --datadir flag)
   ├─ .ethash/             ← ~1GB dataset used for PoW consensus
   ├─./genesis.json        ← geth init creates initial ddbb based on it
   ├─./qdata/              ← Node Blockchain and state databases, keystore, process log,...
   ├─ ...
   ├─./qdata/geth/nodekey  ← generated automatically on first run or through
   ├─ ...                    'bootnode -genkey .../nodekey' -writeaddress
   ├─./qdata/geth/chaindata/                                ^^^^^^^^^^^^^
   ├─ ...                                                   shows also pub.key
   ├─./qdata/gethLogs/node1.log                             for enode url
   ├─ ...                                                    (optional)
   ├─./qdata/*keystore*/node1key
   ├─./node1.conf
   ├─./keys/node1.key
   ├─./keys/node1a.pub
   ├─./keys/node1.pub
   └─./keys/node1a.key

   Full CLI options
  @[https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options]

• Basic Admin:
  ref: https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts
  - Geth Key Handling: [[{evm.implementation.geth,security.secret_mng]]

  (Geth) ACCOUNT "==" private key stored in file protected by password stored under:
                       $DATADIR/keystore/UTC--'created_at_UTC_ISO8601'-'address hex'

  $ geth account   command  [options] [arguments...]
                   ├─────┘   ^^^^^^^
     ┌─────────────┘         --datadir   Base dir for databases+keystore
     v                       --keystore  (def. $DATADIR/keystore)
     · list
     · new        ask for password/passphrase, return its public address.
     · update      migrate to newest key format.
     · import     Export key unencrypted NOT supported
       $ geth --datadir /someDir account import ./key.prv

  - using account NON-interactively (not connected to a geth node):
    $ geth --unlock primary --rpccorsdomain localhost --verbosity 6 2>> geth.log
    $ KEYLIST="0x407d73d8a49eeb85d32cf465507dd71d507100c1"
    $ KEYLIST="${KEYLIST},0,5"
    $ KEYLIST="${KEYLIST},e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32"
    $ geth --unlock "${KEYLIST}"

  [[}]]

  - TODO: Backup/Restore
    https://github.com/ethereum/go-ethereum/wiki/Backup-&-restore

  $ geth upgraded          ← "Sometimes" the internal database formats need updating
  $ geth removed           ← cleanup: remove blockchain and state databases
                             (does not touch the keystore)
  $ geth export 'filename' 0 30000 ← Export blockchain in binary format
                           ^^^^^^^
                           initial and
                           final block

  $ geth import 'filename'         ← Import form binary file

  - Geth extra CLIs : https://github.com/ethereum/go-ethereum/tree/master/cmd
    abigen
    bootnode    bootnode runs a bootstrap node for the Ethereum Discovery Protocol.
              @[https://godoc.org/github.com/ubiq/go-ubiq/cmd/bootnode]
    clef        signs TXs and data . Replacement for acct mgnt
    ethkey      simple tool for working with Ethereum keyfiles

    evm         evm executes EVM code snippets!!.
                   - internal/compiler
                   - compiler.go
                   - disasm.go
                   - main.go
                   - runner.go
                   - staterunner.go
    faucet
    geth
    internal/browser
    p2psim
    puppeth
    rlpdump     rlpdump is a pretty-printer for RLP data
    swarm       Command bzzhash computes a swarm tree hash.
    utils
    wnode
[[}]]

● Geth Architecture: [[{evm.implementation.geth,architecture.geth,01_doc_has.diagram,00_PM.TODO]]
  REF: https://www.mycryptopedia.com/ethereum-geth-installing-and-running-a-node/
         ┌────────┐              ┌───────┐
         │JSON RPC│              │LevelDB│
         └────────┘              └───────┘
              ↑                      ↑
  ┌─────┐     │       ┌─────┐        │  ┌───────┐
  │SWARM│     └──────→│ EVM ┼←───────┘  │Whisper│
  └──┬──┘             └─────┘           └───┬───┘
     │                   ↓                  │
     │         ┌─────────────────────┐      │
     └────────→│     P2P/Gossip      │←─────┘
               └─────────┬───────────┘
                         ↓
                    ···· ···   ···
                   ··   ·   ···  ··
                   ·   Network    ·
                   ······     ····
                         ·····

  • LevelDB internal (key/value) storage backend. http://leveldb.org/
    - entries stored lexicographically sorted by keys.
      (sorting comes-in very useful for querying)
    - Arbitrary byte arrays:
      keys and values are treated as simple arrays of bytes,
      so content can be anything from ASCII strings to binary blobs.
    - Compressed storage:
      Google’s Snappy compression library (optional) dependency,
      highly optimized for fast compression (vs high compress ratio)
    - Ex ussage:
      var level = require('level')
      var db = level('./db', { valueEncoding: 'json' })

      db.put('key', { example: true }, function (err) {
        if (err) throw err

        db.get('key', function (err, value) {
          if (err) throw err
          console.log(value)
        })
      })
[[}]]

● Understanding Geth Code: [[{evm.implementation.geth,00_PM.TODO]]
 @[https://github.com/Agzs/geth-pbft-study/wiki/Blockchain-Structure]

  type BlockChain struct {
    config *params.ChainConfig // chain & network configuration

┌   hc           *HeaderChain
|   chainDb      ethdb.Database
|   eventMux     *event.TypeMux
|   genesisBlock *types.Block
|
|   mu      sync.RWMutex // global mutex for locking chain operations
|   chainmu sync.RWMutex // blockchain insertion lock
|   procmu  sync.RWMutex // block processor lock
|
|   checkpoint       int          // checkpoint counts towards the new checkpoint
|┌  currentBlock     *types.Block // Current head of the block chain
|·  currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!)
|·
|·  stateCache   state.Database // State database to reuse between imports (contains state cache)
|·  bodyCache    *lru.Cache     // Cache for the most recent block bodies
|·  bodyRLPCache *lru.Cache     // Cache for the most recent block bodies in RLP encoded format
|·  blockCache   *lru.Cache     // Cache for the most recent entire blocks
|·  futureBlocks *lru.Cache     // future blocks are blocks added for later processing
|·
|·  quit    chan struct{} // blockchain quit channel
|·  running int32         // running must be called atomically
|·  // procInterrupt must be atomically called
|·  procInterrupt int32          // interrupt signaler for block processing
|·  wg            sync.WaitGroup // chain processing wait group for shutting down
|·
|·  engine    consensus.Engine
|·  processor Processor // block processor interface
|·  validator Validator // block and state validator interface
|·  vmConfig  vm.Config
|·
|·  badBlocks *lru.Cache // Bad block cache
|·}
|·
|·                                                 // Header represents a block header in the Ethereum blockchain.
|└→type Block struct {                             type Heade  struct {
|    header       *Header ·······················→  ParentHash  common.Hash    Keccak256(parent_block_header)
|    uncles       []*Header                         UncleHash   common.Hash
|    transactions Transactions                      Coinbase    common.Address miner address
|                                                   Root        common.Hash   ← of state    trie
|    // caches                                      TxHash      common.Hash   ← of TX       trie
|    hash atomic.Value                              ReceiptHash common.Hash   ← of receipts trie
|    size atomic.Value                              Bloom       Bloom
|                                                   Difficulty  *big.Int
|    // Td is used by package core to store the     Number      *big.Int
|    // total difficulty of the chain up to and     GasLimit    *big.Int
|    // including the block.                        GasUsed     *big.Int
|    td *big.Int                                    Time        *big.Int
|                                                   Extra       []byte
|    // These fields are used by package eth        MixDigest   common.Hash
|    // to track inter-peer block relay.            Nonce       BlockNonce    ← PoW (Combined with
|    ReceivedAt   time.Time                       }                             MixDigest)
|    ReceivedFrom interface{}
|  }
|
└→ type HeaderChain struct {
       config *params.ChainConfig

       chainDb       ethdb.Database
       genesisHeader *types.Header

       currentHeader     *types.Header // Current head of the header chain (may be above the block chain!)
       currentHeaderHash common.Hash   // Hash of the current head of the header chain (prevent recomputing all the time)

       headerCache *lru.Cache // Cache for the most recent block headers
       tdCache     *lru.Cache // Cache for the most recent block total difficulties
       numberCache *lru.Cache // Cache for the most recent block numbers

       procInterrupt func() bool

       rand   *mrand.Rand
       engine consensus.Engine
   }


  TRANSACTIONS
  type Transaction struct {    type txdata struct {
      data txdata                  AccountNonce uint64          `json:"nonce"    gencodec:"required"`
      // caches                    Price        *big.Int        `json:"gasPrice" gencodec:"required"`
      hash atomic.Value            GasLimit     *big.Int        `json:"gas"      gencodec:"required"`
      size atomic.Value            Recipient    *common.Address `json:"to"       rlp:"nil"` // nil → new contract
      from atomic.Value            Amount       *big.Int        `json:"value"    gencodec:"required"`
  }                                Payload      []byte          `json:"input"    gencodec:"required"`

                                   // Signature values
                                   V *big.Int `json:"v" gencodec:"required"`
                                   R *big.Int `json:"r" gencodec:"required"`
                                   S *big.Int `json:"s" gencodec:"required"`

                                   // This is only used when marshaling to JSON.
                                   Hash *common.Hash `json:"hash" rlp:"-"`
                               }

  DATABASE
  type Database interface {
      Put(key []byte, value []byte) error
      Get(key []byte) ([]byte, error)
      Delete(key []byte) error
      Close()
      NewBatch() Batch
  }
  //==> Implied by LDBDatabase ==>
  type LDBDatabase struct {
      fn string      // filename for reporting
      db *leveldb.DB // LevelDB instance

      getTimer       gometrics.Timer // Timer for measuring the database get request counts and latencies
      putTimer       gometrics.Timer // Timer for measuring the database put request counts and latencies
      delTimer       gometrics.Timer // Timer for measuring the database delete request counts and latencies
      missMeter      gometrics.Meter // Meter for measuring the missed database get requests
      readMeter      gometrics.Meter // Meter for measuring the database get request data usage
      writeMeter     gometrics.Meter // Meter for measuring the database put request data usage
      compTimeMeter  gometrics.Meter // Meter for measuring the total time spent in database compaction
      compReadMeter  gometrics.Meter // Meter for measuring the data read during compaction
      compWriteMeter gometrics.Meter // Meter for measuring the data written during compaction

      quitLock sync.Mutex      // Mutex protecting the quit channel access
      quitChan chan chan error // Quit channel to stop the metrics collection before closing the database

      log log.Logger // Contextual logger tracking the database path
  }

  // Database wraps access to tries and contract code.   //==> Implied by cachingDB ==>
  type (state.)Database interface {                      type cachingD  struct {
      // Accessing tries:                                    db            ethdb.Database
      // OpenTrie opens the main account trie.               mu            sync.Mutex
      // OpenStorageTrie opens the storage trie              pastTries     []*trie.SecureTrie
      // of an account.                                      codeSizeCache *lru.Cache
      OpenTrie(root common.Hash) (Trie, error)           }
      OpenStorageTrie(addrHash, root common.Hash)
         (Trie, error)
      // Accessing contract code:
      ContractCode(addrHash, codeHash common.Hash)
         ([]byte, error)
      ContractCodeSize(addrHash, codeHash common.Hash)
         (int, error)
      // CopyTrie returns an independent copy of
      // the given trie.
      CopyTrie(Trie) Trie
  }

  // Trie is a Ethereum Merkle Trie.           //==> Implied by odrTrie, SecureTrie, Trie,
  type Trie interface {                        // but implied by cachedTrie in this place.==>
      TryGet(key []byte) ([]byte, error)       // cachedTrie inserts its trie into a cachingDB
      TryUpdate(key, value []byte) error       // on commit.
      TryDelete(key []byte) error              type cachedTrie struct {
      CommitTo(trie.DatabaseWriter)                *trie.SecureTrie
         (common.Hash, error)                      db *cachingDB
      Hash() common.Hash                       }
      NodeIterator(startKey []byte)
          trie.NodeIterator
      GetKey([]byte) []byte // TODO(fjl):
               // remove this when SecureTrie
               // is removed
  }
[[}]]

• Geth (JS cli) Console: [[{evm.implementation.geth,devops.geth]]
@[https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console]
  $ geth attach \
        --preload "script1.js,..."     <- opt: preload CSV script list
        --exec  " eth.blockNumber "    <- batch mode
          http://123.123.123.123:8545

  - Example script: EXAMINE TX.
    TX_ID ='0xaeb..b49'
    web3.eth.getTransaction(TX_ID , (err, result) {
         if (err) { console.log(e); return; }
         console.log(JSON.stringify(result);
    });
  - Example script: CHECK ACCOUNT BALANCE/S
    loadScript ("gethPreload.js")
    checkAllBalances()

    function   checkAllBalances()  {
      var totalBal = 0;
      for (var acctNum in eth.accounts) {
        const acct = eth.accounts[acctNum];
        const acctBal = web3.fromWei( eth.getBalance(acct), "ether");
        totalBal += parseFloat(acctBal);
        console.log( acct + " balance: " + acctBal + " ether");
      }
    };
[[}]]

• GETH: Configuration Troubleshooting [[{evm.implementation.geth,13_SLC.troubleshooting]]
  REF: @[https://web3js.readthedocs.io/en/1.0/index.html] Full 1.0 API

  console.dir(eth) does NOT work but all that needed is enter the object name in the prompt

> eth                                > web3
  {                                    {
    accounts: [...],                     admin: {
    blockNumber: ...,                      datadir: ".../qdata/dd1",
    coinbase: "0xed9....",                 nodeInfo: { enode: ..., },
    compile: {                             peers: [ ... ],
      lll: function(),                     ...
      serpent: function(),               },
      solidity: function()               eth: {
    },                                     accounts: [...],
    pendingTransactions: [],               blockNumber: 5,
    protocolVersion: "0x3e",               coinbase: "0x ...",
    syncing: false,                        ...
    getAccounts: function(callback),     },
    getBalance: function(),              isIBAN: undefined,
    getBlock: function(),                ...
    ...                                }
  }
[[}]]

• GETH Disk Space [[{persistence.blockchain,infrastructure.storage,devops.storage]]
- Sync Mode:
  @[https://medium.com/coinmonks/how-a-pruned-ethereum-node-can-fully-verify-the-blockchain-bbe9f29663ed]
  @[https://github.com/ethereum/go-ethereum/pull/1889]

     Mode      2020
     Archive ~ 1.5TB -Contains state at all given blocks.
     Prune   ~ 0.2TB -Contains all events and just last state.
                      After synced, the node will continue to
                      work in Archive mode. It's recomended then
                      to resyn every ~6 months to save space unless
                      archive of old states are needed.

REF:
@[https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs/826#826]
Last Update: May 14th, 2018 / Block ~ 5_600_000
Geth (Go) 1.8.3 Ubuntu 16.4 LTS,  VPS + SSD | Parity (Rust)
--------------------------------------------+--------------------------------------------
Client / Mode    | Block Number |Disk Space | Client / Mode      |Block Number|Disk Space
=================|==============|========== | ===================|============|==========
geth light       | 5_600_000    |363M       | parity light       |5_600_000   | 89M
geth fast full   | 5_600_000    |142G       | parity warp fast   |5_600_000   | 82G
geth full full   | ?_???_??? [1]|239G + [1] | parity full fast   |5_600_000   | 78G
geth full archive| 4_980_000 [2]|671G       | parity full archive|5_600_000   |1.1T
                                            |
[1] disk was full, I wasn't able to repeat  |
    this sync mode                          |
[2] I didn't manage to fully sync           |
    within 6 weeks, unfortunately.          |
--------------------------------------------+--------------------------------------------
Update 2019-08-08:
zation of a quadratic CPU and disk IO complexity,
REF: @[https://blog.ethereum.org/2019/07/10/geth-v1-9-0/]
"""We've run a fast sync benchmark on two i3.2xlarge AWS EC2 instances
   (8 core, 61 GiB RAM, 1.9 TiB NVMe SSD) with --cache=4096 --maxpeers=50
   (defaults on v1.9.0) on the 25th of April."""

 FAST SYNC
     Version          Sync time   Disk size   Disk reads  Disk writes
     Geth v1.8.27       11h 20m      176GiB      1.58TiB      1.94TiB
     Geth v1.9.0          4h 8m      131GiB      0.91TiB      1.06TiB
---------------------------------------------------------------------
 FULL SYNC
     Version          Sync time   Disk size   Disk reads  Disk writes
     Geth v1.8.27    6d 15h 30m      341GiB      28.9TiB      21.8TiB
     Geth v1.9.0     6d  8h  7m      303GiB      40.2Ti       32.6TiB*

"""... reducing the memory use by about 1/3rd  and
       completely removing spurious memory peaks (Shanghai DoS) .
    The reason for the higher disk IO is due to using less memory
    for caching, having to push more aggressively to disk."""

 ARCHIVE SYNC
- archive sync benchmark
  - two m5.2xlarge AWS EC2 instances (8 core, 32 GiB RAM, 3TiB EBS SSD)
    with --cache=4096 --syncmode=full --gcmode=archive.

    Version       Sync time   Disk size   Disk reads  Disk writes
    Geth v1.8.27     62d 4h     2.57TiB     69.29TiB     49.03TiB
    Geth v1.9.0     13d 19h*    2.32TiB    104.73TiB     91.40TiB

  EBS volumes are significantly slower than physical SSDs
  attached to the VM. Better performance can be achieved
  on VMs with real SSDs or actual physical hardware.
[[}]]

• GETH: Monitoring & Metrics [[{evm.implementation.geth,devops,13_SLC.monitoring]]
@[https://github.com/ethereum/go-ethereum/wiki/Metrics-and-Monitoring]

> debug.metrics().p2p.InboundTraffic         > debug.metrics().chain.inserts
{                                            {
  Avg01Min: '169.12K (2.82K/s)',               Avg01Min: '10 (0.17/s)',
  Avg05Min: '1.92M (6.42K/s)',                 Avg05Min: '61 (0.20/s)',
  Avg15Min: '3.57M (3.96K/s)',                 Avg15Min: '168 (0.19/s)',
  Total: '5.83M (2.97K/s)'                     Maximum: '2.157261657s',
}                                              Minimum: '2.271716ms',
                                               Percentiles: {
> debug.metrics(true).p2p.InboundTraffic         20: '6.993756ms',
{                                                50: '12.342836ms',
  AvgRate01Min: 1599.6190029292586,              80: '21.765944ms',
  AvgRate05Min: 5367.754506658111,               95: '218.500479ms',
  AvgRate15Min: 3761.057607521597,               99: '376.015984ms'
  MeanRate: 2907.3919382272857,                },
  Total: 5901154                               Total: '432 (0.22/s)'
}                                           }

$ geth monitor  ← periodically queries a node for
                  metrics and plots them on the terminal

$ geth monitor [--attach=api-url] metric1 metric2 ... metricN
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Ex metrics:
        system/memory/allocs/AvgRate05Min        ← Full canonical metric
        system/memory/allocs                     ← Group of metrics
        system/memory                            ← Group of metrics
        system/memory/allocs,frees/AvgRate01Min  ← Multiple branching metrics
        system/memory/*/AvgRate01Min             ← wildard pattern   (Not supported by planned)
        system/memory/allocs/!AvgRate01Min       ← Exclusion pattern (Not supported by planned)

Available metrics (use geth monitor for full list)
    system/memory/
        allocs: number of memory allocations made
        frees: number of memory releases made
        inuse: memory currently being used
        pauses: time spent in the garbage collector
[[}]]

• GETH What's new [[{evm.implementation.geth,devops,integration.graphql,10_EVM.i/o,13_SLC.monitoring]]
  - 1.9 Release Notes @[https://blog.ethereum.org/2019/07/10/geth-v1-9-0/]
  Release page      : @[https://github.com/ethereum/go-ethereum/releases/tag/v1.9.0]

  - Performance Improvements.

  - Allow separated database into two parts:
    - Recent blocks, stored in fast key-val LevelDB, Ideal to put on SSD [[{devops.storage]]
    - older "stuff", infrequent access. HDD should be "OK"  
      Use --datadir.ancient to move outside chaindata ("SSD" disk)  [[}]]
    - Ex: A fresh fast sync at block 7.77M placed
      - 60GB of data into LevelDB
      - 79GB of data into the freezer
  
  - GraphQL support (--graphql CLI flag): [[{integration.graphql]]
    - Support for flexible queries (INNER JOINS) in a single round trip.
    - Ex: find all the ENS domain registrations on the Görli testnet!
      STEP 1) Start Geth v1.9.0 on Görli with GraphQL enabled
      $ geth --goerli --graphql  ← should sync in 1-2 minutes tops
  
      STEP 2) point browser to BUILT-IN GraphQL explorer http://localhost:8547

      STEP 3) sample query: find ENS HashRegistered events.
              returns address-of-user doing the registration, 
              block number and timestamp:
      {
        logs(                                ← "SELECT FROM  logs INNER JOIN address ON ... "
          filter: {                          ←   "WHERE"
            fromBlock: 0,                    ←     "BLOCK > 0 AND"
            addresses: ["0xf105....62"],     ←     "ADDRESSES IN (${ENS_CONTRACT}) AND "
            topics   : [ ["0x0f0...670"] ]   ←     "TOPICS    IN (HashRegistered) "
          }                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
        {
          transaction {                      ← RETURN:
            hash
            from {
              address                        ← + address of the user doing the registration
            }
            block{
              number                         ← + block number
              timestamp                      ← + timestamp
            }
          }
        }
      }  [[}]]

  - SUPPORTED HARDWARE WALLETS:
   - LEDGER WALLETS
   - TREZOR WALLETS
   - STATUS KEYCARDS
     - full HD hardware wallet based on Java SmartCards [[ dev_framework.java.smartcards]]
  - Added CLEF app:  "wallets everywhere!" as a (eventual) [[{wallet.cloud}]]
    replacement for Geth's account management.
    - standalone signer for the entire Ethereum ecosystem
    - major features:
      - remove account management from "maybe insecure" Geth gateway.
      - Reusable by Geth, Parity, Trinity, Metamask, ...
        - deliberately tiny external API via IPC or HTTP,           
          designed to work with any interface: cli, web, Android, ..
        - Clef exposes an extended internal API solely via standard input/output.
          and JSON-RPC IO streams.
        - pre-built CLI interface
  - new ULTRA LIGHT CLIENT aiming to be (security like) midway       [[consensus]]
    between trusted and light enodes, replacing PoW verification
    with digital signatures from majority-of-trusted enodes:

  - Added support for hard-coded on-chain checkpoint oracle.

   - checkpoint oracle contract is an especially nasty beast:

  - Metrics collection gathering     exposed metrics:
    $ geth ... --metrics --pprof   ← http://127.0.0.1:6060/debug/metrics
    (pull based monitoring)          ( expva   -Go ecosystem friendly format)
                                     http://127.0.0.1:6060/debug/metrics/prometheus
                                     (prometheus friendly format)
  
    $ geth ...              + "set of --metrics.influxdb subflags"
    (push based monitoring)   (server, ddbb, user/password, ...)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                              see the METRICS AND STATS OPTIONS section
                              of geth help for details

  - METRICS VISUALIZATION: [[{devops.monitoring]]
    You can import next grafana dashboard:
    (
    cat << EOF
H4sIAIdjTF0AA+1dW3PbNhZ+z6/gsN2dNuO4omzZ1s5kdhInadomrbd2+9JkNBAJSagpkiFBX+rx
f18AvAAkQOpCkZIV5EGxAArngnP5DgiCD88MwxyNkBfEODL/Y/xFvhvGA/skPR6YQ9JqvrkcXfz+
28e3V+/f/nFpHmTdLhhDl/YHoT+HeAbjiHc6MLJDFGDke/QS3oHvAzaoAzCI/Di0Ie8L3HiKvJ+c
qkGT/l9Tti74FeyCR/L5+SARKYRfYhRChVAZ/WkIJsADfHDkKJszJfxY7riBYZRKd3LYP+ynTByo
yQXAI8qSiQUzJSmxWSBUT0OlUlSpTE9Wo4qkddg77K0hW4S8qQsjDLBM8lLRJ0uZTyfwPJ9cS3rp
fCbkTRdFOJ9dzhTpGcfIxT/RkawD3iooh5B48cJIJ9R48cIULoMeGLv0EhzGUGifIUfRimzfO/dd
P6RjhtMx+K53YPQti3wMBgeG9b04dCb9Ky6O8W/jlQtDHInX8emMZmMfhI6Z9j2y/z8/S2fChA7C
JW7NqQcxcyAvdt2khVrTle+7GAWkvccaUeEShGEIUle1Bic966R/2rMGx8m1LvKumSMls8FmW+FY
tu+6IIggHXkC3CjXE+EAORc+n7tEoaX5uSXf+8dCw13GbPr9nn7PNFE0trM+DxE5d595yEHYTezu
PsJwLsei0L9VWzhwEYjYBDPuOdkxYC1FOemEfYDeFDPZeoV2qLpctMhvHwph9pFzOUGuKyqrWp8n
JX2eLVCnpVan1csHMl04hZ5TJEW0MvVeRVep7RWkot03U0WrHYch9LCiZw7uVK3IU7SGaDrDl4kv
lvuimX8ruygmvuYqrr4BbswnRVIEMXrWK47GGm+Rgwu2W/IP1kQ968JHHv7oM1ZZA59RP8iDGacY
QGIJHgZTSTYzoEOFwEEx/c2g2C4bFtGzA0PIgtLE9YUgG8EQweg3EmuJCcES01EAbKiyXxKo7WuJ
CnGlIIDOB6ITqQ+DcAoFSEH/cQOioesuYOxFzCNHdhCPyJ+uDxwhElLb98M5oEZDnHgORwn/xUuI
CmBIZvMdsDELxFahOzHgd/k4UTEGpAqbJKDjlZk3Px6swvktQLhtzpEvU8k5f70W5wQX2F0onRjD
rILxc4Hx9C8hcs8Ihpv5riNF9Dl8R3CLkMTy9t/hNHWu0g8uZ2iC5V+kueH84g8hMeTpUgh70QyE
LLuVIkzkh7gUXFlwGWXpBXkOukFOTOKQFGcEOCpivjtwh0oBfhzb14lPiQLQSJnGGCqjAm+UrlZH
yTwa/vVZYvEe3MEaV+bWkkaw4kRnVUKRDdrhT1+DCEq2k6QD6fIkH0jNgjgLHYBzSn4V7gCfkr3f
y9POkq0qy9L2D/AmZ7oAEvccyIjfa4DMmcYxGsd0gmNI+QS/SxPrHM798H4EXNe3o7+s+efv206v
jNTGIE3Kf0xLuZYZl2k0ADQp3zPots63TGPn8MxHpg0NaZpBmvE9LpuKBjTVfGpAsyagscQL6hAN
T5oa0WhE0xGicVB0PQohcFg47ATSUGrNEY0kxG2IMOxOCkZuCYCzTaDwhuhFw4RmMOF1oEHCDoKE
Lm5JnaoT9amQC+puSf0K8a0fig645/ekrP4ChZ6pFTpcaS2n5OQJ8Ck1ctxT6khsvNzILLzUKIKe
cmxcD/MIrqIhzzYgT9APRsibkvTbDURIaTVfBcm5h90xD+t435WVkKsQTCbI1hhHY5w9xDj7BgcK
DTV44PRU4wGNB1rFAzSZBhCGUdtpVEFk7dUOyrSDiMCdAABGaYPYhbB009HaTEJqx7HLRcEyNHJZ
C7l4vge3Dwk0dNnG8ox1rIYP+e/ql2deu759bc8A0Z/kGpUrNDawZ/CKWL0fS55tU6T2mqSsaejH
niw56/+TWr26q2jw5jf94dA+PhHdi21D7x+dHhAoNTwwjnsHRu/wbFjYiv6Nc3wMjoApzXWF05hT
ELPUL0wHMbWMT6snqp0YW9YhNqfGVjaZPJh+oLYu4QXxio8gvIZhJSqqNJp+yWiOFtnMQG0zVu+M
N6TJpjy/Crw1B0FAqvyrxGwsVXtNGMueGmCR0MC+geFdKUrcZNOwMNhkg4XAmy4YrF8TEcjUvyGV
wUWG8IT5l9Gl7XsetLGw0YNdc0Upl5Snhp5+hCeIzpPwFFHa+M73CNz+h9EZ9P4l9JNMLv2GtVX+
hOnkI4lHNSklSe5FwMx6cCKN+esPr0odfv6DGoUSdBteuwlYFYyXllXFx0uOLOLW1hn5OBtSv7bO
Cn49iV1VNUFHFsdJhumTyGANjwoDiE4qYwJaTJFx4nn5ma5lETWLpKMZBA77IFXAhkGeEjbXAzhR
jhoAV4/TPhAAG2GjJFSeKlQPQzFHE63xTLRG1ltvjT7FgebLJQ0x8+uFtsguzJ6xy2piZZ5bbemh
LiuuuCyx/nLDsBT6xVRQG/oFppTLDS3urPhadk/0i+1Peumg9UAn70iUqayzhiAwHkIboqD1x1qU
ZNZZRBBYH1PY3jbjCiI7t35wTnXC0pJeRGi2iLAj1XmFD+wcn5LRt7eKoKvtJ1VtSzd4qjHXEW/Q
5bYut3mPLreXQqH4LiC5fhQQ2EIsf19q7bd30I6ZckhkAl5EuGNmLMEOXXXvaNVtDYSG+hSwYNef
Lrsr4/jXWHa3G/Ck3W95IGped6ecf4lh3P5jl1NAVd284k6ZJnUwcNvmWUFk56rtK56ODKoZXXPr
mlvX3Lrm3nrNLd3hrnhqxbI4DtElty65hR5dcq9646el+ydbvsVdlmrPq22d6Z5WppNXlytTHd8C
qFOdTnVCj051qyy2tLNksa0s9yNbGvkqF5Z1qntaqU4q6oYVma435A060+lMx3t0plu1qGtlZ9mW
S7qiTDrL6SyXT8z2s5xc0FWlOX5XWac5neZ0mls5zbV5O3drKY4K81WWc09gn5C4L2ipp3n7VW+s
4VlCnwaSN37Fe4sKutjgEz3Jlh+ikYcvMfAwcuHLT+a32d+fzMdNx031niO6weS7Ly9zwqXDMtZ/
8IcwghywUQFnyjOBiyDNbKQTzvRSSln5kSJ2imt3+lhSatufzxFeSuLzVSUGtk0KIMzO/I22Zeop
EwZlYikx36wrZhw4tBLetqAJG0uJ+nZdUWcsZ29bUsbFUoK+W1fQxD22LukKXvrjqqJGhBGSg7fr
pSkTy3vp+3XF3LKXZoKu4KU/rSvqdr00k3R5L/15XUG37KWZpCt46S87steYnUxk0Bf4wSgSN7vr
vcbrHRKmTzddmk/J7nfkdNOnsYhxVPEWY8vSR5rqRQxhEaOtI87TdV5WNndy1CajtEQ+XQAdROaR
1x37Ka3mayyiADG1mSBENlxTiPbXVQQWmy+liLKnz+fRV/LYIGxL/pWf4jNSfpqvoqiEDWHgEofv
5lx+LlNKtvmSiVIm0uYiAp07lyoj3Hx9RCWX50+I8Xf0DgUuVUq2+VKIKFOyP3M3fC158HSBn62w
DqKQs5GbbVjOet9bYSFEJWcz19u0pAv8cYWVEIWsjdxxw5LW++jPO7I6UHgSOfQDMGX3R/QigT5J
fB+XCbo4Sfyoat8Zr9prjxKne7LGVNOSZ+zrq97KL7kta/S4YiHkaMFLbvWhL4Z+TUsJMEA8Gznj
Ebu7QC2bv7O2ExDv0kjljI2a19auWiurJWJ7EToVqe4dtquufUgyAc9GMN1o0IlUKcG6iVq1zq8U
qru5yqSqm6s3OwJNaR5k9YIGo/qFfHuIRfcMtInf60Ab3feuUZtGbcuitmrA9rSwWg1Me2IIrRac
PS1cVg/JNBrjaOyS7h7yPYMFS/2mwYaQzIH2+B6XzUfjsmo+NS5bE5dZ4gX1wIwf/7DEtiJJyS3i
NnFvkcZ0+4rpIvoEZTdQqAU4lyGHLqRIaS0B5bYKGdJN0wWNaMCgAUMnfHYHGLq4qXh8ok7aR0ve
VLwiMce4xAArHmvf19uKhRNBlEqtOvKxr1/iqOHMqpulCVOjOZyzZwtGtguB1+Bu1aY2I80qd1qt
vEtVIV+DG1ebEnCOoqo9Vq93BAedU10ZTG8aBulbWXuIgPYNKEhniVUhhYF+7ZQGCo2AwtRmKwZb
3rJstwISJm4czXZAPJ9YALGM2009nFREQuyR8AZSrnWcy44v/bxBIb7XkEdDnv2BPM/SYamzUT+i
Ulu9ZG7MiBj6HPwJQ3qPlAp2ljTj+8QfHBAmB+eSXDHl3mRiOA9cgOmxDBmPJMFGWDCMAududiar
WXy8VbRQDi8ehHlbFkbRK+EEeQgnkpgPf/vjl59MkuBmxYM2svAsYiXk2W7swFcMiZW8IbMH8+ru
grB+To+9oQfBik4XkwAh/zI77xTfjZjQtuKnHGTwQEWav8QwvK8Xg89nv9A6hezk0R8On6dPGR0+
//7h8Pl/P5mHz38QB4iuUfBH6F7ee7YKp8mBjNgAm8fofxl3ZrFXEoO2qS9OI10ip9ARR/AqGUiJ
+NRWVYpqgiUVPA+6yUmw5Yky+MGVVM/FcJCfXMm6VKFloUFJB6IqI0xuReXLMzMillBhOQK/osT1
MtdJXS03D1ZCuBINtjTWAivL7MCOI0wy+SanW2GPgsi9w+GgYqJZV91E91qe6OyIniazLYHPguyD
ytmmfeJkH2yA2mkdudN16NXYsjSx1VO7IfGGwzp6wxbo1RNsheICksMVIgQxMXp49Cn7HCafw+Qz
+2/YOIKw/yl8fUwAC5rz0635Sdr+7YvBPKWVHZad3FXiPwsQgdoh/3Gad0dZ/SP6pDkQ7lNlKIt9
ORK/WHP+90D42xK/HPXEHqEc6At/W04i8edMBlqtybGimoo48Ik4sEilfyx+EY5SP3VEfjNeCur7
x2crD2YKI/P3EJE0YVyQeSD/wziFozFKDgK4CP5+f/IepdDzJoen/ZNnj8/+D27JWX7VxQAA
EOF
    ) | base64 -d | gzip -d [[}]]

 - New list of pre-hardcoded boot nodes for Mainnet.
   enode://d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666@18.138.108.67:30303 (Singapore, AWS)
   enode://22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de@3.209.45.79:30303 (Virginia, AWS)
   enode://ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758@34.255.23.113:30303 (Ireland, AWS)
   enode://279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8@35.158.244.151:30303 (Frankfurt, AWS)
   enode://8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a@52.187.207.27:30303 Australia, Azure)
   enode://103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1@191.234.162.198:30303 (Brazil, Azure)
   enode://715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8@52.231.165.108:30303 (South Korea, Azure)
   enode://5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f@104.42.217.25:30303 (West US, Azure)
[[}]]

● EEA Summary [[{standards.eea,scalability.consensus,scalability.offchain,integration,00_PM.ext_resource]]
- External resources:
  - @[https://entethalliance.org/]
  - @[https://github.com/EntEthAlliance/]
  - @[https://entethalliance.org/technical-documents/]
    - EEA Client Spec
    - EEA Off-Chain Trusted Compute Spec
    - EEA Architecture Stack
    - ....
  - Collaboration  : @[https://member.entethalliance.org/communities-all-members60/librarydocuments
  • Youtube Channel: https://www.youtube.com/channel/UClC49LtcE4Wuo4POqa4J0bA


- [P]SMRT-030:Enterprise Ethereum clients MUST support
     smart contracts of at least 24,576bytes in size
- [P]SMRT-040:Enterprise Ethereum clients MUST read and enforce a size limit
     for smartcontracts from the current network configuration (e.g. the genesis
     block).
- [P]SMRT-050: If no contract size limit is specified in a genesis block,
     subsequent hard fork blockor network configuration, Enterprise Ethereum
     clients MUST enforce a size limit on smartcontracts of 24,576 bytes.
  
  - Permissioning is the property of a system that ensures operations are
    executed by and accessible todesignated parties. For Enterprise Ethereum,
    permissioning refers to:
    - the ability of a node to join an Enterprise Ethereum blockchain
    - the ability of individual accounts or nodes to perform
      specific functions.
    - Ex: an Enterprise Ethereum blockchain might only allow certain nodes
      to act as validators, and only certain accounts to instantiate smart
      contracts.Enterprise Ethereum provides a permissioned implementation
      of Ethereum supporting peer nodeconnectivity permissioning,
      account permissioning, and transaction type permission.
  
  7.1.1 Nodes:
    [C] NODE-010:Enterprise Ethereum implementations MUST provide the ability
        to specify atstartup a list of static peer nodes to establish
        peer-to-peer connections with.
    [C] NODE-020:Enterprise Ethereum clients MUST provide the ability to enable
        or disable peer-to-peer node discovery.
    [P] NODE-030:Enterprise Ethereum clients MUST provide the ability to specify
        a whitelist of thenodes permitted to connect to a node.
    [P] NODE-040:Enterprise Ethereum clients MAY provide the ability to specify
        a blacklist of thenodes not permitted to connect to a node.7.1 Permissions
        and Credentials Sublayer
    [P] NODE-050: It MUST be possible to specify the node whitelist required by
        NODE-030 througha transaction into a smart contract.
    [P] NODE-060: It MUST be possible to specify the node blacklist allowed by
        NODE-040 (ifimplemented) through a transaction into a smart contract.
    [P] NODE-080:Enterprise Ethereum clients MUST provide the ability to specify
        node identities ina way aligned with the concept of groups.
    [P] NODE-090:Enterprise Ethereum clients MUST document which metadata parameters
        (if any)can affect transaction ordering, and what the effects are.


- EEA Net Protocol Sublayer: (enodes, ...) [[{10_EVM.implementation,devops,architecture]]
- Nodes MUST be identified and advertised using the Ethereum enode URL format
  https://github.com/ethereum/wiki/wiki/enode-url-format  [[101]]
- Implementations SHOULD use the DEVp2p Wire Protocol for messaging between 
  nodes to establish and maintain a communications channel for use by higher
  layer protocols.
  REF: https://github.com/ethereum/wiki/wiki/%C3%90%CE%9EVp2p-Wire-Protocol

- These higher layer protocols are known as capability protocols

- The Ethereum-Wire-Protocol defines the capability protocols for messaging
  between Ethereum client nodes to exchange status, including block and TX info.
  https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol

- messages are sent and received over an already
  established DEVp2p connection between nodes.

- Implementations SHOULD support, at a minimum,
  Ethereum-Wire-Protocols eth/62 and eth/63

- Implementations MAY add new protocols or extend
  existing Ethereum protocols

- To minimize the number of point -to-point connections
  needed between private nodes , some private nodes
  SHOULD be capable of relaying private TX data to
  multiple other private nodes.

• EEA Design Considerations:
  - Private contracts cannot update public contracts. [[privacy]]
    (not all participants will be able to execute a private contract,
    and so if that contract can update a public contract, then each
    participant will end up with a different state for the public contract.
  - Once a contract has been made public, it can't later be made private.
    You DO need to delete from the blockchain and create a new private contract

• EEA Supported Consensus:
- Probe of Authority (PoA):
  @[https://github.com/ethereum/EIPs/issues/225]
  @[https://github.com/ethereum/go-ethereum/blob/master/consensus/clique/clique.go]
  @[https://github.com/NethermindEth/nethermind/tree/master/src/Nethermind/Nethermind.Clique]
  @[https://github.com/hyperledger/besu/tree/master/consensus/clique/src/main/java/org/hyperledger/besu/consensus/clique]
  - TestNet:
  @[https://github.com/goerli/testnet]  @[https://goerli.net/]
  """Görli Testnet is the first proof-of-authority cross-client testnet,
     synching Parity Ethereum, Geth, Nethermind,
     Besu, and EthereumJS."""
- RAFT: https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md
  NON  BYZANTINE FAULT TOLERANCE with next advantages:
  - faster blocktimes (milliseconds vs seconds)
  - absence of forking
  - Compared with QuorumChain, does NOT "unnecessarily" create empty blocks
  +-----------+----------------+-------------------------------------------------+
  |Transport  | Ethereum p2p   |  Raft (over HTTP)                               |
  |Layer      |                |                                                 |
  +-----------+----------------+-------------------------------------------------+
  |DATA TYPE  | communicate TXs|  communicate full blocks                        |
  +-----------+----------------+-------------------------------------------------+
  |config     |                | Minting blocks frequency:  < = 50ms ,           |
  |params     |                |    (--raftblocktime (millisecs)                 |
  |           |                | --raftport newTCPPort default to 50400 )        |
  |           |                |                                                 |
  |           |                |  static-nodes.json: required                    |
  |           |                |  - initial list of nodes in the cluster         |
  |           |                |  - order  MUST BE EQUALS ACROSS PEERS           |
  |           |                |                                                 |
  |           |                | - ID URIs must include a raftport querystring   |
  |           |                |   param specifying the raft port for each peer: |
  |           |                |   e.g.                                          |
  |           |                |    enode://abcd@127.0.0.1:30400?raftport=50400  |
  +-----------+----------------+-------------------------------------------------+

- IBFT: (Istambul) Bizantine Fault Tolerant
[[}]]
• EEA TX Manager: [[{standards.eea,consensus.eea,privacy.private_tx]]
  - Quorum’s Transaction Manager is responsible for Transaction privacy.
     It stores and allows access to encrypted transaction data, exchanges encrypted
     payloads with other participant's Transaction Managers but does not have
     access to any sensitive private keys. It utilizes the Enclave for
     cryptographic functionality (although the Enclave can optionally be
     hosted by the Transaction Manager itself.)

  - """To send a private transaction, a PrivateTransactionManager must be
     configured. This is the service which transfers private payloads to
     their intended recipients, performing encryption and related operations
     in the process."""
  - The Transaction Manager is restful/stateless and can be load balanced easily.

<a href='https://github.com/jpmorganchase/quorum/wiki/Transaction-Processing'>Transaction Processing</a>
  - 'Public Transactions' and 'Private Transactions' are a notional concept
    only and Quorum does not introduce new Transaction Types, but rather, the
    Ethereum Transaction Model has been extended to include an optional
    '  privateFo  ' parameter (the population of which results in a Transaction
    being treated as private by Quorum) and the Transaction Type has a new
    IsPrivate method to identify such Transactions.
  -   privateFo   can take multiple addresses in a comma separated list.
  - Private Transactions payload is only visible to the network
    participants specified in the   privateFo   parameter of the TX.
  - Quorum Node sets the Transaction_Signature.V = 37 or 38
    (as opposed to 27 or 28)

  - prior to propagate the TX to the rest of the network,
    mining/sender node replaces the original TX-Payload with
    a the hash of the encrypted Payload that received from the
    secure enclave implementation (Crux, Constellation,..).
    Participants involved in the   privateFo   TX
    will have the encrypted payload associated to the hash
    within their secure enclave.

  Example priv.TX A←→B:<span bgorange>
Party A and B belongs to TX AB, whilst C doesn't
Party A → A.Node: TX + payload
                TX.  privateFo   [ pub.key A, pub.keyB]
A.Node → A TX Manager: Request to store TX payload
A_TX_Manager → Enclave: - Validate sender with A priv.key

Enclave → Enclave:  performs TX conversion (encrypt payload)
                    - generating [sym.key, random Nonce]
                    - encrypting TX.payload+Nonce with sym.key
                    - generate hash  SHA3-512 (encrypted payload)
                    - iterate through TX recipients [A, B] encrypting
                      sym.key with recipient's pub.key (PGP encryption)
A_TX_Manager ← Enclave: encrypted payload, SHA3-512 hash, encrypted keys
A_TX_Manager → A_TX_Manager: store encrypted payload, encrypted sym.key
                             (using hash as index)
A_TX_Manager → B_TX_Manager: (via HTTPS) hash, encrypted (payload, sym.key)
A_TX_Manager ← B_TX_Manager: Ack
A.Node ←  A_TX_Manager: SHA3-512 (encrypted payload)
A.Node →  A.Node: - Replace TX.payload with TX.sha3-512
                  - changes TX.V to 37 or 38 (indicates other nodes that
                    hash represents priv.TX)
A_TX_Manager → Network:  (Ethereum P2P protocol) TX encrypted payload
Network → Network: +block containing TX AB
Network → Node N: block containing TX AB
Node N → Node N: Try validate TX in block
                 - Recognise TX.V is 37 or 38
Node N → Node N TX_Manager: Do nodes holds private TX?
Node N ← Node N TX_Manager: YES  (continue validation)
                         or "NotARecipient" (skip to next TX in block)
A,B Node → A,B enclave: TX payload
           A,B enclave: 1. validates signature
                        2. decrypts sym.key  private key that is held
                           in The Enclave, decrypts the Transaction Payload using
                           the now-revealed symmetric key and returns the decrypted
                           payload to the Transaction Manager.
A,B TX_Manager → A,B EVM: send decrypted payload
A,B EVM → A,B EVM: contract code execution
                   Update Quorum Node's Private StateDB only.
                   NOTE: code discarded once executed.
[[}]]

• EEA Secure Enclave [[{standards.eea,privacy.private_tx]]
 - Distributed Ledger protocols typically leverage cryptographic techniques
   for transaction authenticity, participant authentication, and historical
   data preservation (i.e. through a chain of cryptographically hashed data
   .) In order to achieve a separation of concerns, as well as to provide
   performance improvements through parallelization of certain crypto-
   operations, much of the cryptographic work including symmetric key
   generation and data encryption/decryption is delegated to the Enclave.
 - The Enclave works hand in hand with the Transaction Manager to
   strengthen privacy by managing the encryption/decryption in an isolated
   way. It holds private keys and is essentially a “virtual HSM” isolated
   from other components.
 - Different implementations of the enclave exists:
   - Constellation: Original, writen in Haskell
   - Crux         : Golang based, compatible with Constellation


 - JS client privateFor ex.: [[dev_framework.js]]
   "privateFor": indicates the list of Tessera (vs Ethereum) public keys
                 of TX recipient. If not empty the TX will be private.
   web3.eth.defaultAccount = eth.accounts[0];
   var simpleSource = 'contract simplestorage { ... }'
   var simpleCompiled = web3.eth.compile.solidity(simpleSource);
   var simpleRoot = Object.keys(simpleCompiled)[0];
   var simpleContract = web3.eth.contract(
       simpleCompiled[simpleRoot].info.abiDefinition);
   var simple = simpleContract.new(42,
       {from:web3.eth.accounts[0],
        data: simpleCompiled[simpleRoot].code,
        gas: 300000,
        privateFor: ["ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc="]
       }, function(e, contract) {
         if (e) { throw("err creating contract", e); }
         if (!contract.address) {
           console.log(contract.transactionHash + " mining...");
           return;
         }
         console.log("Contract Address: " + contract.address);
       });
[[}]]

• EEA Plugable EVM spec: [[{standards.eea,architecture]]
@[https://ethereum.github.io/evmc/]
@[https://github.com/ethereum/evmc]

- Allows to "plug-in" different EVM implementations.

- The EVMC is the low-level ABI between Ethereum Virtual Machines (EVMs) and
  Ethereum Clients. On the EVM side it supports classic EVM1 and ewasm. On the
  Client-side it defines the interface for EVM implementations to access
  Ethereum environment and state.

- It's currently used by the evmone project. (@[https://github.com/chfast/evmone])
  Potentially
  A Java-to-Native (JNI) wrapper looks to exists:
@[https://github.com/semuxproject/evmc-jni]
  See also:
@[https://github.com/jnr/jnr-ffi]
  - Java library for loading native libraries without writing JNI code by hand

- evmONE: 100x faster EVM implementation !!! [[scalability.evm]]
-@[https://github.com/ewasm/benchmarking]
[[}]]

• Caliper blockchain performance benchmark: [[{13_SLC.profiling,20_QA,00_PM.TODO]]
  @[https://github.com/hyperledger/caliper] with support for:
  - test different blockchain solutions with predefined use cases,
    and get a set of performance test results.
    Currently supported blockchain solutions:
    - Hyperledger Fabric v1.X
    - Hyperledger Sawtooth 1.0+
    - Hyperledger Iroha 1.0 beta-3
    - Hyperledger Burrow 1.0
    - Ethereum
    - Hyperledger Besu, utilizing the Ethereum adapter.
    - FISCO BCOS
[[}]]

• EEA enode management HowTo [[{standards.eea,devops.101,infrastructure.network,01_doc_has.diagram]]
  Extracted from https://github.com/ethereum/devp2p/blob/master/rlpx.md#network-formation
  """ (P2P Network) NODE Identity:
     each node is expected to maintain a static  secp256k1 private key
     which is saved and restored between sessions.
     It is recommended that the private key can only be reset manually,
     for example, by deleting a file or database entry.
  
     There are two kinds of connections which can be established.
     A node can connect to:
       ─ a known peer which has previously been connected to
         and from which a corresponding session token is available for
         authenticating the requested connection
       ─ a new peer
  """
- enode uri scheme is used by the Node discovery protocol
- enode uri scheme can be used in the bootnodes command line option
  of the client or as the argument to suggestPeer(nodeURL) function
  in the JSRE.

  C&P from https://github.com/ethereum/wiki/wiki/enode-url-format               
                                                              
  enode://6f8516f6144...0 @10.3.58.6:30303?discport=30301
          └───────┬──···─┘  └───┬───┘                └─┬─┘
                  │          DNS NOT trusted         discovery
                  │          Only IP allowed         UDP port     
  64-bytes/128 hex-digits 
  node ID of the secp256k1 
  public key 
  
• GENERATE PRIVATE KEY AND ENODE ID:

  (REF:@[https://kobl.one/blog/create-full-ethereum-keypair-and-address/])
  STEP 1) Generate private key
  $ openssl ecparam -name secp256k1 -genkey -noout | tee >  nodePrivateKey
  -----BEGIN EC PRIVATE KEY-----
  MHQCAQEEIGLW3b7sUpzhb3I4/sLCbakIjfUz6KuBh3Xaox62beJ3oAcGBSuBBAAK
  oUQDQgAEUarn9mq43dODnfxAVcSksAxHsTbrco9FnV0A7Mzqr6guzCQlCCmgXM7k
  Kns43IkR1JfB8mwKkTfOPdykq9nGIg==
  -----END EC PRIVATE KEY-----

  STEP 2) Show associated public-key in enode format (64 bytes/128 hex digits)
  $ cat  nodePrivateKey | \
    openssl ec -noout -text  | \      <- Display info with public key *1
    grep pub -A 5 | tail -n +2 | \    ┐┌ Convert public key to enode expected format 
    tr -d '\n[:space:]:' | \          ├┘ Output will be similar to:
    sed 's/^04//'                     ┘  067......(128 hex-digits)......8e06 

   *1 Output will be similar to:                       
      Private-Key: (256 bit)                           
      priv:                                            
          00:f4:16:f5:89:3d:60:86:8a:1d:77:4d:2f:74:3b:
          29:53:5b:b9:cb:f9:50:0e:38:39:24:c5:7a:a9:1b:
          b7:d2:b4                                     
      pub:                                             
          04:06:74:34:d5:10:e3:e1:86:a0:39:58:3d:b7:27: <-  Uncompressed Pub. key length must be
          cd:8d:3d:ae:e9:fc:23:8a:6d:54:2e:ca:03:b0:b7:     0x04 prefix + 64 bytes long.
          bc:85:28:df:9b:4d:87:86:61:f3:50:c0:ea:3d:53:
          37:a5:83:1c:94:d8:4e:22:c5:ba:ff:ee:7a:55:e9:
          cb:1f:80:8e:06                               
      ASN1 OID: secp256k1                              

  STEP 3) (Not needed for enode, but can be useful in other configs)
  $ cat   ${publicAddres} | \
    keccak-256sum -x -l | \     Output will be similar to:  
    tr -d ' -' | \              0bed7abd61247635c1973eb38474a2516ed1d884
    tail -c 41                  └─····20 bytes / 40 hex-digits········─┘
 
    WARN!: if final address looks like
    "0xdcc703c0E500B653Ca82273B7BFAd8045D85a470", it means 
    we hashed an empty public key.
    SENDING FUNDS TO THIS ADDRESS WILL LOCK THEM FOREVER!
[[}]]

• PUPPETH [[{devops,00_PM.low_code}]]
  - Easy Geth deployment of networks
  - (Integrated into Geth 1.9+)
  - Creates genesis block, bootnodes, signers, ethstats, faucet, 
    wallet, explorer and dashboard..


● Clef wallet/signer middleware [[{wallet.cloud,security,01_doc_has.diagram,00_PM.TODO]]
@[https://github.com/ethereum/go-ethereum/blob/master/cmd/clef/tutorial.md]
- Sign TX and data (data "==" swap/swarm), designed 
  as an (eventual) replacement for Geth's account management.
- DApps/Middleware can  send data/TX to Clef, which will
  then provide the user with context and asks for permission
  to sign the content.
  If the users grants the signing request, Clef will send the
  signature back to the DApp.
- Programmatic rules for automated (batch) transactions.        [[{architecture.batch]]
  (e.g. Clique signer, Raiden relay, Swarm exchange, etc).
  Clef solves this via an encrypted key-value store and an ingenious
  rule engine! Instead of prompting the user to confirm each and every
  request via a passphrase entry, we can permit Clef to sign on our
  behalf by storing our passphrase in its encrypted database.
  This will only allow passwordless signing, but still needs
  manual confirmation!                                       
  - JS rule file: as requests arrive it decides to 
    auto-confirm, auto-reject, or forward to manual confirm.
    JS rules have access to full request and can also store
    arbitrary data in a key-value store for persistence. Ex:
      function ApproveSignData(req) {
        if (req.address.toLowerCase() == "0xd9....") {
            if (req.messages[0].value.indexOf("bazonk") >= 0) {
                return "Approve"
            }
            return "Reject"
        }
        // ... continue with manual processing
      }
                                                                    [[}]]

REF: @[https://hackmd.io/@ethswarm/SyrP04XdI] (2020-04)
-  looks dead  but some work is happening again
  (https://github.com/ethereum/clef-ui).
- documentation is unclear on what works but testing
  showed it works surprisingly well
- can sign arbirtrary data.
- seems to have quite a few undocumented features
- only allows function signatures from the 4bytes directory
  (swap was not yet there)
-  go-ethereum already has code for using clef as a signer
-  managed to deploy chequebooks and sign cheques :
 @[https://github.com/ralph-pichler/swap-clef-test]
-  Tightly integrated with geth:
   Adding any crypto functions requires modifying the main
   go-ethereum wallet interface:
  - modify keystore backend.
  - modify the hw wallet and smart card backends
[[}]]


● EthSigner wallet/signer middleware: [[{wallet.cloud,security,01_doc_has.diagram]]
REF: @[https://hackmd.io/@ethswarm/SyrP04XdI] (2020-04)
     @[https://docs.ethsigner.pegasys.tech/en/latest/]
- used as signer middleware, replaces eth_sendTransaction 
- does NOT replace eth_signData (and alike).
- hacks for eth_signData seem possible (based on blog posts),
  but even that doesn’t allow arbitrary data
- does not work well with the design of go-ethereum based
  contract interaction.
- primarily for enterprise (Azure Key Vault, Hashicorp,...)

      eth_sendTransaction,    eth_sendRawTransaction,
      eea_sendTransaction     eea_sendRawTransaction
               ·                    ·
               v                    v
  │Dapp│     <····> │EthSigner│ <······> │Ether │
  (Web3j/            Signs TXs           │Client│
  Web3j-eea)           · ^
                       · ·
                       v ·
                    V3 Keystore,
                    Hashicorp Vault,
                    Azure Key Vault,
                    ...
[[}]]

● Privacy layers: [[{standards.eea,privacy.101]]
└ PRIVACY OF PARTICIPANTS:
  Allow for anonymous parties.
  - on-chain cryptographic mechanisms
    like ring signatures, stealth addresses, mixing,
    or storage of private data off-chain.
└ PRIVACY OF DATA:
  keep transactions, balances, SCs, data encrypted 
  on|off-chain, using cryptographic tools like ZKP
  and zk-SNARKS, Pedersen commitments, or off-chain
  privacy layers like TEEs.
  └ Consensys PROJECT UBIN:
    - Public TX validated by the whole network but whose amount,
      asset type,... are shielded.
      "...a consortium of financial institutions used
        zero-knowledge proofs to enable the transfer of digital assets on a
        distributed ledger without revealing information about the balances
        or TX amounts"
    - Project Khokha (South African Reserve Bank "PoC")
      Pedersen commitments are also additively homomorphic, which means that
      for a balance update, network participants can validate that the correct
      update has happened without knowing the opening balance, the closing
      balance, or the transfer amount:
      [[{01_doc_has.comparative]]
      Pedersen commitments and Folklore range proofs to process the typical  
      daily volume of payments for the SARB with full confidentiality and
      finality in less than two hours. These commitment schemes proved to be
      much quicker to validate than the zero-knowledge proofs.
    - Adhara has been exploring substituting range proofs with bullet proofs,
      which are much smaller and quicker to validate. Very simply, instead
      of writing the balances and the transaction amounts in the clear as in
      a normal ERC20 contract, nodes write a proof or a Pedersen commitment
      of the balance.
      [[}]]
└ Public-First + Privacy Layers = Future-Proof
  - Business networks need resilience, interoperability, permissioning,
    and privacy to succeed.

"...These requirements, however, are out of scope for proprietary distributed
ledgers, let alone traditional database technologies. The Ethereum
granular privacy layers and public-first approach make it a powerful
enterprise solution for organizations that need the flexibility of an in-
house platform and that want the global reach to participate in economies of
scale.
[[}]]

● Quorum [[{privacy.private_tx,privacy.private_tx.101]] #[eea_priv_tx_summary]
         [[01_doc_has.diagram,implementation.quorum,devops,00_PM.low_code]]
@[https://consensys.net/quorum/]
• Originally developed by JP Morgan as an extension to standard geth adding
  support for private transactions and later on adquired by Consensys
  (that also develops Besu in parallel with the idea of support both of them).

• Private transactions are implemented to just a restrictect set of nodes.
  Such nodes will keep 2 states ("blockchains"), one for public transactions
  visible to all nodes, and a second one for private transactions.
  KEY POINT: Private granularity is done at enode scope.

  PRIVATE TX SIMPLIFIED SCHEMA:

  ┌ Node  ───┐     ┌ Node ────┐ • Each node trusted-admin will generate a couple of
  │ @ClientA │     │ @ClientB │   priv/pub keys for the Tessera "side-car", keeping
  │  ┌───────┤     ├───────┐  │   the private key "safe", and distributing the pub.
  │  │Tessera•·····•Tessera│  │   key to peers. Such pub.key will be used as recipient
  └──┴──────•┘     └•──────┴──┘   address when sending private transactions (to node
            ·       ·             or to group).
            └·┐   ┌·┘
              ·   ·               NOTE: Not shown in diagram. Clients and
            ┌─•───•─┬───────┐     regulators ussually have two parallel nodes.
            │Tessera│       │     One validator node that executes/validates
            ├───────┘       │     all incoming transactions in each new block,
            │ Regulator     │     and another node to attend client dApps.
            └ Node ─────────┘      The tessera "side-car" is normally installed
                                  on the dApps node used by dApp clients.
                                  In simple setups, validator can also be re-used
to serve dapps, query the blockchain, send new private/public TXs, but is less secure,
since secrets are more exposed to the rest of the network.

 @[https://raw.githubusercontent.com/jpmorganchase/quorum-docs/master/images/QuorumTransactionProcessing.JPG]
   P┌====================================================================┐
   A│                           (9) TxAB-hash Payload?                   │
   R│                             ┌··················┐   (3,10)          │
   T│      (1) Private TX AB      ·(2)TXPayloadStore ·   En/De─crypt req.│
   Y│┌──────•····▷┌───────────────•───┬······▶┌──────▼─•···→┌───────────┐│
    ││ Dapp │     │ Quorum Node A     ├       │TX Mng A│    │ Enclave A ││
   A│└──────┘     │                   │◀······••────•──┘←···•───────────┘│
    │             │                   │    (6) ·    ┃ TX Resp.(4,11)     │
    │             │  Public  Private  │TX Hash ·    ┃                    │
    │             │  State    State   │        ·    ┃ (5)                │
    │             │  ┌────┐   ┌────┐  │◀·······┘    ┃ TXPayloadStore     │
    │    (8) Block│  ├────┤   ├────┤  │      (12)   ┃ private to A and B │
    │    with TxAB··▷└────┘   └────┘  │TX Payload   ┃                    │
    │ notarization│                   │             ┃                    │
    │         hash└───────────────────┘             ┃                    │
    │                 △                             ┃                    │
    │                 *                             ┃                    │
    └==== (7) Ethere. * ============================┃====================┘
          Standard TX *                             ┃
   P┌====    Protocol *=============================┃====================┐
   A│                 *       (9) TxAB-hash Payload?┃   (10) En/De-crypt │
   R│                 ▽          ┌·············┐    ┃  ┐request          │
   T│             ┌──────────────•────┐       ┌▼────▼──•···→┌───────────┐│
   Y│             │ Quorum Node B     │       │TX Mng B│    │ Enclave B ││
    │             │  Public  Private  │       └•───────┘←···•───────────┘│
   B│             │  State    State   │        ·     Tx Resp.(11)        │
    │             │  ┌────┐   ┌────┐  │        ·                         │
    │    (8) Block│  ├────┤   ├────┤  │        ·                         │
    │    with TxAB··▷└────┘   └────┘  │◀·······┘                         │
    │ notarization│                   │      (12)                        │
    │         hash└───────────────────┘TX Payload                        │
    │                 △                                                  │
    │                 *                                                  │
    └==== (7) Ethere. * =================================================┘
          Standard TX *
   P┌====    Protocol * =================================================┐
   A│                 *       (9) TxAB-hash Payload?                     │
   R│                 ▽          ┌·············┐                         │
   T│             ┌───────────────────┐       ┌▼───────┐    ┌───────────┐│
   Y│             │ Quorum Node C     │       │TX Mng C│    │ Enclave C ││
    │             │  Public  Private  │       └────────┘    └───────────┘│
   C│             │  State    State    ◀·······┘                         │
    │             │  ┌────┐   ┌────┐  │          (12)                    │
    │    (8) Block│  ├────┤   ├────┤  │  TX Not Found                    │
    │    with TxAB··▷└────┘   └────┘  │                                  │
    │ notarization│                   │                                  │
    │         hash└───────────────────┘                                  │
    └====================================================================┘
          △ △ △ △ △ △ △ △ △  ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲
          * * * * * * * * *  · · · · · · · · · · · · · ·
          └───────────────┘  └─────────────────────────┘
            Ethereum standard       EEA PRIVATE TX
             p2p Protocol         EXTENSION PROTOCOL

• TESSERA (Private TX):
  • Developed in Java, used both by Quorum and Besu.
    ('Orion' was used by the Go Quorum version, but later on its features
     were embedded into Tessera and the first one 'deprecated', 'Orion'
     deprecated the (Haskell implementation) 'Constellation'.
  • used as a "side-car" of Besu/Quorum to manage private
    communication of encrypted transactions to targeted nodes. (vs public
    non-encrypted transactions -but still digitally signed- broadcasting
    and propagating to all nodes).
  • The enclave, a side-car of the Tessera side-car is use to manage secrets.
    Different enclave plugins exists:
    · local-filesystem keys.
    · Azure Key Vault key pairs.
    · HashiCorp Vault key pairs.
    · AWS Secrets Manager key pairs.

  - Each Tessera node:
    - Generates and maintains a number of private/public key pairs
    - Self manages and discovers all nodes in the network (i.e. their
      public keys) by connecting to as few as one other node
    - Provides Private and Public API interfaces for communication:
      Private API - This is used for communication with Quorum
      Public  API - This is used for communication between Tessera
                    peer nodes
    - Provides two way SSL using TLS certificates and various trust
      models like Trust On First Use (TOFU), whitelist, certificate
      authority, etc.
    - Supports IP whitelist
    - Connects to any SQL DB which supports the JDBC client
[[}]]

● Baseline Protocol Summary [[{integration.enterprise_patterns,integration.data,dev_framework.baseline]]
                            [[privacy.ZKP,standards.EIP/ERC,00_PM.backlog}]]
@[https://docs.baseline-protocol.org/]
@[https://github.com/ethereum-oasis/baseline]
@[https://github.com/eea-oasis/baseline]

• See also Glossary:
@[https://docs.baseline-protocol.org/baseline-basics/glossary]
• Baseline Protocol: set of methods that enable two or more state
  machines to achieve and maintain data consistency, and workflow
  continuity by using a network as a common frame of reference
  through a Consensus Controlled State Machine (CCSM) like Ethereum
  MainNet/....   WITHOUT MOVING ANY SENSITIVE DATA OUT OF OF
  TRADITIONAL SYSTEMS-OF-RECORD .

• """ It is particularly promising as a way to reduce capital
  expense and other overheads while increasing operational integrity
  when automating business processes across multiple companies."""

• BaseLine Modules&Packages:
@[https://docs.baseline-protocol.org/baseline-protocol-code/packages]

  (@baseline-
  protocol)
  Package     Source Path   Description
  =========== ===========   =======================================
  /api        core/api      Core baseline API package providing
                            unified access to the baseline JSON-RPC
                            module and blockchain, registry and key
                            management interfaces

  /baseline   core/baseline Core baseline  package provides unified
                            access to internal integration
                            middleware interfaces for systems of
                            record


  /ccsm       core/ccsm     Core ccsm package provides interfaces
                            for general interaction with an
                            underlying mainnet

  /identitty  core/identity Core identity package provides interfaces
                            for organization registry and decentralized
                            identifiers (DIDs)

  /privacy    core/privacy  Core privacy package provides interfaces
                            supporting Proversystems and and
                            zero-knowledge cryptography


  /types      core/types    Core reusable type definitions

  /vaults     core/vaults   Core vault Provides management interfaces
                            for digital authentication credentials such
                            as keys and secrets

- https://docs.baseline-protocol.org/
- https://docs.baseline-protocol.org/baseline-protocol/packages/contracts

- Video 1 of 6: Baseline Protocol v0.1 Messaging
  https://www.youtube.com/watch?v=ZgaAcQvoD_8&feature=youtu.be

- Video 2 of 6 -- Baseline Protocol v0.1 API Registry Interface
  https://www.youtube.com/watch?v=lsZQwiE2glA&feature=youtu.be

- Video 3 of 6: Baseline Protocol v0.1 Privacy Introduction
  https://www.youtube.com/watch?v=l3BDBNMnR_Q&feature=youtu.be

- Video 4 of 6: Baseline Protocol v0.1 Privacy Deepdive
  https://www.youtube.com/watch?v=0vXoSb5bVks&feature=youtu.be

- Video 5 of 6: Baseline Protocol v0.1 Reference Implementation
  https://www.youtube.com/watch?v=2WXvTHR4_7Q&feature=youtu.be

- Video 6 of 6: Baseline Protocol v0.1 Reference Implementation Part 2
  https://www.youtube.com/watch?v=R0AEww6fKLk&feature=youtu.be

- https://github.com/ethereum-oasis/baseline/tree/master/core/privacy
- https://github.com/ethereum-oasis/baseline/tree/master/examples/bri-1

• Who-is-Who:
- Daniel Norkin : co-founder and CEO of Envision Blockchain.
  a full-service consultancy and Blockchain systems integrator.
- Stefan Schmidt is the CTO, co-founder, and head of software
  architecture at Unibright.
  - Master of Computer Science
  - 20+years of experience in business modeling and software architecture.
  - always in search for the perfect harmony of architectural
    aesthetics and functional simplicity.
- Kyle Thomas :  Founder/CEO of Provide, cybersecurity
  and distributed systems polyglot and entrepreneur with experience
  shipping massively-scalable software to the public/private sectors.

- Salesforce + Baseline: [[{integration.salesforce}]]
https://medium.com/baselineprotocol/dappsuite-extends-the-salesforce-platform-to-leverage-baseline-protocol-for-b2b-workflow-e466cf85c3f0
[[}]]

● EEA-Besu: [[{10_EVM.implementation.besu,standards.eea,standards.eea,10_EVM.implementation.besu.architecture]]
  (Pegasys Pantheon was renamed to Hyperledger Besu after joining the Hyperledger Fundation)
#[besu_architecture_summary]
- External Resources
  • Chat     : @[https://chat.hyperledger.org/channel/besu]
  • Releases : @[https://github.com/hyperledger/besu/releases]
  • Core Devs: @[https://github.com/hyperledger/besu/graphs/contributors?from=2021-06-01&to=2022-02-01&type=c]

- Java based, using VertX as core framework.
- Apache 2.0.
- Supports different plugable consensus (Ethash-PoW/Mainnet, Clique-PoA/Goerli testnet,
  IBFT2/private networks requiring X-finality.
- Private TXs.
- GraphQL.
- OnChain permissioning of allowed TX-signers and allowed nodes for permissioned networks.
- OpenSource / Enterprise version.
_________________________
Extracted from old gitter channel: 2019-03-27
https://gitter.im/PegaSysEng/pantheon

• BESU HIGH LEVEL COMPONENT ARCHITECTURE:  [[{01_doc_has.diagram]]
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              JSON RPC                                                       │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
╔═ CORE ("Mining") ═════╗ ╔ CHAIN PROCESSING ═══════╗ ╔ P2P ══════════════════════════════════╗
║╔═ SYNCHRONIZER ══════╗║ ║ PROTOCOL SPEC:          ║ ║╔ ETH SUB-PROTOCOL ═══════════════════╗║
║║ ● DOWNLOADER        ║║ ║ Update chain-of-blocks: ║ ║║┌ ETH PEER ─────────┐─┌ EXECUTORS ──┐║║
║║                     ║║ ║                         ║ ║║│                   │ │             │║║
║║ ● BLOCK PROPAGATION ║║ ║ ● BLOCK     ● TX        ║ ║║│ ● WIRE-CONNECTION │ │● SYNC WORKER│║║
║║   MANAGER           ║║ ║   HEADER      VALIDATOR ║ ║║│ ● REQUEST-MANAGER │ │● TX WORKER  │║║
║╚═════════════════════╝║ ║   VALIDATOR             ║ ║║│ ● PEER-REPUTATION │ │● SCHEDULED  │║║
║╔ TX POOL ════════════╗║ ║                         ║ ║║│ ● CHAIN-STATE     │ └─────────────┘║║
║║ ● PENDING  ● TX     ║║ ║ ● BLOCK     ● BLOCK     ║ ║║└───────────────────┘                ║║
║║   TXs        SENDER ║║ ║   IMPORTER    PROCESSOR ║ ║║ ● ETH MESSAGER                      ║║
║╚═════════════════════╝║ ╚═════════════════════════╝ ║╚═════════════════════════════════════╝║
║ ● MINER               ║                             ║┌─WIRE P2P PROTOCOL──────────────────┐ ║
╚═══════════════════════╝                             ║└────────────────────────────────────┘ ║
                                                      ║┌ DISCOVERY AGENT ───────────────────┐ ║
            ╔═ STATE  ══════════════════╗             ║└──▲─────────────────────────────────┘ ║
            ║┌ WORLD───┐ ┌ BLOCKCHAIN ┐ ║             ╚═══│═══════════════════════════════════╝
            ║│ STATE   │ │            │ ║       • DEVp2 Peer Discovery
            ║│ ARCHIVE │ │            │ ║         . UDP-based system to discover other nodes
            ║└─────────┘ └────────────┘ ║         . Based on a  well-known set of boot nodes .
            ║┌CONSENSUS┐ ┌ SYNC STATE ┐ ║           . Recursively looks up new peers (neighbors)
            ║└─────────┘ └────────────┘ ║             from known peers.
            ╚═══════════════════════════╝       • DISCOVERY (of (neighbors IP) PACKET EXCHANGE
                                                  Node_A → Node_B: Ping
                                                  Node_A ← Node_B: Pong
                                                  Node_A → Node_B: Find Neighbors
                                                  Node_A ← Node_B: known-neighbors list
[[}]]

  besu  /                                $ bin\besu --config=my.cfg \
     ├─ bin/ (install)                 $   --data-path=/var/lib/besu/node1 \
     ├─ lib/ (install)                 $   --genesis=my.genesis \
     ├─ key  (run─time) eNode Priv.key $   --max-peers=5 \
     │  (--data-path)                  $   --rpc-enabled
     └─ ddbb (run─time) RocksDB data   ( LOGS go to STDOUT )
        (--data-path)

• Besu: UNDERSTANDING CODEBASE. STARTUP SEQUENCE:
@[https://github.com/hyperledger/besu]

    Initial                    Create                      Create                    Run Runner
    Bootstrap             ->   BesuController.java     ->  Runner.java           ->  instance!!
  ┌──────────────────────┐  ┌─────────────────────────┐   ┌───────────────────────┐
  - Parse cli flags         It will collect all bck        RunnerBuilder.java 
  - (cli/BesuCommand.java)  related config&services:       -> Runner.java                
  - parse config file,      - chain+world state DBs 
  - load|generate node      - StorageProvider:           - Contains services for:
    key-pair                  InMemory + RocksDB      ┌··- Network startup 
  - parse genesis file      - Genesis Config File     ·  - Besu COntroller
                        ┌···- Node keypair            ·  - JSON RPC
                        ·   - ProtocolSchedule        ·  - WebSocket RPC
┌···························  + ProtocolSpec          ·  - Plugable Metrics System 
·                       ·   · Synchronizer            ·    (Prometheus, ...)
· ┌·····················┘   - Transaction Pool        ·  - Data directory
· ·                         - Miner                   · 
· ·                                                   ·
· └ Valid for a "bunch of blocks" in the chain        ·
·   (validators and proccessor applying to Byzantium, ·
·   Constantinople,... The ProtocolSchedule "groups   ·
·   them all" mapping milestone block-ranges to       ·
·   specific protocol logic                           ·
·   (ethereum/mainnet/ProtocolSpec.java)              ·
·                                                     ·
· ┌···················································┘         [[{01_doc_has.seq_diagram]]
· ·                                                    ┌······· (UDP) PEER DISCOVERY  
· └· Runner                                            ·        - Recursive, starting with  
·    └> Network Startup:                               ·          "well-known-set-of-boot-nodes"
·       └> Discover Neighbords                         ·          NODE -> PEER: "PING"
·          └> Setup connections                        ·          NODE <- PEER: "PONG"
·             > DEV-P2P Wire Protocol (RLPx)        ┌··┴····┐     NODE -> PEER: "FIND Neighbors"
·               . Manages peers [capabilites/status,discovery,    NODE -> PEER: Neighbors list
·                                reputation("best to talk to")] [[}]]
·               . Peer Authentication
·               . Encryption (ECIES based on node Pub/Priv keys)
·               . Compression
·               . Keep Alive
·  
·             > DEV-P2P Subprotocol
·               - Pluggable subprotocols handling extended consensus
·                 mechanisms such as Eth, Ibft, Istanbul64Protocol
·               - Defines the set and appropiate ordering of messages 
·                 on the network.
·               -  PROTOCOL MANAGE:
·                 "Acumulates the logic of different subprotocols"
·                 a) Processes incoming messages for their subprotocol
·                 b) Sends outbound messages to other nodes using this
·                    subprotocol
· 
·               - Example Sample Message Set for EthPV62:  [[{101]]
·                 [ STATUS , NEW_BLOCK_HASHES , TRANSACTIONS,
·                   GET_BLOCK_HEADERS, BLOCK_HEADERS, GET_BLOCK_BODIES,
·                   BLOCK_BODIES , NEW_BLOCK ]  [[}]]
· 
└> SYNCHRONIZER: Manages the overall sync runtime
   - ChainDownloader Loop:
     1) Find best peer to sync from (best new data)
     2) Pull checkpoint headers (Multithreaded downloading)
     3) Pipelined blocks Import
        - Download and validate headers
        - Download bodies
        - Extract TX senders (PKI key recovery)
        - Validate / Persist blocks
     4) "repeat"

  - "MUST TO" video explaining the general architecture :
  @[https://www.youtube.com/watch?v=OJfib9kTK7U]

 - REF: 
   https://github.com/hyperledger/besu/blob/master/besu/src/main/java/org/hyperledger/besu/cli/BesuCommand.java
   https://github.com/hyperledger/besu/blob/master/besu/src/main/java/org/hyperledger/besu/controller/BesuController.java]
   https://github.com/hyperledger/besu/blob/master/ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetProtocolSpecs.java

 • Web3J(ava) Besu Private TX Extensions: [[{dev_framework.java.web3j]]
   https://github.com/web3j/web3j/blob/master/besu/src/test/java/org/web3j/protocol/besu/RequestTest.java
   https://github.com/web3j/web3j/blob/master/besu/src/test/java/org/web3j/protocol/besu/ResponseTest.java
  
   - Extracted from Initial Pull Request:
   @[https://github.com/web3j/web3j/pull/767]
   ikirilov : ... propose we reconcile common calls for geth and Besu.
   benesjan : ... There is one issue with creating common Geth and Besu module.
                  Geth's version of minerStart accepts parameter threadCount and
                  Besu's version does not. So unifying those two might be confusing.
   conor10  : ... let’s leave the duplication in for now ...
   [[}]]


[[}]]

● BESU/EEA NODES GOVERNANCE [[{standards.eea,10_EVM.implementation.besu,security.governance,00_PM.TODO]]
- Onchain Permissioning: (Las Update 2020-03-20)
@[https://besu.hyperledger.org/en/stable/Concepts/Permissioning/Onchain-Permissioning/]

- SCs used to store and administer allowed nodes, accounts and admin whitelists.
  (vs whitelists in config files with the potential to have errors or not being in sync).

- Custom SCs and DApps can be implemented to work with onchain permissioning.

- Existing Permissioning contracts:
  - INGRESS CONTRACTS : proxy contracts DEFINED IN THE GENESIS FILE to defer the
    for nodes and       permissioning logic to the Node Rules and Account Rules contracts.
    accounts            The Ingress contracts deploy to static addresses.

  - NODE RULES        : stores node whitelist and node whitelist operations
                        (for example, add and remove).

  - ACCOUNT RULES     : stores the accounts whitelist and account
                        whitelist operations (for example, add and remove).

  - ADMIN             : stores the list of admin accounts and admin list
                        operations (for example, add and remove). There is one
                        list of admin accounts for node and accounts.

- Permissioning Management Dapp:
  - provides view and maintain access to the whitelists.

- Whitelists implemented:
  - ACCOUNTS that can submit transactions to the network.
  - NODES    that can join the network.
             TIP: All bootnodes must be on the nodes whitelist.
  - ADMINS   accounts that are able to update the ACCOUNTS 
             and NODES WHITELISTS

  WARN: On-chain ACCOUNT whitelist permissioning is incompatible  [[{privacy]]
        with random key signing for privacy marker transactions:
        A signing key must be specified using the
        "--privacy-marker-transaction-signing-key-file" cli flag,
        and also included in the accounts whitelist.              [[}]]

@[https://besu.hyperledger.org/en/stable/HowTo/Limit-Access/Local-Permissioning/]
[[}]]

● EEA-Besu CLI Summary: [[{devops.besu,13_SLC.monitoring]]

  besu  blocks import   imports blocks from file into database.       [[{devops.besu.backups]]
  besu  blocks export   exports a specific block, or list of blocks
                        into file                                     [[}]]

  besu  public-key export <- print node public key  to STDOUT
  besu  public-key           (export-address to print address)

  besu  password hash   <- generate hash of a given password

  besu  retesteth       <- Run a Retesteth compatible server for (re)ference (test)s
                           https://ethereum-tests.readthedocs.io/en/develop/index.html
                           "Common tests for all clients to test again"

  besu  rlp encode     <- encode JSON to RLP hex string

  besu  operator \     <- generates node keypairs+genesis file
   generate-blockchain-config                           (with RLP encoded IBFT 2.0 extra data).

  Common CLI Options: (Precedence order: cli flags, ENV.VARs, config file)
@[https://besu.hyperledger.org/en/stable/Reference/CLI/CLI-Syntax/]
Updated 2019-10-21

  --banned-node-ids=bannedNodeId1,bannedNodeId2,...              [[{security.aaa.besu}]]
  --bootnodes=enode://id@host1:port1,enode://id@host2:port2,...
  --data-path=dir_path
  --discovery-enabled=false
  --genesis-file=file_path   # --network is enough for public main/test nets.

 GraphQL
  --graphql-http-cors-origins="graphQLHttpCorsAllowedOrigins"
  --graphql-http-enabled
  --graphql-http-host="host" # defaults to 127.0.0.1
  --graphql-http-port="port" # defaults to 8547.

 Host Whitelist
  --host-whitelist=host1,host2,... or "all"  # allowed host list to JSON-RPC
                                           # Defaults to 127.0.0.1, recomended.
  --key-value-storage="keyValueStorageName"# Use only if using a storage system
                                           # provided with a plugin. Default:rocksdb
  --max-peers=N                            # Specifies the maximum P2P connections
                                           # that can be established. The default is 25.
 Metrics
  --metrics-category="Comma separated list"# BIG_QUEUE, BLOCKCHAIN, EXECUTORS, JVM, NETWORK,
                                           # PEERS, PROCESS, ROCKSDB, RPC, SYNCHRONIZER.
  --metrics-enabled=true                   # Defaults to false
                                           # incompatible with --metrics-push-enabled.
                                           # (either push or pull can be enabled)
    More info at: @[https://docs.pantheon.pegasys.tech/en/stable/HowTo/Deploy/Monitoring-Performance/]
  --metrics-host=prometheus_host           # --host-whitelist is respected
  --metrics-port=tcp_port                  # default to 9545
  --metrics-push-enabled=true|false        # incompatible with --metrics-enabled.
                                           # (either push or pull can be enabled)
                                           # --host-whitelist is respected
  --metrics-push-interval=number_of_secs   # default is 15.
  --metrics-push-port=tcp_port             # default to 9001.
  --metrics-prometheus-job=prometheus_Job

 MINING
  --miner-coinbase=valid_coinbase          # applies with --miner-enabled (or miner_start JSON-RPC method)
                                           # ignored by Clique, IBFT 2.0 consensus
  --miner-enabled
  --miner-extra-data="32 bytes hex string" # will be include in extra-data-field of mined block
                                           # default to 0x.
  --min-gas-price=minTransactionGasPrice

 NAT TRAVERSAL
  --nat-method=UPNP                        # UPNP | NONE(default)
                                           # Can NOT be used with Docker image

 PUBLIC ETH. NET
 --network=$NETWORK                        ropsten (PoW), rinkeby (PoA+Clique),
                                           goerli  (PoA+Clique), dev (very low PoW difficulty)
                                           (Use --genesis-file for non-standard networks)
 --network-id="P2P net. integer ID"        # overrides chain ID in genesis file

 NODE PRIVATE KEY                          (cloud extensions exists to retrieve from AWS/Azure/...)
 --node-private-key-file=file_path         # Defaults to data directory. If NOT found a key file
                                           # containing the generated private key is created;
                                           #  WARN: The private key is not encrypted!!!
 GOSSIP PROTOCOL
 --p2p-enabled=true*|false
 --p2p-host=p2p_listening_host            # default to 127.0.0.1
 --p2p-interface=ip_nterface              # default to 0.0.0.0 (all interfaces).
 --p2p-port=tcp_port                      # default to 30303.
 --remote-connections-limit-enabled=true*|false      # TIP: In private networks with a level of trust
                                                     # between peers, disabling it may increase speed
                                                     # at which nodes can join the network.
                                                     # WARN: Always enable in pub.nets to avoid
                                                     #       eclipse attacks, specially with fast-sync.
 --remote-connections-max-percentage=...             # 0 to 100, defaults to 60

  ACCOUNT PERMISSIONING (onchain permissioning is preferred)
  --permissions-accounts-config-file-enabled=true|false*  # enable file-based account level perm.
                                                          # enable file-based account level perm.
  --permissions-accounts-config-file=path  # Default to permissions_config.toml
                                           # Tip  --permissions-accounts-config-file and
                                           #      --permissions-nodes-config-file    can use the same file.
  --permissions-accounts-contract-enabled=true|false*
  --permissions-accounts-contract-address= # contract address for onchain account permissioning.
  --permissions-nodes-contract-address=    # contract address for onchain node permissioning.
  --permissions-nodes-config-file-enabled=true|false
  --permissions-nodes-config-file=file     # Default to ${BESU_DATA_PATH}/permissions_config.toml
  --permissions-nodes-contract-enabled=true|false*

 PRIVACY: ("Tessera configuration")
  --privacy-enabled=true|false
  --privacy-marker-transaction-signing-key-file=file  # priv.key used to sign Privacy Marker Transactions.
                                                      # If not set, each TX is signed with a different
                                                      # randomly generated key.
  --privacy-precompiled-address=priv.Precomp.Address  # default to 126
  --privacy-public-key-file=privacyPublicKeyFile      # pub.key of the Tessera node.
  --privacy-url=privacyUrl                            # URL on which Tessera node is running.

  DEBUG
  --revert-reason-enabled=true|false*                 # Why default to false?
                                                      # Enabling it use a significant amount of memory.
                                                      # Not recommended for public Ethereum networks.
 HTTP APIs
  --rpc-http-api=csv of enabled APIs through HTTP     # --rpc-http-enabled must also be set to take effect
                                                      #  ADMIN, ETH, NET, WEB3, CLIQUE, IBFT,
                                                      #  PERM, DEBUG, MINER, EEA, PRIV,TXPOOL.
                                                      #  default: ETH, NET, WEB3
                                                      #  Investigate what CLIQUE, IBFT, PRIV, TXPOOL, .. means
  --rpc-http-authentication-credentials-file=$file
  --rpc-http-authentication-enabled=true|false*
  --rpc-http-cors-origins=csv of URLs or "all"        # Domain URLs must be enclosed in double quotes
                                                      # Needed for Remix and any other browser app
                                                      # Defaults to "none" (browser apps cannot interact with node)
                                                      # To use Bese as MetaMask backend anywhere, set it to "all"/"*"
  --rpc-http-enabled=true|false*
  --rpc-http-host=$host                               # default to 127.0.0.1
  --rpc-http-port=$port                               # default to 8545
 Web Socket APIs
  --rpc-ws-api=csv of enabled APIs through Web Socket # --rpc-ws-enabled must also be set to take effect
                                                      #  ADMIN, ETH, NET, WEB3, CLIQUE, IBFT,
                                                      #  PERM, DEBUG, MINER, EEA, PRIV,TXPOOL.
                                                      #  default: ETH, NET, WEB3
  --rpc-ws-authentication-credentials-file=$file
  --rpc-ws-authentication-enabled=true|false*         # WARN: auth. requires a token passed by header, not
                                                      # currently supported by 'wscat'
  --rpc-ws-enabled=true|false*
  --rpc-ws-host=$host                                 # default to 127.0.0.1
  --rpc-ws-port=$port                                 # default to 8546

  GAS LIMIT CONFIGURATION:
  --target-gas-limit=$GAS_LIMIT_INTEGER               [[{10_EVM.gas]]
    Specifies the block gas limit toward which Besu will gradually move on an existing network,
    if enough miners are in agreement.  Use it to change the block gas limit set in the
    genesis file without creating a new network .
    The gas limit between blocks can change only 1/1024th , so this option tells the
    block creator how to set the gas limit in its block:
    - If the values are the same or within 1/1024th, the limit is set to the specified value.
    - Otherwise, the limit moves as far as it can within that constraint.
    - If not specified, block gas limit remains at the value specified in the genesis file.
  [[}]]

  PENDING TX POOL [[{architecture.async]]
  --tx-pool-max-size=integer                        # Max TX num.kept in pending TX pool. 
                                                    # Default to 4096. 
  --tx-pool-retention-hours=integer                 # Max hours to retain pending TX in TX pool.  
                                                    # Default to 13h.
  [[}]]

  LOGGING
  --logging=OFF|FATAL|ERROR|WARN|INFO*|DEBUG|TRACE|ALL

  FAST SYNC
  --sync-mode=FAST|FULL*
  WARN: FAST mode, most historical world state data is unavailable.
        Any methods attempting to access unavailable world state data return null.
  --fast-sync-min-peers=integer                     # Minimum peer number before start fast-sync.
                                                    # Default is 5.
[[}]]

● Besus GraphQL Schema [[{10_EVM.implementation.besu,integration.graphql]]
@[https://github.com/hyperledger/besu/blob/master/ethereum/api/src/main/resources/schema.graphqls]

schema {
    query: Query
    mutation: Mutation
}

TYPES:
 - Query, Account, Log, Transaction, Block,
 - CallResult, SyncState, Pending  (State)

type Query {
    account(address: Address!, blockNumber: Long): Account!
    block(number: Long, hash: Bytes32): Block!
    blocks(from: Long!, to: Long): [Block!]!
    pending: Pending!
    transaction(hash: Bytes32!): Transaction
    logs(filter: FilterCriteria!): [Log!]!
    gasPrice: BigInt!
    protocolVersion: Int!
    syncing: SyncState
}

type Mutation {
    sendRawTransaction(data: Bytes!): Bytes32!
}

INPUTS:
  - BlockFilterCriteria: (filter applied to a single block)
  - CallData
  - FilterCriteria : Filter applied from block to block)
[[}]]

● EEA-Besu What's new: [[{evm.implementation.besu]]
• EEA-Quorum 21 (2021-03-09):
  REF:
  @[https://consensys.net/blog/quorum/consensys-quorum-21-1-0-features-enhanced-ethereum-mainnet-compatibility/]
  - Enhanced compatibility between Besu and GoQuorum.
  - lower infrastructure costs
  - Besu mainnet Improvements for Network Upgrades, Database and Storage:
    - Compatibility with MainNet Berlin Network Upgrade
      (next planned MainNet hard fork)
      -  addition of subroutines to the EVM.
      -  introduction of  "transaction envelopes"  making it simpler for Ethereum
         to support several different kinds of transactions
      -  changes in gas costs to increase the security of the network.
         WARN : Use 21.1.2 or higher.   21.1.0 contains an outdated version  of Berlin upgrade.
      -  Mainnet Launcher "wizard"
      -  Bonsai Tries (Early Access): new database format reducing  [[{01_doc_has.comparative]]
         storage requirements and improving performance for "recent state"
         operations.
         NON-BONSAI TRIES                 BONSAI TRIES
         - multi-trie key/val store     - single trie.
                                        - one set of indexed leafs
                                        - N diffs that can be used
                                          to move the trie forward
                                          or backwards.
                                        --------------------------
                                        - reduce chain head count and
                                          state read and write amplification
                                          from 10x-20x levels to 1x-2x for
                                          non-committed access.

                                        - Note: only full sync currently supported.
         [[}]]

  -  New monitoring API detects nodes non initiating or receiving TX
     for a period-of-time and stops+hibernates them to reduce infra. cost.

  -  Multi-Tenancy in GoQuorum/Tessera nodes.             [[{governance.multitenant]]
     Allows multiple private states(MPS) for different tenants
     using the same GoQuorum node, with each tenant having
     its own private state(s).                            [[}]]

• EEA-Besu 1.4:
  └ Plugin API  allows to fetch data from running Besu node:

    BESU  -> (data) -> Besu 1.4+ -> feed to DDBBs, kafka, ...
    node     ^^^^^^    Plugin-API
            Blocks, 
            Balances, TXs, SC,
            Logs,  ...
  └ future work: Besu will compartmentalize key supporting services, eventually
                 allowing them to be swapped via a plugin.
                 Ex: PegaSys Plus 1st release, made DDBB swappable to support
                     encryption at rest.

  └ privacy use in a multi-tenacy environment; [[{governance.multitenant]]
  @[https://pegasys.tech/increase-adoption-and-cut-costs-with-multi-tenancy-on-hyperledger-besu/]
    (many clients re-using the same Ethereum client node
     whilst maintaining the privacy and confidentiality )
    with support for authenticated API access and allowing hosts who
    standup the infrastructure custom control on who to grant access to,
    at various levels of granularity depending on the
    users need,   coupled with Tessera private TX manage  .
    - By using   JWT tokens , a user identity is tied to a privacy
      identity, validating every API call to ensure the user
      is part of the privacy group before any data is revealed.
    (WiP for EthSigner and PegaSys Orchestrate multi-tenancy)   [[}]]
  └ Early access to flexible privacy groups allowing addition and
    removal of privacy group members.
  └ New tracing APIs
  └ Event Streaming Improvements
  └ Advanced Key Management
  └ Flexible privacy calls
  └ End to end encryption with TLS links between PegaSys suite products

• EEA-Besu 1.2 Release: (2019-08)
  - improvements to our privacy groups
  - new DApp for onchain permissioning management. 
  @[https://youtu.be/lwaZ4JhLhH0]
  - Account-level Permissioning
  - Improved Privacy Groups:
  - EthSigner for External Key Management
    Hashicorp KeyVault and Azure Key Vault
  - New GraphQL Interface:
  - Support for UPnP (dynamic inbound connections in routers)
[[}]]

● EEA-Besu DevOps: [[{standards.eea,10_EVM.implementation.besuldevops]]
                   [[infrastructure.storage.offchain,13_SLC.monitoring]]

• EEA-Besu IBFT 2.0 BOOTSTRAP:

  PRE-SETUP)  [[{devops.troubleshooting.performance]]
  - Linux: In MainNet and "large" nets increase max.number 
            of open files allowed: $ sudo ulimit ...    [TODO]
            to avoid the "Too many open files RocksDB exception". [}]]

@[https://besu.hyperledger.org/en/stable/Tutorials/Private-Network/Create-IBFT-Network/]

 STEP 01: BOOTSTRAP NODE CONFIGURATION)
 --------------------------------------
 (key / key.pub for each node can be generated 

 INPUT               ->  BOOTSTRAP                        ->  OUTPUT 
                         SCRIPT                               (INPUT TO NODE CONFIG)
 --------------------    --------------------------------     -------------------------
                                                              (Move to each new node)
  ibftGenesis.json       $ besu operator \                     ./networkFiles/
  ^^^^^^^^^^^^^^^^        generate-blockchain-config  \        ├  genesis.json
  |                          --config-file=ibftGenesis.json \  └  keys
  {                          --to=networkFiles \                  0x--20 bytes addr1/
   "genesis": {              --private-key-file-name=key          ├ key
     "config": {                                                  └ key.pub
        "chainId": 2018,                                          0x--20 bytes addr2/
        "constantinoplefixblock": 0,                              ├ key
        "ibft2": {                                                └ key.pub
          "blockperiodseconds": 2,                                0x--20 bytes addr3/
          "epochlength": 30000,                                   ├ key
          "requesttimeoutseconds": 10                             └ key.pub
        }                                                         0x--20 bytes addr4/
      },                                                          ├ key
      "nonce": "0x0",                                             └ key.pub
      "timestamp": "0x58ee40ba",                                  ^
      "gasLimit": "0x47b760",                                     ·
      "difficulty": "0x1",                                        ·
      "mixHash": "0x-- 32 bytes   *1 --",                         ·
      "coinbase": "0x00...20bytes..00",                           ·
      "alloc": {                                                  ·
         "40 hex-digits account01.": {                            ·
            "balance": "0x..."                                    ·
         },                                                       ·
         ...
        },                                                        ·
      "extraData": "0x... (RLP encoded)...",                      ·
   },                                                             ·
                                                                  ·
   "blockchain": {                                                ·
     "nodes": {                                                   ·
       "generate": true,                                          ·
         "count": 4       <··· number of node key pairs to be generate
     }                         4+ validators needed in IBFT 2.0 to really
   }                           be BFT
  }
   *1 :0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365


 STEP 02: Start the Network (Example script)
 --------------------------
 $ export COMMON=""
 $ export COMMON="$COMMON --data-path=data"
 $ export COMMON="$COMMON --genesis-file=../genesis.json"
 $ export COMMON="$COMMON --rpc-http-enabled --rpc-http-api=ETH,NET,IBFT"
 $ export COMMON="$COMMON --host-whitelist='*' --rpc-http-cors-origins='all'"
 $ besu $COMMON --bootnodes=$ENODE1_URL --p2p-port=30306 --rpc-http-port=8548

 $ curl -X POST \     <- STEP 3) Confirm Network is Working
   --data '{"jsonrpc":"2.0","method":"net_peerCount","params":[],"id":1}' \
   localhost:8545
 -- Output must confirm 3 peers for node 1
   { ...  "result" : "0x3" }
  (Check also logs confirming blocks being produced after 
   cluster nodes are in sync -it can take a few minutes for big chains)

 - Add/Remove validators using the IBFT REST API:
  @[https://besu.hyperledger.org/en/stable/Reference/API-Methods/#ibft-20-methods]
  PRE-SETUP: run besu with flags '--rpc-http-api' and/or '--rpc-ws-api'

  REST API:
  PROPOSAL TO ADD/DEL VALIDATOR          DISCARDS PENDING PROPOSAL            GET PENDING VOTES
  =============================          =========================            =================
  METHOD="ibft_proposeValidatorVote"     METHOD="ibft_discardValidatorVote"   Returns json Map address:vote
  PARAMS='["0x..40hex-digit addr",true]' PARAMS='[$VALIDATOR_A_ADDR]'         METHOD="ibft_getPendingVotes"
  curl -X POST --data \                  curl -X POST --data \                curl -X POST --data \
  '{"jsonrpc":"2.0",                      '{"jsonrpc":"2.0",                  '{"jsonrpc":"2.0",
    "method":"$METHOD",                     "method":"$METHOD",                 "method":"$METHOD",
    "params":$PARAMS,                       "params":$PARAMS,                   "params":[], 
    "id":1}' $NODE_URL                      "id":1}' $NODE_URL                  "id":1}' $NODE_URL
  
  - LISTS VALIDATORS @ BLOCK-HASH                   - LISTS VALIDATORS @ BLOCK NUMBER.
    - Returns list of validator addresses             - Returns list of validator addresses.
      METHOD="ibft_getValidatorsByBlockHash"            METHOD="ibft_getValidatorsByBlockNumber"
      PARAMS='["0x... 64 hex-digit block hash"]'        PARAMS='["latest"]' # N|earliest|latest
      curl -X POST --data \                             curl -X POST --data \          |pending 
      '{"jsonrpc":"2.0",                                '{"jsonrpc":"2.0",
         "method":"$METHOD",                              "method":"$METHOD", \
         "params":$PARAMS,                                "params":$PARAMS, \
         "id":1}' $NODE_URL                               "id":1}' $NODE_URL
  
  
  GET VALIDATOR METRICS FOR BLOCK-RANGE:
  ======================================
  Returns: Block number of last-block-proposed-by-each-validator 
           All validators present in the last-block in range
  Note: genesis block proposer has address 0x000...0.
  - Example
    METHOD="ibft_getSignerMetrics"
    PARAMS='["1", "100"]' <- [from, to] blocks (defaults to last 100 blocks)
    curl -X POST --data \
    '{"jsonrpc":"2.0",
      "method":"$METHOD",
      "params":$PARAMS,
      "id":1}' $NODE_URL


• EEA-Besu Disk/RAM stimation:                      [[{devops.besu.storage]]
                          DISK Space:  RAM:
test/private network      -200+MB      - 4+GB RAM
mainnet/public-test-net   -1.5+TB      - 8+GB RAM

Notes: 2019-01
Testing with besu-quick-start and IBFT 2.0 with defaults settings
(1 block each 5? seconds) the disk compsumption is:

          1 hour     1 day      1year
          2044K      47.9MB     17485.8MB
IBFT2 Consensus Case:
- Each mined block has a minimum length of 648 bytes for empty blocks.
- With a block-period configured to 5 seconds, this leads to:

print( ( 648 / (1024.*1024.) ) * 12      * 60       * 24)      ~  10.68 MBytes/day
         ^^^^^^^^^^^^^^^^^^      ^         ^          ^           ^^^^^^^^^^^^^^^^
        block-size in MBytes   blks/min  mins/hour   hours/day    Minimum ussage.
                               5secs/blk                          Just empty blocks.
                                                                  No indexes, external
                                                                  logs, file-system
                                                                  metadata, ...
  [[}]]

[[}]

● EEA-Besu Monitoring Performance (Prometh.+Grafana) [[{evm.implementation.besu,13_SLC.profiling]]
FROM @[https://gitter.im/PegaSysEng/pantheon] on 2019-05-29 20:01
- Adrian Sutton@ajsutton
  We've just published a Grafana dashboard as an example for
  monitoring Pantheon nodes:
   whether they're in sync , number of peers, cpu and memory usage etc.
  It's available at:
  @[https://grafana.com/dashboards/10273] and instructions for
  setting up Pantheon and Prometheus is at
  @[https://pantheon.readthedocs.io/en/stable/Using-Pantheon/Monitoring/#setting-up-and-running-prometheus-with-pantheon]
  ...
  I did sneak some extra metrics into trunk yesterday so the board
  work best with a build from master or anything from 1.1.2 onwards
  once it's released.


REF: @[https://lists.hyperledger.org/g/besu/message/34]
Re: How to Monitor Performance for Multiple Nodes?
...  you can use the promethus metrics server.
(--metrics-enabled and --metrics-categories=JVM,PROCESS).
In addition to enabling it you would need a prometheus server
to poll the metrics and something like grafana to make it presentable.

Here is a mechanical dump of all of the Prometheus metrics that we currently can export:

@[https://gist.github.com/shemnon/bff32ff78ff42cb2d51f76effba0d311]
Most relevant are the jvm_ and process_ metrics, which are standard prometheus names.

Block gas limit of the current chain head block
Gas used by the current chain head block
Number of ommers in the current chain head block
Timestamp from the current chain head
Number of transactions in the current chain head block
Total difficulty of the chainhead
Current number of threads executing tasks
Total number of tasks executed
Current number of threads in the thread pool
Current number of tasks awaiting execution
Total number of tasks rejected by this executor
Total number of tasks executed
Current number of threads executing tasks
Total number of tasks executed
Current number of threads in the thread pool
Current number of tasks awaiting execution
Total number of tasks rejected by this executor
Total number of tasks executed
Current number of threads executing tasks
Total number of tasks executed
Current number of threads in the thread pool
Current number of tasks awaiting execution
Total number of tasks rejected by this executor
Total number of tasks executed
Current number of threads executing tasks
Total number of tasks executed
Total number of tasks rejected by this working queue.
Current number of threads in the thread pool
Current number of tasks awaiting execution
Total number of tasks rejected by this executor
Total number of tasks executed
Current number of threads executing tasks
Total number of tasks executed
Current number of threads in the thread pool
Current number of tasks awaiting execution
Total number of tasks rejected by this executor
Total number of tasks executed
Current number of inflight discovery interactions
Total number of discovery interactions initiated
Total number of interaction retries performed
Total number of P2P discovery messages received
Total number of P2P discovery messages sent
The number of pending tasks in the Netty boss event loop
The number of pending tasks in the Netty workers event loop
Count of each P2P message received inbound.
Count of each P2P message sent outbound.
The number of pending tasks in the Vertx event loop
Total number of tasks completed by the Vertx worker pool
Total number of tasks rejected by the Vertx worker pool
Total number of tasks submitted to the Vertx worker pool
Total number of peers connected
Total number of peers disconnected
Number of peer requests currently pending because peers are busy
Latency for commits to RocksDB.
Latency for read from RocksDB.
Latency of remove requests from RocksDB.
Estimated database size in bytes
Estimated memory used for RocksDB index and filter blocks in bytes
Number of RocksDB transactions rolled back.
Latency for write to RocksDB.
Time taken to process a JSON-RPC request
Total number of subscriptions
Total number of unsubscriptions
Number of entries process by each chain download pipeline stage
Number of times the chain download pipeline has been restarted
Whether or not the local node has caught up to the best known peer
Internal processing tasks
Count of transactions added to the transaction pool
Total number of duplicate transactions received
Total number of transactions messages skipped by the processor.
Count of transactions removed from the transaction pool
The estimated highest block available
The current height of the canonical chain
The current number of peers connected
The maximum number of peers this node allows to connect
Bytes capacity of a given JVM buffer pool.
Used buffers of a given JVM buffer pool.
Used bytes of a given JVM buffer pool.
The number of classes that are currently loaded in the JVM
The total number of classes that have been loaded since the JVM has started execution
The total number of classes that have been unloaded since the JVM has started execution
Time spent in a given JVM garbage collector in seconds.
Committed (bytes) of a given JVM memory area.
Initial bytes of a given JVM memory area.
Max (bytes) of a given JVM memory area.
Used bytes of a given JVM memory area.
Committed bytes of a given JVM memory pool.
Initial bytes of a given JVM memory pool.
Max bytes of a given JVM memory pool.
Used bytes of a given JVM memory pool.
Current thread count of a JVM
Daemon thread count of a JVM
Cycles of JVM-threads that are in deadlock waiting to acquire object monitors or ownable synchronizers
Cycles of JVM-threads that are in deadlock waiting to acquire object monitors
Peak thread count of a JVM
Started thread count of a JVM
Current count of threads by state
Total user and system CPU time spent in seconds.
Maximum number of open file descriptors.
Number of open file descriptors.
Start time of the process since unix epoch in seconds.
RocksDB statistics (cache,  compression, ...)

[[}]]


● Kaleido (SaaS Besu)
[[{infrastructure.cloud.SaaS,dev_framework.kaleido,security.governance,13_SLC.troubleshooting,00_PM.low_code]]
<span xsmall>External Links</span>
-@[https://docs.kaleido.io/getting-started/about-kaleido/]
-@[https://github.com/kaleido-io/]
<span xsmall bgorange>Marketplace</span>
@[https://marketplace.kaleido.io/]
- Zero Knowledge Token Transfer
- Token Swap: Easily and securely trade tokens with other members in your environment.
- Document Store: Store, manage and share information from your own private document store
- App2App Messaging
  - Communicate securely and reliably with end-to-end encrypted messaging from Dapp to Dapp
  - Identity and Access Management (IAM)
    Integrate your existing enterprise identity management with your Dapp
- Rotate signers
  Scale IBFT consensus algorithm for broader participation
- Token Explorer Dashboard
- EthWallet
  Simple and secure way to manage key ownership for signing transactions.
- HD Wallet
  Submit transactions anonymously, mask your identity + manage accounts]
- IPFS File Store
  Securely store data through a censorship resistant file sharing protocol
- On-Chain Registry
  Bind verified digital certificates to org Ethereum addresses via on-chain registry
- Public Ethereum Tether
  Pin state proofs from your private chain to public Ethereum networks
- Connectors
  - If This Then That (IFTTT)
    - Automate workflows and exchange data to and from the chain with the IFTTT connector
  - Zapier
    - Automate workflows and exchange data to and from the chain with any Zapier app connection
  - Salesforce
    - Exchange chain data to and from your Salesforce CRM and applications
- Middleware
  - Event Streams:
    Trigger business processes, and stream data to off-chain caching or analytics
  - REST API Gateway
    APIs for all your Smart Contracts, backed by reliable Kafka streaming
- Partner Integrations
  - QEDIT Private Asset Transfer
    Keep sensitive transactional data off the blockchain with zero-knowledge proof cryptography.
  - Openlaw
    Create, store and execute legal agreements for blockchain assets
  - Treum
    Model business processes, track assets + build supply chains faster
  - unchain.io
    Interact with an Ethereum smart contract on Kaleido via a simple API
  - Clause
    Store audit trail events from your Smart Clauses (TM) on your Kaleido blockchain.
  - Chainlink
    Provide external data to Ethereum smart contracts via oracle network
  - Rhombus
    Connect your smart contract with real-world data

- Developer Tools
  - MythX: Premier security analysis service for Ethereum smart contracts
  - Remix: Quickly and easily write, compile and debug smart contracts.
  - OpenZepplin: Reduce the risk of vulnerabilities in your applications by
    using standard, tested, community-based smart contract code.
  - MetaMask: Run dApps right in your browser without running a full Ethereum node.
  - Truffle: Truffle gets developers from idea to dapp as comfortably as possible

- Cloud Configurations
  - Amazon Web Services: Key Management backed by AWS KMS
    Create and control the keys used to encrypt your data
  - Log Streaming
    View and monitor your Kaleido resources in AWS CloudWatch
  - Backup your Ledger to AWS S3
    Backup your Ledger Data and Transactions to AWS S3 blob storage

- Federated Login:
  -  Implement simple and secure user sign-up, sign-in, and access control

- Private Networking
  Leverage secure network connectivity for sensitive data sharing
- Microsoft Azure
  - Key Protection
  - Key Management backed by Azure Key Vault
  - Log Streaming
    View and monitor your Kaleido resources in Azure Monitor
  - Data Backup
    -Backup your Ledger Data and Transactions to Azure blob storage

- Protocols: Geth, Quorum, Besu

• Kaleido Network Governance:
  - Kaleido Account:
@[https://docs.kaleido.io/using-kaleido/accounts-pricing]
- parent resource used to manage "super user" actions
  not related to the application:
  - organizational identity
  - shared administrators
  - consortia collaborators
  - uploaded certificates
  - administrative bearer tokens
  - current plan instance and billing orchestration.

• Kaleido Services:
@[https://docs.kaleido.io/kaleido-services/]
- Public Eth. Tether
- Ether pool
- Block Explorer
- HD Wallet
- IPFS
- ID Registry
- Eth-Connect

• Kaleido AWS Integration:
@[https://docs.kaleido.io/aws-integrations/using-aws-integrations/]

• Kaleido Troubleshooting:
@[https://docs.kaleido.io/support/troubleshooting/]

• Kaleido Developer Material:
- @[https://docs.kaleido.io/developer-materials/api-101/]
- @[https://console-eu.kaleido.io/]
- @[https://github.com/kaleido-io/kaleido-js]   NodeJS example (Offline TX signing in Azure,...)

• Kaleido Deploy in 10 minutes:
@[https://medium.com/coinmonks/deploy-a-private-ethereum-blockchain-in-10-minutes-with-kaleido-73c21a26d5bb]

• Kaleido + Truffle:
@[https://medium.com/coinmonks/connecting-to-kaleido-private-ethereum-blockchain-with-truffle-7ae7cc6a3234]

 PRE-SETUP 1: Deploy a private Kaleido Blockchain instance:
@[https://medium.com/coinmonks/deploy-a-private-ethereum-blockchain-in-10-minutes-with-kaleido-73c21a26d5bb]

 PRE-SETUP 2: Write down the publicpublic key from any wallet

 PRE-SETUP 3: Truffle Framework setup
$ npm install -g -production windows-build-tools  (Windows OS only)
$ npm install -g truffle
$ npm install truffle-hdwallet-provider-privkey #
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
              allows to sign and exec TXs by providing
              a private key that belongs to an existing
              Ethereum wallet. (generated by MetaMask,...)

$ cd ...
$ mkdir trufflekaleido
$ cd trufflekaleido

$ truffle unbox webpack # ← simplex box

 Kaleido STEP 1: Ether Pool
- paste your public key here to receive some ETH.

 Kaleido STEP 2: Edit/Create the contract
$ "vim" .../contracts/hello.sol
  |pragma solidity >=0.4.22 <0.6.0;
  |contract Mortal {
  |    address owner;
  |    constructor() public { owner = msg.sender; }
  |    function kill() public { if (msg.sender == owner) selfdestruct(msg.sender); }
  |}
  |
  |contract Greeter is Mortal {
  |    string greeting;
  |    constructor(string memory _greeting) public { greeting = _greeting; }
  |    function greet() public view returns (string memory) { return greeting; }
  |}

 Kaleido STEP 3.1: create truffle migration script
$ "vim" .../migrations/2_deploy_contracts.js
  |var mortal = artifacts.require("./Mortal");
  |var greeter = artifacts.require("./Greeter");
  |module.exports = function(deployer) {
  |deployer.deploy(greeter, 'Jack');
  |};

 Kaleido STEP 3.2: Setup truffle-config.js
var  HDWalletProvider = require("truffle-hdwallet-provider-privkey");
const  privKeys = [${private_key_in_hex_format_with_NO_leading_0x}] ;
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Ex: ["65c2d64f53211d8328c6db8e8bc22341c0f0b8d22989f40f4efd0ed55e3e3d8b"];
module.exports = {
  networks: {
    development: {
      provider: function() {
        return new   HDWalletProvide  (  privKeys , "http://kaleido_host:port");
      },                                             ^^^^^^^^^^^^^^^^^^^^^^^^
      network_id: '*',                               In the Kaleido interface select node then:
      gas: 4700000                                 - [Connect Node] →   [VIEW DETAILS]     → input SECRET-KEY → [Submit]
    },                                                              (under Native JSON/RPC)
    ganache: { ...  },                             - Copy the CONNECTION-URL under "Auth Type -INURL" section.
  },
  mocha: { ... }
  compilers: {...}
}


 Kaleido STEP 4: compile and run
$ truffle compile
$ truffle migrate
→ Running migration: 1_initial_migration.js
→   Deploying Migrations...
→   ... 0xbb56569292a0a5f47700f450dc8e166545308835b5fd8db7d09c00a306d83852
→   Migrations: 0xcdd5665ec87da674dc58549f2fc0bb8c514661bb
→ Saving artifacts...
→ Running migration: 2_deploy_contracts.js
→   Replacing Greeter...
→   ... 0xa3447e50d0de2a86c0325e975478399d8abe931efa6458a9deb78b0b24a89d82
→   Greeter: 0x96b9b7d5330021ed3e1ab2191482479def16c036

 Kaleido STEP 5: Testing the Contract
$ truffle console --network development
truffle(development)>
truffle(development)> Greeter.deployed().then(function(contractInstance) {contractInstance.greet().then(function(v) {console.log(v)})})
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                      Greeter.deployed().then(
                        function(contractInstance) {
                           contractInstance.greet().then(
                             function(v) {console.log(v)}
                           )
                        }
                      )
[[}]]

● EthrDIDs"uPort++" [[{02_use_case.identity,standards.W3C_DID,architecture,00_PM.radar]]
@[https://medium.com/uport/goodbye-uport-dids-hello-ethr-dids-ea2e80256f54]
@[https://github.com/uport-project/ethr-did-registry]
- Goodbye uPort DIDs, Hello Ethr-DIDs
  We have released a major app update that enables migrating all old uPort
  identities created before September 2018, to the current DID architecture.
  Not to worry though, your old Identity data will still be available to use
  and all verifications issued will be available
[[}]]

● EIP 648 [[{scalability.evm,standards.EIP/ERC.648,00_PM.TODO]]
@[https://github.com/ethereum/EIPs/issues/648] (V. Buterin)
• Introduce new type of transaction (following same general format as #232):
  [2, network_id, startgas, to, data, ranges]
  Where ranges is an RLP list, where each value in the list is an
  address prefix, representing the range of all addresses with that
  prefix.
• Rationale:
  transactions in the EVM to be processed in parallel much more easily,
  by specifying statically what addresses they can access; it also
  appropriately incentivizes making transactions that are easy to
  parallelize. It does this in a maximally backwards-compatible and
  non-intrusive way where old-style transactions can continue to work.
[[}]]

● Hyperledger Avalon, Improving Performance Off-Chain [[{scalability.offchain,security,00_PM.radar]]
  @[https://www.infoq.com/news/2019/10/Hyperledger-Avalon-Blockchain/]
  - It aims to move blockchain processing off the main
    chain to dedicated computing resources, e.g. Intel SGX TEE.
    using "computational trust".
  - Broadly supported blockchain project and  organizations like Intel,
    iExec Blockchain Tech, Alibaba Cloud, Baidu, Chainlink, ConsenSys,
    IBM, Microsoft and Oracle.
  - Project previously executed underneath the Trusted Compute Framework(TCF)
    name.
  - collaboration across the Hyperledger project, Enterprise Ethereum
    Alliance and the cloud provider ecosystem.

  - Who is Who:
    Eugene Yarmosh: systems architect at Intel, and has over 20 years
    of experience designing and building distributed and decentralized
    solutions spanning from embedded firmware to large-scale cloud
    solutions. During the last several years, Eugene has focused on
    scalability and privacy solutions for public and private blockchains,
    specifically utilizing HW based trusted execution environments (TEE)
    for off-chain workload execution. Eugene is an editor of the EEA
    Off-chain Trusted Compute Specification and is a lead architect for
    Hyperledger Avalon, a ledger-independent reference implementation of
    the Trusted Compute specification. He also holds several patents.
[[}]]

● AlphaWallet TokenScripts "Smart Tokens" [[{wallet.mobile,scalability.sidechain,privacy.offchain,00_PM.radar]]
    In short, it's like a SECURE FRONT-END FOR TOKENS.
  - AlphaWallet is a production-ready white-label wallet that is easy to
    customize. TokenScript is similar to web frameworks used by web apps,
    combining the attributes of a blockchain-based token and the perks of
    a web app, allowing users to interact directly with
    blockchain-powered applications and services.

  - It tries to solve the Trilemma "Security,Decentralization,Scalability".

  - It consists of protocols chaining Dapss with Side Chains and "Main" Chains
    converting "value" into "tokens" than can be used in the AlphaWallet
    mobile platform.  Its core strategy is to "move" as much as possible
    off-chain while keeping it only validation logic on-chain.

  - A TokenScript file is made of:
    - JavaScript to make Token work in the user's wallet or across multiple apps; and
    - XML data to extract status and value of the token.

  - Benefits
    - Run your tokens from users wallets as native, modular ‘Mini-DApps'
    - Extend token structure and realise rich functions with a single file
    - Portable across DApps
    - Sync updates at any time
    - Blockchain agnostic
    - Secure Enclave
    - DvP Security
    - Context based programming: User-experience
    - Attestation

  - Who-is-Who:
    Wei Wu Zhang: head of development for AlphaWallet

  • Portis is a self-custody blockchain wallet and Web3 access provider.
    It is powered by ShapeShift and provides access to multiple networks
    including Ethereum, Bitcoin, SKALE, xDai, and many others. It
    supports easy onboarding and user engagement and is trusted by a
    growing number of the most popular decentralized applications. Tom
    Teman, a co-founder at Portis, will be the presenter
[[}]]

● EIP-165: Standard Interface [[{standards.eip/erc.165,devops,12_solidity.101,architecture,20_QA.UX]]
  - NOTE: EIP-1820 improves over this standard, but EIP-165 is not
    deprecated and still in active use (e.g, required by EIP-1155)
    as of 2021-10

  - standard to publish and detect what interfaces a smart contract implements
    by detailing:

    - How interfaces are identified
    - How a contract will publish the interfaces it implements
    - How to detect if a contract implements ERC-165
    - How to detect if a contract implements any given interface

  - ERC-165 in practice:
  ┌─ .../IERC165.sol interface ─────────────────────────────────────┐
  │ interface IERC165 {                                             │
  │     function supportsInterface(bytes4 interfaceId)              │
  │     external view returns (bool);                               │
  │ }                                                               │
  └─────────────────────────────────────────────────────────────────┘
  ┌─ ERC1155.sol implementation ─────────────────────────────────────┐
  │ import ".../utils/introspection/ERC165.sol";                     │
  │ import "./IERC1155.sol";                                         │
  │                                                                  │
  │ contract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI {     │
  │     ...                                                          │
  │     function supportsInterface(bytes4 interfaceId)               │
  │     public view virtual                                          │
  │     override(IERC165)                                            │
  │     returns (bool) {                                             │
  │       return                                                     │
  │         interfaceId == type(IERC165).interfaceId             ||  │
  │         interfaceId == type(IERC1155).interfaceId            ||  │
  │         interfaceId == type(IERC1155MetadataURI).interfaceId ||  │
  │         super.supportsInterface(interfaceId);                    │
  │     }                                                            │
  │ }                                                                │
  └──────────────────────────────────────────────────────────────────┘
  - See also:@[#eip_1820] Pseudo-introspection Registry Contract
[[}]]

● EIP-1820: EIP-165"++" @ma [[{devops,standards.eip/erc.1820,12_solidity.101,architecture,20_QA.UX]]
https://eips.ethereum.org/EIPS/eip-1820
    - Pseudo-introspection Registry Contract
    - Status: Final
    - It improves (but does NOT replaces) EIP-165.
    - Superseed EIP-820 (universal registry)
[[}]]

●  HardHat https://hardhat.org/ (Truffle alternative) [[{dev_framework.js.hardhat]]
- TypeScript support (Compile time vs runtime errors).

- HardHat Framework can be seen briefly as its Hardhat Runtime Environment  (HRE):
  const hardhat /*HRE*/ = require("hardhat")
        └─────┴─ "==" 
   {
     /* core */           ┌ task: async function + metadata defining 
     config: ...,         v       "everything you can do in HardHat"
     "tasks..." : task1, task2, ... 
     "plugins..." : ...  

     /* others */
     artifacts : {
        readArtifact("contracts/A.sol:A"),
     }

   }

- Export EIP-1193 compatible Ethereum provider.

- Hardhat Runner: task runner designed around "tasks" and "plugins".
  $ npx hardhat compile ···(translates to)··-> runing built-in-task "compile"

  - plugins can override default task behaviour.

- Hardhat for VS Code: adds advanced support for Solidity. [[{IDE,dev_framework.js}]]

- Ussage:
  $ npm install --save-dev hardhat  <- PRESETUP: only local install is allowed to
                                       ensure reproducible builds.

  $ npx hardhat --help 
    Usage: hardhat [GLOBAL OPTIONS] <TASK> [TASK OPTIONS]
   
    GLOBAL                  │ AVAILABLE 
    OPTIONS:                │ TASKS:
    ---------------         │ ---------
    --config ...            │ check  ... whatever you need to check ...
    --emoji  yes|no         │ clean      Clears cache + artifacts
    --help                  │ compile    compile contracts/*, generate TS bindings
    --max-memory ...        │ console 
    --network ...           │ flatten    Flattens, prints contracts and dependencies
    --show-stack-traces ... │ node       Starts a JSON-RPC test node @http://127.0.0.1:8545/
    --tsconfig ...          │ run        ... user-defined script after compiling ...
    --verbose  ...          │ typechain  Generate Typechain typings for Compiled contracts
    --version  ...          │ verify     Verifies contract on Etherscan  [[security]]
                            │                                                                
                            │ coverage   [[13_SLC.testing.coverage]]
     ^^^^^^^^^^             │ test       test/*js *ts [[13_SLC.testing]]
     ENV.VARS: 
     - HARDHAT_NETWORK           (overriden by --network flag)
     - HARDHAT_SHOW_STACK_TRACES
     - HARDHAT_VERBOSE
     - HARDHAT_MAX_MEMORY

• Compared to Truffle there is no migrations/* directory.
  To deploy new contracts:
  STEP 1) Create standard deployment script (js/ts) using ethers.js
  STEP 2) $ npx hardhat run scripts/deploy.ts
[[}]]

● Non Classified / TODO: [[{00_PM.TODO]]
  • Mnemonic to Seed: [[{wallet.mnemonics}]]
  @[https://ethereum.stackexchange.com/questions/25484/could-address-reuse-leak-your-mnemonic-seed/25705#2570://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#from-mnemonic-to-seed]

 (mnemonic, passphrase) → (input to) → │PBKDF2│ ──────────────→  derived key ("seed")
  ^            ^^                         ^                      512 bits (64 bytes)
  └ UTF-8 NFKD ┘|              - Iter.count : 2048                ^
                |              - HASH       : HMAC-SHA512        Can be used to generate
                |                                                deterministic keys (wallets)
                |                                                (BIP-0032)
       every "random" passphrase
       generates a valid seed but
       only the correct one will
       make the desired wallet available

  • Azure offline signing: [[{wallet.cloud,signature.ecdsa_secp256k1,security,00_PM.TODO}>
   @[https://tomislav.tech/2018-02-05-ethereum-keyvault-signing-transactions/]

  • EthVM OOSS Blockchain Explorer focused mainly on Ethereum
    [[{20_QA.auditing,integration.*,13_SLC.monitoring,00_PM.radar}]]
    (although other networks and forks will be supported over time)
    under the SSPL license (a small variation of the GNU Affero License v3)
    and written in a mixture of different languages.
    - backed by popular frameworks:
        Apache Kafka = Kafka Connect + Kafka Streams + Kafka Schema Registry
        VueJs
        NestJS
    - Example ussage of Kafka streams as "micro-esb" to transform Etherum events:
    @[https://github.com/EthVM/EthVM/tree/develop/apps/processing/kafka-streams/src/main/kotlin/com/ethvm/kafka/streams]
</pre>

  • Solidity Security Considerations [[{12_solidity,security.101}]]
@[http://solidity.readthedocs.io/en/develop/security-considerations.html#security-considerations]

 • Ethereum Package Registry [[{20_QA.solidity,12_solidity,20_QA.UX,00_PM.radar}]]
  @[https://www.ethpm.com/]
  - A package index for Ethereum smart contract packages.
  - The Ethereum Package Registry is a package index for Ethereum smart contract
    packages. The registry is based on the ERC190 Smart Contract Packaging
    Specification.

    """Dear Ethereum,
    We need to talk. You're not the easiest platform to work with. Don't get me
    wrong, you have some great qualities but it's time to grow up and start
    acting a bit more... mature

    Since we care about you and really want you to succeed we made you something
    that should help. It's called a package index.

    I know change can be a little scary but we're sure that once you try it you'
    ll love it. Developers are going to like you more. Their bosses may even stop
    seeing you as the dangerous kid teaching their devs bad habits like copy/pasting code.
    Please give it a try. We really do want the best for you.


 • How to build server less applications for Mist
@[https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/]

 • https://buidler.dev/ (npm package) [[{12_solidity}]]
   @[https://www.npmjs.com/package/@nomiclabs/buidler-ethers]
   """ Turn a mess of tricky Solidity tools into a smooth workflow """
   ...
   - Buidler: task runner for Ethereum smart contract developers.

   - It works with all developer tools, rather than replace any       @ma
     specific ones. It's value comes from being the connective tissue,
     rather than from specific functionality. It's an integration
     platform for other tools to build upon.

 • Web3-Secret-Storage-Definition [[{wallet.standards,standards.secret_storage}]]
  @[https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition]

 • SmartCard USB HSM [[{wallet.hsm}]]
@[https://blog.coinfabrik.com/using-the-cardcontact-smartcard-usb-hsm-in-an-ethereum-poa-chain/]
   Using the CardContact SmartCard USB HSM in an Ethereum PoA Chain

 • ethpm-js: [[{dev_framework.js}]] https://github.com/ethpm/ethpm-js
   Javascript library for publishing and consuming Ethereum packages,
   on the Ethereum Package Manager specification. It is meant to be integrated
   directly into development tools to support their use of the Ethereum Package
   Management ecosystem.

 • https://etherscan.io/pushTx : Send raw-transactions

 • Mine Only on Pending TXs (avoid empty blocks) [[{10_EVM.implementation.geth,10_EVM.implementation.besu,scalability.evm}]]
   @[https://ethereum.stackexchange.com/questions/3151/how-to-make-miner-to-mine-only-when-there-are-pending-transactions]
   - How to make miner to mine only when there are Pending Transactions?
     As of now the geth miner running on my system mines even empty blocks.
   - How to do that same in Besu, Parity, ...?

 • Deconstructing a Sol. Contract [[{10_EVM.debugging,12_solidity}]]
@[https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/]

 • Ether Vault (Anti-theft) [[{wallet.cloud,security}]]
   https://www.blunderingcode.com/ether-vaults/
   - The basic idea is to have a hot wallet account, plus a contract which
     holds the bulk of your ether, and stores a vault key and recovery
     key. Most of the money is vaulted and inaccessible. To unvault some
     of it, use the vault key. After a delay the vault key can send the
     money to your hotwallet.

 • Ephemeral Testnet YOLO [[{13_SLC.testing,20_QA,standards.EIP/ERC,10_EVM}]]
   In preparation for the next network upgrade, Berlin, an ephemeral
   testnet called YOLO was launched with two new EIPs enabled: EIP-2315,
   which adds subroutines to the EVM, and EIP-2537, which introduces a
   new precompile for the BLS12-381 curve.

 • OrbitDB [[{persistence.offchain_objects,,20_QA.UX,architecture,scalability.offchain}]]
  @[https://orbitdb.org/]
  - OrbitDB is a serverless, distributed, peer-to-peer database. OrbitDB
    uses IPFS as its data storage and IPFS Pubsub to automatically sync
    databases with peers. It’s an eventually consistent database that
    uses CRDTs for conflict-free database merges making OrbitDB an
    excellent choice for decentralized apps (dApps), blockchain
    applications and offline-first web applications.

  - "Alternatives":
    - DOLT: Distributed SQL ddbb on top of Git.

 • EIP vs ERC [[{101,standards.EIP/ERC}]]
   - ERC are a subset of EIPs for application-level standards and
     conventions, including contract standards such as token standards
     (ERC-20), name registries (ERC-137), URI schemes (ERC-681),
     library/package formats (EIP190), and wallet formats (EIP-85).

 • LEGIONS: [[{13_SLC,persistence.contract_state,security]]
            [[devops,12_solidity.troubleshooting,20_QA.UX]]
  @[https://diligence.consensys.net/blog/2020/06/legions-a-tool-for-seekers/]
" Tool to poke around Geth Nodes in the terminal."
  -  Poke around a public Ethereum node JSON RPC endpoints?
  -  See if an Ethereum node is mining or not?
  -  Read the storage of a smart contract? And maybe see how the [[{13_SLC.debugging.state}]]
     storage changed between different block numbers?
  -  Get the bytecode of a smart contract without going to etherscan?
  -  List all ENS domains names owned by an address and their expiry dates?

  So I began building a tool for that specific engagement. As the
  engagement went on, certain other tasks kept cropping up, such as
  simple Wei to Eth conversion, or more challenging tasks like reading
  the storage of a smart contract.
  Is there anything better than a cool command-line interface?

  Legions is now open-source and also available on Pypi Package manager.

  Simply install the package for python 3.6+ and everything else should
  be easy to find with the interactive interface:

    $ pip install legions
  [[}]]

 • ethereum-etl: [[{integration.data,dev_framework.python,10_EVM.events,00_PM.low_code]]
   WARN: See limitation in Github Project page.
   Export blocks and transactions (Schema, Reference):
   $ python export_blocks_and_transactions.py \
   $   --start-block 0 --end-block 500000 \
   $   --provider-uri https://mainnet.infura.io \
   $   --blocks-output blocks.csv --transactions-output \
   $   transactions.csv

   Export ERC20 and ERC721 transfers (Schema, Reference):
   $ python export_token_transfers.py \
   $   --start-block 0 --end-block 500000 \
   $   --provider-uri file://$HOME/Library/Ethereum/geth.ipc \
   $   --output token_transfers.csv

   Export receipts and logs (Schema, Reference):
   $ python export_receipts_and_logs.py --transaction-hashes \
   $   transaction_hashes.txt \
   $   --provider-uri https://mainnet.infura.io --receipts-output \
   $   receipts.csv --logs-output logs.csv

   Export ERC20 and ERC721 token details (Schema, Reference):
   $ python export_tokens.py \
   $   --token-addresses token_addresses.csv \
   $   --provider-uri https://mainnet.infura.io --output tokens.csv

   Export traces (Schema, Reference):
   $ python export_traces.py --start-block 0 --end-block 500000 \
   $   --provider-uri file://$HOME/Library/Ethereum/parity.ipc \
   $   --output traces.csv
   [[}]]

 • Algorithmic stablecoins [[{02_use_case.finance.stablecoins,01_doc_has.comparative]]
REF: @[https://frax.finance/whitepaper/]
     @[https://github.com/FraxFinance/frax-truffle/blob/master/test/Frax-Tests.js]
- Although there are many ways to categorise stablecoins, two distinct
  design concepts have stood out over time:
  - collateralized stablecoins:
    - Main categories:
      - crypto-collateralized (MakerDAO’s Dai)
      - fiat-collateralized tokens (Tether, BUSD, USDC)
    (both subgroups having had significant adoption).
  - algorithmic stablecoins :
    - attempt to change the circulating supply of the token
      so that changes in demand for the stablecoin minimally
      affect its price.
    -   not collateralized or redeemable fo
        an underlying asset.
    - no significant traction (high profile attempts done):
      " ... We contend that a prevailing reason
        for the lack of traction of algorithmic
        stablecoins was not their economic
        infeasibility, but their flawed designs
        and execution..."
        https://frax.finance/whitepaper/   [[}]]


 • EthTrust [[{12_solidity,security,20_QA.auditing]]
   https://entethalliance.org/enterprise-ethereum-alliance-launches-ethtrust-security-initiative-to-advance-confidence-in-ethereum-as-a-global-settlement-layer-for-transactions-of-all-types/

  Enterprise Ethereum Alliance Launches EthTrust Security Initiative to
  Advance Confidence in Ethereum as a Global Settlement Layer for
  Transactions of All Types
  
  .. The Working Group’s mission will be to continue the advances begun
   by the Ethereum Trust Alliance (ETA), now part of the EEA, on the
   EthTrust project, that will :
    set standards for secure, smart contract transactions that are
    conducted within the Ethereum ecosystem.
  
     Given that it only takes one small flaw in smart
    contract code to instantly lock up or lose tens of millions of
    dollars, the EthTrust project’s standard and registry aim to make
    it quick and easy for organizations and individuals to tell if a
    smart contract has been through a full security audit by a
    professional team.
[[}]]

  • Turbo Geth [[{scalability.node_storage,implementation.turbo_geth]]
@[https://eth.wiki/en/fundamentals/patricia-tree]
    ...  Turbo-geth is one implementation that gets to the root of the
    problem: It flattens the trie database and uses the path of a node
    (rather than its hash) as the [key, value] pair. This effectively
    makes the depth of the tree irrelevant for lookups, and allows for a
    variety of nifty features that can improve performance and reduce the
    load on disk when running a full node.
[[}]]

 • SKALE framework [[{scalability.consensus]]
 @[https://skale.network/]
 @[https://skale.network/whitepaper] <!-- @ma -->
  SKALE Network. An Ethereum Interoperable Elastic Blockchain Network
  SKALE: Standard Kit for Asyncronous Ledgers.
  
  - SKALE is a modular framework that splits blockchain consensus (BC)
    under asynchronous networking model into a sequence of stages. It
    then applies provably secure algorithms at each stage, so that the
    entire BC becomes provably secure. This modular framework allows to
    construct a wide variety of BCs with different tradeoffs as well as
    re-interpret and analyze security some of the existing BCs such as
    Tendermint.
[[}]]

 • Uniswap [[{02_use_case.finance.liquidity_provision]]
   "fully decentralized protocol for automated liquidity provision on Ethereum".
    Uniswap is a good example of use-case when ethers are controlled by Smart Contracts
    (vs externally owned accounts).
   
   - centralized vs de-centralized exchange:
     centralized exchange (Coinbase,...):
     - PRE-SETUP: register for an account.
     - exchange monitors and facilitates transactions.
     decentralized exchange (Coinbase,...):
     - PRE-SETUP: Connected crypto wallet to Uniswap's app (no third party involved)
     - no registration required.
     - exchange operates as automated market maker offering various
       pairs of tokens to trade with prices set using mathematical formulas.
   
   - Uniswap cryptocurrency:
     - high-risk "investment".
     - governance token to vote on proposed changes for the exchange.
     - if the exchange gets more popular, it will likely lead to more
       people wanting to buy the token.
   
   - Implementation:
     - Exchange uses liquidity pools, "drawing" from them when users trade.
                     └──────┬─────┘
                     ej:
                     ( crypto1, crypto 2) fund  ← e.g.: (ETH, DAI) pool
                     ( crypto1, crypto 3) fund
                     ( crypto2, crypto 3) fund
                     ...

   ##############
   # PRE-SETUP: #
   ##############
   User_A            → Uniswap_Dapp_S.C: Signed TX "Add liquidity"
                                         (Lend equivalent amount of both cryptos to some Uniswap pool)
   Uniswap_Dapp_S.C  → Uniswap_Dapp_S.C: Add to pool.
                                          Pay share of the gas fees to user in that pool.

   ##################
   # SWAP Execution #
   ##################
   User_B            → Uniswap_Dapp_S.C: Signed TX with:
                                         - amount to trade  : N (owned) Ethers
                                         - Crytpo to receive: Dai

   Uniswap_Dapp_S.C  → Uniswap_Dapp_S.C: calculate Dai to be received
   User_B            ← Uniswap_Dapp_S.C: Dai to be received
   User_B            → Uniswap_Dapp_S.C: confirm the trade
   Uniswap_Dapp_S.C  → Uniswap_Dapp_S.C: Pay from internal Ethereum/Dai pool
                                         minus transaction (gas) fee, always
                                         paid in Ethers. This fee is shared among
                                         users "feeding" the pool in the "PRESETUP".
                                         NOTE: Fees in Ethereum depend on the congestion of the network,
                                               not on the value of the transaction.
                                               Uniswap is a poor choice for trading small swap amounts.

- Alternatives (inspired by Uniswap) include: ( PancakeSwap , SushiSwap , BurgerSwap , Curve , DODO )
   - One advantage several other exchanges offer is that they run
     on the Binance Smart Chain, which currently has much lower fees than Ethereum.
     Particularly succesful is the case of PancakeSwap.

- Options to "invest" in Uniswap include:
  - buy it through an exchange like any other cryptocurrency (Coinbase, Gemini, Binance, ...)
  - trade for it on Uniswap exchange.
[[}]]

 • QuickSwap [[{02_use_case.finance]]
@[https://coinquora.com/quickswap-the-dex-curating-an-economical-and-scalable-way-to-swap-tokens/]
  "... The tradeoffs of a blockchain are passed on to the project’s building on top of them.
   This is what happened with Uniswap, the world’s first decentralized token swap platform.
   It was the first decentralized exchange (DEX) of the crypto space, which attracted the
   community for its decentralization and ability to process trades without asking its users
   to go through rigorous KYC/AML processes. However, with all of the advantages UniSwap offers,
   its users suffer from high gas fees due to it being built on the Ethereum blockchain.
   A simple transaction on Uniswap now often costs more than the transaction itself,
   leaving a gap that needed filling.

   QuickSwap was quick to address the issues plaguing Ethereum-based DEXs,[[{10_EVM.GAS_PRICE,20_QA.UX]]
   by offering much lower transaction fees and almost instant block formation time. [[}]]

   QuickSwap DES allows users to trade any ERC-20 tokens. 
   It is powered by the Polygon network, which provides several
   benefits not seen in other similar solutions.

    For example, QuickSwap can trade any of the ERC-20 tokens listed
   on its platform with almost no gas costs and at lightning-fast
   speeds, making QuickSwap (and Polygon) a great accompaniment for
   UniSwap and Ethereum.

    Moreover, anyone can list any ERC-20 token on QuickSwap by
   providing liquidity to enable token swaps.  In return, the platform
   rewards them with a 0.3% transaction fee (out of which 0.25% goes to
   the LPs, 0.04% to the dragon’s lair (which is the QUICK staking
   pool), and 0.01% goes to  QuickSwap’s treasury (to fund
   development).

    In addition to the trading fee, liquidity providers can earn
   QuickSwap’s native governance QUICK token – which they can use to
   create, vet, and vote on proposals relating to the running of the
   protocol. They can also use QUICK tokens to stake  in the Dragon’s
   Lair to earn additional QUICK.

• Reference Implementation: 
  https://github.com/mudgen/quickswap-contracts/] By Nick Mudge ("Diamonds Standard")
[[}]]


 • Hapi One: https://www.hapi.one [[{02_use_case.finance.compliance,02_use_case.finance.fraud]]
                                  [[ standards,20_QA.auditing,00_PM.RADAR]]
   - On-Chain Cybersecurity Cross-Chain Protocol and Oracle
     data -> ML -> Oracle -> DAO
   - Monitor for frauds, stolen-wallets, ...
   - Works on Polygon.Network (cross-chain Ethereum compatible networks) [[}]]

 • FireFly IoT Wallet [[{02_use_case.IoT,20_QA.UX]]
  @[https://firefly.city/]
  @[https://ethereum.stackexchange.com/questions/29524/sign-raw-transaction-offline-with-c-on-arduino]
    use our Firefly Hardware Wallet (https://firefly.city) for the ATmega328 to do:
  - secp256k1 signing
  - RLP decoding transactions
  - keccak256
  - generating checksum addresses (or raw addresses)
  - Signing requires in the neighbourhood of around 700 bytes of free memory,
    everything else requires a fairly slim memory footprint.
  - Optional OLED display: Firefly source code also includes zero-memory video driver.
  @[https://github.com/firefly/wallet/tree/master/source/libs/ethers]
  [[}]]

 • Raiden Network: (Micro) Payment channels [[{02_use_case.micropayments,scalability.payment_channels}]]

 • ZkOpru [[{layer2.rollup.optimistic,privacy.zksnark,scalability.layer2]]
      https://github.com/zkopru-network/zkopru
      - Ethereum L2 scaling solution for private transactions using
        zk-SNARK and optimistic rollup. [[}]]

  • L2 Exchanges:[[{layer2.rollup.stark,02_USE_CASE.finance.trading,scalability.layer2]]
    - major centralized exchanges integrating Layer 2:
      BInance, OKEx (also with Arbitrum),  Coinbase (Polygon's
      Layer 2 planned, Arbitrum, Optimism, Starkware on radar),

    - Decentralized protocols:
      Uniswap, 1inch, Aave: Already integrate with Arbitrum's and
      other Layer 2 technologies into their platforms.

    -  WARN:!!!!  @ma
    -  Binance's Arbitrum integration comes at a time when Binance Smart
       Chain (BSC) validators are complaining that the network is poorly run.
       "BSC is a lost cause," one GitHub user posted earlier this week, fo
        instance. "There is zero responding to bug reports. Hundreds of
        people report non syncing nodes or nodes falling out of sync.
        Response from the 'developers' - zero."
     https://github.com/binance-chain/bsc/issues/553  [[}]]

  • StarkNet proof system [[{layer2.rollup.stark,scalability.layer2}]]
    https://starkware.co/stark/
    - STARK is a proof system based on cutting-edge cryptography to
      provide polylogarithmic verification resources and proof size, with
      minimal and post-quantum-secure assumptions.
      White paper: @[https://eprint.iacr.org/2018/046.pdf]
    - Alpha State as of 2022-02-22
    - StarkNet is a permissionless decentralized ZK-Rollup. It operates
      as an L2 network over Ethereum, enabling any dApp to achieve
      unlimited scale for its computation – without compromising
      Ethereum's composability and security.

  • ERC-2309: Standarized event emitted when creating/tranferring
    1+ NFTs using consecutive tokens ids.

  • Ethereum 2.0 delegators? [[{consensus.ethereum2]]
    How Proof of Stake Addresses Scalability, Why Validator and 
    Delegator Economics Matter, and Why Yield Farming is a Thing.
    Join Konstantin Richter of Blockdaemon as he explores what it takes
    to operate nodes for blockchain networks as well as detail the
    improvements that the Proof of Stake consensus model will bring to
    Ethereum and Layer 2 networks. He will dive into the new world of
    validator and delegator staking and how it serves as a key element in
    providing scalable networks while ensuring secure and collusion
    resistant transaction settlement. Lastly, he will discuss DeFi,
    explain what yield farming is, and put the current chase for APY
    (annual percentage yield) in crypto into better context for all.
    About the Speakers
    Konstantin Richter is the CEO and Founder of Blockdaemon. He is a
    serial entrepreneur and investor. He has led several SaaS B2B
    companies towards meaningful exits in the media/advertising space,
    most notably, Audiotube, Lookbooks, and Wiredrive. He also is an
    advisor to blockchain company Gem, and serves on the board of
    MadHive, a leading media/advertising blockchain business. He
    currently serves as the CEO and founder of Blockdaemon, the most
    battle-tested blockchain infrastructure platform for major blockchain
    protocols. [[}]]

  • Security Attack:
    https://www.theblockcrypto.com/post/84804/defi-protocol-origin-attack-7-million-lost

  • https://academy.binance.com/en/articles/what-are-flash-loans-in-defi

  • eth_getLogs
    Returns an array of logs matching a specified filter object.
    Leave the - -auto-log-bloom-caching-enabled command line option at
    the default value of true to improve log retrieval performance.

  • BitGo: digital asset trust company and security company (2013+),
    headquartered in Palo Alto, California
    The company offers a multisignature bitcoin wallet service,
    where keys are divided among a number of owners to manage risk.
    Generally, BitGo wallets have three keys:
    - one held by BitGo,
    - two held by the wallet's owner.
    - Wallets can be configured in:
      - hot |  cold  mode.
      - non-custodial  | custodial.

    - In January 2015 BitGo announced the general availability of their
      Platform API.
    - The BitGo SDK enables the following:
      - Creation of multi-signature wallets
      - Transaction creation and signing

      - Transaction monitoring and notifications
      - Wallet balance and transaction listing
      - Secure user authentication
      - Multi-user workflows for use in enterprise environments.
      - Policies and spending limits

  • Bitstamp API: [[{02_use_case.finance.trading,architecture.API]]
    - Ticker: returns BTC/ETH/... TO USD/EUR/GBP/... currency pair.
    - Hourly Ticker:
    - EUR/USD conversion rate
    - Order book:
      Returns dictionary with "bids" and "asks".
      Each is a list of open orders and each order is represented as
      a list holding the price and the amount.
    - Transactions:
      Descending list of transactions.
    - Trading pairs info: Returns list of pairs (minum order, trading
      engine status, decription,...) [[}]]

    - OHLC data: returs dictionary of tick-data for selected trading pair.
      Each tick in the dic is rpresented as a list of OHLC data
      - OHLC == Open high low close chart.
      - pair
      - high
      - timestamp
      - volume
      - low
      - close
      - open
 • web3j: Valid private key range not enforced ·
   https://github.com/web3j/web3j/issues/502

 • web3j: Generate wallet from Ganache test account private key · Issue #697 · web3j/web3j
   https://github.com/web3j/web3j/issues/697 

 • web3j:  web3j: Expose hardened bit in Bip32ECKeyPair for other libraries
   web3j/web3jhttps://github.com/web3j/web3j/issues/838 

 • web3j: Adding support of hardware wallets to web3j
   web3j/web3jhttps://github.com/web3j/web3j/issues/892 

 • web3j: Different privateKey generated by Mnemonic comparing to other libraries
   web3j/web3jhttps://github.com/web3j/web3j/issues/919 

 • Introducing LUXOR - a spreadsheet for decentralized data. [[{00_PM.RADAR}]]
   https://m.youtube.com/watch?v=DmFLWpV7nGQ

 • Understanding Diamonds on Ethereum - DEV @ma
   https://dev.to/mudgen/understanding-diamonds-on-ethereum-1fb
   https://dev.to/mudgen/what-is-diamond-storage-3n7c 

 • Total Value Locked in DeFi Tripled in a Month ConsenSys Codefi
   https://codefi.consensys.net/blog/total-value-locked-tripled-newsletter-8

 • https://www.infoq.com/news/2021/01/mastering-blockchain-3rd-ed-qa/
    Bashir: A lot of work has been done on scalability. Solutions
   such as ZK-rollups, lightning network, state channels, and plasma are
   all new technologies that have been developed, indicating significant
   progress in this area.

 • C&P from: https://github.com/q9f/secp256k1.cr
   - private keys are scalars
     public  keys are points with (x , y) coordinates.

   - bitcoin public keys can be uncompressed #{p}#{x}#{y} or compressed
     #{p}#{x}. both come with a prefix p which is useless for uncompressed
     keys but necessary for compressed keys to recover the y coordinate on
     the secp256k1 elliptic curve.

   - ethereum public keys are uncompressed #{x}#{y} without any prefix.
     the last 20 bytes slice of the y coordinate is actually used as
     address without any checksum. a checksum was later added in eip-55
     using a keccak256 hash and indicating character capitalization.

   - neither bitcoin nor ethereum allow for recovering public keys from
     an address unless there exists a transaction with a valid signature
     on the blockchain.

 • https://medium.com/coinmonks/hierarchical-deterministic-wallets-ethereum-589f8a359b81
   This article walks you through how to create ethereum compatible
   hierarchical deterministic wallets. This should enable you to
   generate your own public - private keys, checksums and addresses for
   transactions.
   We’ll be using bip39, ethereumjs-tx, ethereumjs-util, hdkey and web3.js.
   - BIP39: To generate mnemonics
   - Ethereumjs-tx: To create the transaction (Set params and serialize)
   - Ethereum-util: To leverage checksum, private-public key creation and convert public
     key to address
   - HDkey: To construct Hierarchical Deterministic key trees

  [Interoperability,scalability,payment_channels]
    https://stakenet.io/
    https://github.com/X9Developers/DexAPI

    "The first trustless interchain economy"

       Combining Lightning Network and Masternodes into a global
    blockchain for decentralized applications.  XSN is the cryptocurrency
    powering the network.

    - XSN is programmable digital money.
      It is the native cryptocurrency of Stakenet
      and powers its decentralized applications.
      Instant transactions with virtually zero fees

    - XSN is digital money with instant, infinitely scalable transactions, and near zero fees over Lightning Network.
      Cross-chain connected over Lightning Network

    - XSN can operate with other blockchains. It runs on a decentralized, very secure, and trustless cross-chain blockchain.
      Masternodes on a highly secure PoS blockchain

    - Masternodes run dApps and services on one of the most secure PoS blockchains, utilizing Trustless Proof of Stake.

  • What's new ConsenSys Quorum 21.1.0:
  - advancements for Mainnet development, features to help lower
    costs and increase ease of use
  - New features for GoQuorum and Hyperledger Besu include:
   - Berlin Network Upgrades in preparation for the hardfork
   - Mainnet Launcher  makes it easy to create a config file for an
     Ethereum client at start-up
   - Bonsai Tries a new database format which reduces storage
     requirements and improves performance for access to recent state
   - Node Hibernation to eliminate unnecessary costs when activity is
     reduced for a significant period of time
   - Multi-Tenancy to allow a number of users to use the same Ethereum
     node to connect to the network & thereby reduce costs
   - Learn more about the new features in this release on our blog

 • Etherum Offline TX signature in with JS in Azure: [[{wallet}]]
   Snippet example from Kaleido examples:
   REFs:

   https://github.com/kaleido-io/kaleido-js/blob/master/deploy-transact/lib/azure-signing.js
   https://tomislav.tech/2018-01-31-ethereum-keyvault-generating-keys/
   https://tomislav.tech/2018-02-05-ethereum-keyvault-signing-transactions

   WARN: According to this link  the secp256k1 curve spec (used by
   Bitcoin and Ethereum signatures) is only available in Azure Key Vault
   under Premium SKU, not Standard.

    async signTx(signedTx) {
      // signature on the tx is over the hash of the tx
      let hash = signedTx.hash(false);
      // now ask Azure to sign the hash
      let res;

      // reference: blog by Tomislav Markovski
      // https://tomislav.tech/2018-02-05-ethereum-keyvault-signing-transactions/
      try {
        // The output of this will be a 64 byte array. The first 32 are the value for R and the rest is S.
        res = await
    //${serviceName}.vault.azure.net`,   // ← sign directly by setting signature key.
              keyName, keyVersion, 'ECDSA256', Buffer.from(hash));
      } catch(err) {
        throw new Error('Failed to get signature from the signing service', err);
      }

      // standard ethereum signature object has "r", "s" and "v"
      let sig = {
        r: res.result.slice(0, 32),
        s: res.result.slice(32)
      }

      // find the recovery ID by trying the possible values (0, 1, 2, 3) with "recover"
      let account = await this.getAccount();
      console.log(`\tRetrieved account from Azure key vault: ${account.address}`);
      let recoverId;
      for (let i of [0, 1, 2, 3]) {
        let recovered = this.web3.eth.accounts.recover({
          messageHash: '0x' + hash.toString('hex'),
          v: '0x' + (i + 27).toString(16),
          r: '0x' + sig.r.toString('hex'),
          s: '0x' + sig.s.toString('hex')
        });

        if (recovered.toLowerCase() === account.address.toLowerCase()) {
          recoverId = i;
          break;
        }
      }

      sig.v = recoverId + 27;

      if (signedTx._chainId > 0) {
        sig.v += signedTx._chainId * 2 + 8;
      }
      Object.assign(signedTx, sig);

      return signedTx;
    }
  • IPFS at TLDR:
    https://github.com/tldr-pages/tldr/blob/master/pages/common/ipfs.md

  • https://www.komputing.org/  qa, monitoring, auditing,
    Decentralized Metadata and Source Code Repository
    Sourcify is a decentralized automated contract verification service,
    which makes publishing and verifying source code easy.
     -  Choose network from dropdown menu
     -  Input contract address
     -  Upload all metadata and contract files that you want to verify via the dropzone

    Together with the compilation metadata, everyone can re-compile the
    smart contract and be sure that the source code is exactly the same
    as at deploy time, including every comment.

  • scalability,cross-chain,ILP:
    Peter Robinson of ConsenSys will discuss the General Purpose Atomic
    Crosschain Transaction (GPACT), a protocol that allows composable
    programming across multiple Ethereum blockchains. It allows for
    inter-contract and inter-blockchain function calls that are both
    synchronous and atomic -- if one part fails, the whole call graph of
    function calls is rolled back. The protocol operates on existing
    Ethereum blockchains without modification. It works for both public
    permissioned and consortium blockchains. Additionally, the protocol
    is expected to work across heterogeneous blockchains other than
    Ethereum.

  • EEA DeFi Interest Group:
    - Bringing Definition to an Emerging Innovation
        workshop on DeFi will focus on current issues that need to be
      addressed for DeFi to really flourish.
        explore what the ideal world looks like for DeFi years from now.
      - Attendees will:
        - Help define near-term goals and objectives for the DeFi Interest Group
        - Work in collaborative breakout sessions with other finance-minded members
        - Help bring definition to the array of challenges facing the community
        - Play a part in outlining what the future of DeFi can look like

  • https://github.com/fergarrui/ethereum-security
    Repository with some Ethereum security bugs. The bugs and fixes
    are demonstrated using Mocha tests.

    Bugs added so far:
    - Overflow
    - Underflow
    - Reentrancy (DAO hack)
    - Delegatecall (Parity hack style)
    - DOS (e.g. stay as an Auction leader forever)
    - DOS (unbounded array loop)
    - Force ether (relying on the invariant this.balance == 0)
    - Tx.origin
    - Unchecked send() output
    - Storage override (commonly used in honeypots - or genuine bugs)
    - Array storage override (length underflow - storage override)
    - extcodesize bypassed when used to check if the caller is a contract

  • Ethereum 2: knowledge base
    https://consensys.net/knowledge-base/ethereum-2/

  • https://github.com/fravoll/solidity-patterns @ma

  • EVM Add diagram similar to:
    https://fullstacks.org/materials/ethereumbook/14_evm.html

  • Infura, low_code, reliability, transaction:
    https://blog.infura.io/why-you-should-use-infura-transactions-instead-of-building-your-own-in-house-relayer/
    - Problems with stuck TXs and how to solve them using infura TX relayer.
    Infura Alternatives include:
    - https://deploy.radar.tech/
    - https://alchemyapi.io/

  • truffle-teams:
    https://www.trufflesuite.com/blog/iterate-faster-with-truffle-teams
    Truffle Teams provides now a complete workflow including building,
    testing, managing, monitoring, and debugging. This means you’re
    getting a huge boost in productivity.

  • Ethereum Upgrade Moves Into Final Stages
    The London upgrade should be ready by the end of July,2021 and willi
    come to the Ropsten testnet next week. There will be five EIPs in the
    London upgrade, including the much anticipated EIP-1559, which will
    change how gas fees work on Ethereum and what happens to those gas
    fees.

  • Kauri-io Archive. Java Ethereum:
    https://github.com/kauri-io/archive/tree/main/docs/communities/Java%20Ethereum

  • See Plasma World Map in:
    https://medium.com/paradigm-fund/ethereum-report-zk-snarks-on-ethereum-mainnet-by-aztec-sandbox-for-playing-with-minimum-viable-a4ac80121fec

  • Use golang to interact with Ethereum.
    https://www.programmersought.com/article/99731280412/

  • devops.deployment.smartcontract,20_QA.UX @ma
    A Buidler Plugin For Replicable Deployments And Tests
    · Created by Ronan Sandford (wighawag), a prominent smart contract developer and
      an author of the ERC-1155 standard
    · Supports the diamon standard.
    https://www.npmjs.com/package/buidler-deploy

  • Billion dolar mistake, inmutable code, qa:
    https://docs.soliditylang.org/en/latest/contracts.html#constants

  • standards,wallets,js, @ma
    https://eips.ethereum.org/EIPS/eip-1193

    Summary: A JavaScript Ethereum Provider API for consistency across
             clients and applications.

    Abstract:
    A common convention in the Dapps ecosystem is for key-management-software
    (“wallets”) to expose their API via a JavaScript object in the web page.
     This object is called “the Provider”  (window.ethereum)

    - Historically, Provider implementations have exhibited conflicting
    interfaces and behaviors between wallets.
    - This EIP the API and is designed to be minimal, event-driven, and
    agnostic of transport and RPC protocols.
    - Can easily be extended with new RPC methods and message event types.

    Ej: from https://github.com/trufflesuite/ganache
        (EIP-1193 vs "alternatives")
        - Ganache As an EIP-1193 provider only:
          const ganache = require("ganache");

          const options = {};
          const provider = ganache.provider(options);
          const accounts = await provider.request({ method: "eth_accounts", params: [] });

        - Ganache As an EIP-1193 provider and JSON-RPC web server:
          const ganache = require("ganache");

          const options = {};
          const server = ganache.server(options);
          const PORT = 8545;
          server.listen(PORT, err => {
            if (err) throw err;

            console.log(`ganache listening on port ${PORT}...`);
            const provider = server.provider;
            const accounts = await provider.request({ method: "eth_accounts", params:[] });
          });

        - Ganache As a web3.js provider:
          const Web3 = require("web3");
          const ganache = require("ganache");
          const web3 = new Web3(ganache.provider());           ←  alt 1: depending on web3 version
          const web3 = new Web3(ganache.provider(),            ←- alt 2: depending on web3 version
                               null,
                       { transactionConfirmationBlocks: 1 });

        - Ganache As an ethers.js provider:
          const ganache = require("ganache");
          const provider = new ethers.providers.
                             Web3Provider(ganache.provider());

  • https://kalis.me/assert-reverts-solidity-smart-contract-test-truffle/


  • Solidity:
    https://jeancvllr.medium.com/solidity-tutorial-all-about-bytes-9d88fdb22676

  • Solidity:
    https://blog.polymath.network/try-catch-in-solidity-handling-the-revert-exception-f53718f76047
  • https://entethalliance.github.io/client-spec/spec.html
    https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4

  • privacy: (Solution comparative between EEA, Fabric, Corda)
    https://www.linkedin.com/pulse/blockchain-myths-data-visibility-conor-svensson/

  • Ethereum backed DNS names becomes mainstream by integrating with Cloudflare:
    https://es.cointelegraph.com/news/ethereum-based-domain-names-go-mainstream-with-cloudflare-integration

    - Dns over ethereum: Unstoppable Domains
      https://unstoppabledomains.com/

  • Ethereum, scalability: Developer Documentation - Avalanche
    https://docs.avax.network/
    - OOSS platform for launching Dapps and enterprise blockchain
    deployments in one interoperable, highly scalable ecosystem.
    - 1st smart contracts platform that processes 4,500+ transactions/second
      and instantly confirms transactions. Ethereum developers can quickly
      build on Avalanche as Solidity works out-of-the-box.

  • ethereum,web3j,integración: web3j_openapi @ma
    http://docs.web3j.io/latest/web3j_openapi/

  • https://www.linkedin.com/pulse/blockchain-myths-data-visibility-conor-svensson/

  • Ethereum Tally arbitrary precision arithmetic library on the EVM
    https://youtu.be/N8Es2iPLGzY

  • Hyperledger Besu: Understanding and Applying the Options and
    https://consensys.net/blog/quorum/understanding-and-applying-the-options-and-subcommands-with-hyperledger-besu/

  • 101,TODO:
    https://etherbasics.com/the-basics/phases-of-ethereum/
    https://blog.ethereum.org/2015/03/03/ethereum-launch-process/

  • blockapps Strato [architecture,integration.*,dev_framework.strato,00_PM.TODO]
    C&P from https://docs.kaleido.io/kaleido-platform/protocol/ethereum/
    In order to address the enterprise unique needs for privacy,
    scalability, governance and deployment options, a number of companies
    both big and small have worked independently to create versions of
    Ethereum clients that support permissioned deployments. These include
    Quorum by JPMorgan, Autonity by Clearmatics, Hyperledger Besu by
    PegaSys (a team in ConsenSys), and Strato by BlockApps. For the last
    couple of years these company have started working collaboratively
    under the leadership of Enterprise Ethereum Alliance (EEA)
    organization, where Kaleid has been an active contributor, to create
    a robust Enterprise Ethereum technical specification.

    EE Client   Modified From      Developer       License
    Quorum      go-ethereum        JPMorgan Chase  LGPL
    Besu        N/A                PegaSys         Apache 2.0
    Autonity    go-ethereum        Clearmatics     LGPL
    Strato      Haskell Ethereum   BlockApps   Closed-source ←---

    - @[https://developers.blockapps.net/]
    - @[https://github.com/blockapps]
    - Strato Architecture:
    @[https://github.com/blockapps/strato-getting-started]
    - @[https://github.com://github.com/blockapps/strato-openshift]

    - rapid deployment blockchain solution built for businesses:
    - Integrate - Easily integrate with legacy web applications and databases using
      a REST API
    - Manage - Authenticate access to your APIs and protect your critical assets
    - Search - Search millions of smart contracts in seconds using normal
      easy-to-learn SQL queries
    - Protect - Transact privately with network participants and configure user
      visibility
    - Upload - Upload existing business data to the blockchain to bootstrap a new
      project
    - Deploy - Host a STRATO node on Microsoft Azure, AWS, or Google Cloud Platform

  • https://polymath.network/

  • Open Zepellin (OZ) Summary [dev_framework.zepellin,12_solidity,security.aaa,20_QA,00_PM.TODO]
    WARN: upgradable contracts, the "core" of OZ, looks to be replaced by "Diamon Standard"
    @[https://github.com/OpenZeppelin/]
    - TODO: Summary of "important" libraries

    - OZ 2.0 API:
    @[https://openzeppelin.org/api/docs/access_Roles.html]         [aaa]

    - Roadmap:
      @[https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab#.xk3bv3cw8]

    - O.Zepelling RBAC:                                            [aaa]
    @[https://openzeppelin.org/api/docs/ownership_rbac_RBAC.html]

    - Upgradable Contracts                                         [qa]
      To be replaced with Diamon standard:
      https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2537

    - @[https://blog.zeppelinos.org/getting-started-with-zeppelinos/]
    - @[https://paulrberg.com/post/2018/12/30/upgradeable-smart-contracts/]

    - ZeppelinOS "zos" is a command line tool to makes writing upgradeable
      contracts extremely easy, abstracting away the complexities of
      upgradeability.
    -  It is based on proxy libraries as explained at:
      @[https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd]

    WARN: Upgradeability can NOT be applied to already-deployed contracts.

    $ npm install --global zos      ← ZOS install

                                      ZOS ussage
    $ mkdir zos-demo && cd zos-demo   ==========
    $ npm init -y
    $ zos init zos-demo             ← create  zos.json  config.file
                                      makes ZOS aware of your smart contract
                                      architecture.
                                      Can (Must) be added to git.

    $ npm install --save zos-lib    ← "contracts" folder will be created

    $ vim contracts/CounterContract.sol
     pragma solidity ^0.4.21;
     import "zos-lib/contracts/migrations/Migratable.sol";

     ┌───────────────────────────────────────────────────────
     │ contract CounterContract is Migratable {
     │
     │   uint256 public counter;
     │
     │   // initialize replaces constructor in upgradable contract
     │   // guaranting that the new contract version can only be initialized once.
     │
     │   function   initialize (uint256 _counter)
     │     // isInitializer takes the name of contract and version ID
     │      isInitializer("CounterContract", "0")  public {
     │     counter = _counter;
     │   }
     │
     │   function increment() public { counter += 1; }
     │ }
     └───────────────────────────────────────────────────────

        WARN : If using a constructor in an upgradeable smart contract,
               everything set in there will be ignored.

      ###############
      # ZOS Testing #
      ###############
      ("npm install --save ganache-cli" if not already done)
      $ npx ganache-cli --port 9545

      $ zos add CounterContract  # ← STEP 1: Add smart contract to zos
      $ zos push --network local # ← STEP 2: push it to the local network:

      $ zos create CounterContract \ ← create&>initialize upgradeable instance
            --init   initialize  \
            --args 42 \              ← must match the   initialize  method.
            --network local
      → ...
      → ...   CounterContract proxy: <address>   ← address to use for instance
      → ...                                       (save somewhere safely!)

    $ truffle console --network=local  ← enter truffle interactive console
      > counterContract = CounterContract.deployed()    # Alt 1:
      > counterContract = CounterContract.at("address") # Alt 2:
      > counterContract.increment()                     # Call public method
      > counterContract.counter().then(counter => counter.toNumber())
      → 43
      truffle> .exit

    ################################
    # Upgrading deployed contracts #
    ################################

    $ vim  contracts/CounterContract.sol

      contract CounterContract is Migratable {
        uint256 public counter;
   +    mapping(uint256 => address) public history; //   *1
        ...

   +    function incrementByTwo() public {
   +      counter += 2;
   +      history[counter] = msg.sender;
   +    }
      }
      *1 WARN :
         When writing new versions of your contract, you must preserve
         all variables that appear in previous versions of your smart contract
         in the same order.
         You should only make additive changes

  $ zos push --network local                    # ← Push new version.
  $ zos update CounterContract --network local  # ← update CounterContract to new version


      Test new version  #
    $ truffle console --network=local
       > counterContract = CounterContract.deployed() # alt 1
       > counterContract = CounterContract.at("address")
       > counterContract.incrementByTwo()
       > counterContract.counter().then(counter => counter.toNumber())
       → 45
       truffle counterContract.history(45)
       → 0x....

     WARN:  When reseting Ganache dev network restart all over,
            deleting also zos.local.json. This isn't a problem
            for non-dev. networks :D)

  - ZOS TODO:
  @[https://blog.zeppelinos.org/getting-started-with-zeppelinos/]
  @[https://docs.zeppelinos.org/docs/advanced.html#deploying-to-mainnet]
  @[https://docs.zeppelinos.org/docs/basil.html]  (Advanced Tutorial)
  @[https://docs.zeppelinos.org/docs/crafty.html] (Advanced example -Crafty)

  - Realted External Links:
  @[https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2]
  @[https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88]
  @[https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c]

  • awesome-quorum: https://github.com/ConsenSys/awesome-quorum

  • https://www.trufflesuite.com/docs/truffle/db/ @ma
    - complete system of record to track information about smart contracts and their development histories.
    - Information is organized as content-addressed, immutable resources
    - Use-cases:
      - reproduce prior builds
      - single source of truth in development life cycle from source code to deployment.
    - features:
      - track the continuity of a smart contract as it is implemented.
        (even in case of  hard-forks).
      - Blockchain data and metadata is never forgotten.
      - GraphQL interface
      - data persisted to several backend through PouchDB.
    - Ussage:
      $ truffle db serve   ← Starts GraphQL Playground HTTP server.

  TODO: recheck transaction subtopics.

 • https://ethereum-magicians.org/t/in-one-swoop-the-eth2-0-devs-destroyed-staking/7379


 • Headlong [dev_framework.java,dev_framework.headlong,10_EVM.abi,dev_framework.web3j,01_doc_has.comparative]
   @[https://github.com/esaulpaugh/headlong]
 - A Contract ABI and Recursive Length Prefix library in Java for use on the Ethereum network.
 - Contract ABI and Recursive Length Prefix made easy in Java (or Android).
   Everything heavily optimized for maximum throughput (ABI function
   call encoding  up to 500x faster than a popular competito   and one
   function creation plus one encode is up to 60x faster
   ("f(uint,uint32[],bytes10,bytes)", openjdk 11.0.1)).


  • Solidity RLP: [evm.rlp,12_solidity.persistence,00_PM.TODO]
    - @[https://github.com/hamdiallam/solidity-rlp]
      Currently support for solidity v0.5.0

    - The reader contract provides an interface to first take RLP
      encoded bytes and convert them into an internal data structure,
      RLPItem through the function, toRlpItem(bytes). This data structure
      can then be destructured into the desired data types.

      import "solidity-rlp/contracts/RLPReader.sol"

      contract SomeContract {

          // optional way to attach library functions to these data types.
          using RLPReader for RLPReader.RLPItem;
          using RLPReader for RLPReader.Iterator;
          using RLPReader for bytes;

          // lets assume that rlpBytes is an encoding of [[1, "nested"], 2, 0x<Address>]
          function someFunctionThatTakesAnEncodedItem(bytes memory rlpBytes) public {
              RLPReader.RLPItem[] memory ls = rlpBytes.toRlpItem().toList(); // must convert to an rlpItem first!

              RLPReader.RLPItem memory item = ls[0]; // the encoding of [1, "nested"].
              item.toList()[0].toUint(); // 1
              string(item.toList()[1].toBytes()); // "nested"

              ls[1].toUint(); // 2
              ls[2].toAddress(); // 0x<Address>
          }

          // lets assume rlpBytes is an encoding of [ ["sublist"] ]
          function someFunctionThatDemonstratesIterators(bytes memory rlpBytes) public {
              RLPReader.Iterator memory iter = rlpBytes.toRlpItem().iterator();
              RLPReader.Iterator memory subIter = iter.next().iterator();

              // iter.hasNext() == false
              // string(subIter.next().toBytes()) == "sublist"
              // subIter.hasNext() == false
          }
      }

  • Exploring Ethereum's Data Stores: A Cost and Performance Comparison
    https://www.youtube.com/watch?v=tmRj7cYxxBY

  • https://openzeppelin.com/defender/
    - Automate and secure all your smart contract administration
      Administration mistakes on protocols and applications put user
      funds at risk. With Defender Admin, you can seamlessly manage all
      smart contract administration including access controls, upgrades,
      and pausing. Works with popular multi-sigs including Gnosis Safe.

  • Estimating gas price (Add to existing info):
    https://medium.com/@blockchain101/estimating-gas-in-ethereum-b89597748c3f

  • https://eips.ethereum.org/EIPS/eip-998
    ERC-721 extension to enable ERC721 tokens to own other ERC721 and ERC20 tokens.

  • TxTrie: Ethereum TX Ontology
    https://ethon.consensys.net/class-txtrie.html

  • Ways to reduce gas fees</span>  @ma
    https://www.makeuseof.com/ways-reduce-ethereum-gas-fees/


  • Inline Assembly [solidity,10_EVM,00_PM.TODO]
    https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#opcodes

  • YUL: language used for inline assembly.

  • assembly blocks share no namespace:
    Yul block can NOT read val/call func. in other block.

  Ex: access code in another contract and load it into a bytes variable.
      (similar to solidity 'contractXXXAddress.code')

  // ========================================
  // SPDX-License-Identifier: GPL-3.0
  pragma solidity >=0.4.16 <0.9.0;

  library GetCode {
    function at(address _addr) public view returns (bytes memory o_code) {
      assembly {
        let size := extcodesize(_addr) ← fetch code
        o_code := mload(0x40)          ← Solidity converion 0x40. Mem.pointer
        mstore(0x40,                   ←  Allocate new memory by updating it.
            add(o_code,                   convention) and update it.
                and(                      Reserved memory is random init (vs
                  add(                    (zero-init)
                    add(size, 0x20),      No built-in mechanism to free exists.
                    0x1f),                See Note *1
                  not(0x1f)
                )
            )
        )
        mstore(o_code, size)           // store length in memory
        extcodecopy(                   // retrieve code
            _addr,
            add(o_code, 0x20),
            0,
            size)
      }
    }
  }


  e.g.2:
      // NON-OPTIMAL solidity (array check at each iteration)
      for (uint i = 0; i < _data.length; ++i) { sum += _data[i]; }

      // OPTIMIZED INLINE ASSEMBLY
      function sumPureAsm(
                   uint[] memory _data)
      public
      pure
      returns (uint sum) {
        assembly {
            let len := mload(_data)       ← Load array length
            let data := add(_data, 0x20)  ← Skip length field.
            for                             0x20: uint byte-size
            {                             ← for-loop initialization
               let end := add(
                           data,
                           mul(len, 0x20 ))
            }
            lt(data, end)                 ← for-loop end-condition
            { data := add(data, 0x20  ) } ← for-loop post-end code?
            {                             ← for-loop body
              sum := add(sum, mload(data))
           I}
        }
      }
  
  Rules: Local solidity vars/value types  are directly read/write accesible.
         A single Yul identifier is not sufficient, since they do not
         necessarily occupy a single full storage slot. Their "address" is
         composed of ( slot, byte-offset (inside slot) ).
         x.slot  : retreive slot
         x.offset: retreive offset always zero for structs, arrays and mappings
         x       : error.

         .slot,.offset is read       for state variable.
                          read/write for local vars.

   HINT: for var less than 32 bytes clean them first. Ex.:
         uint32 x ...; int32 y = ...;
         assembly { x := and(x, 0xffffffff) }
         assembly { signextend("num_bytes_of_y_minus_one", y) }

  Function calls, loops, ifs and switches are converted by simple
  rewriting rules and after that, the only thing the assembler does for
  you is re-arranging functional-style opcodes, counting stack height
  for variable access and removing stack slots for assembly-local variables
  when the end of their block is reached.

  *1: Solidity memory convetions:
    1st 64 memory bytes [0,0x40] are "scratch space" (short-term alloc)
    [0x40,0x60) is the memory pointer.
    [0x60,0x80) are meant to be zero permanently and is used
                as initial value for empty dynamic memory arrays.
    [0x80,....) Start of allocatable memory (init value of 0x40 pointer)

   - Elements in memory arrays in Solidity always occupy multiples of
     32 bytes (0x20 bytes) even for bytes1[].
   - Multi-dimensional memory arrays are pointers to memory arrays.
     The length of a dynamic array is stored at the first slot of
     the array and followed by the array elements.
   - Statically-sized memory arrays do NOT have a length field, but it
     might be added later. Do NOT rely on this.

  • Proof of Auhority [consensus.PoA,00_PM.TODO]
  @[https://limechain.tech/blog/proof-of-authority-explained/]
    Proof of Authority is a variant of the Proof of Stake consensus
    mechanism where instead of tokens, network participants stake their
    identity and reputation. Proposed in 2015 by Ethereum’s co-founder
    Gavin Wood, Proof of Authority has in recent years become one of the
    more prominent consensus mechanisms, as the blockchain world has
    increasingly been exploring ways to move beyond Proof of Work.
    POA, OR AS IT IS ALSO KNOWN, PROOF OF STAKED AUTHORITY (POSA) IS SEEKING
    TO RESOLVE SOME OF THE ISSUES FOUND IN OTHER POW ALTERNATIVES, NAMELY
    PROOF-OF-STAKE.

  • ethereumjs-vm [_PM.backlog]
   @[https://github.com/ethereumjs/ethereumjs-vm]

  • https://blog.infura.io/ethereum-javascript-libraries-web3js-ethersjs-nov2021/ @ma

  • https://consensys.net/blog/metamask/how-to-bridge-tokens-from-ethereum-to-optimism-with-metamask/

  • https://ethereum.stackexchange.com/questions/710/how-can-i-verify-a-cryptographic-signature-that-was-produced-by-an-ethereum-addr

  • "promising" L2 projects!:
    - ORU (Ben Jones @ Optimism)
    - Arbitrum SCSC (Ed Felten @ Offchain Labs)
    - ZK rollup and Validium (Alex Gluchowski @ Matter Labs)

  • About ZK-Snarks:
    REF: @[https://medium.com/coinmonks/practical-zk-snarks-for-ethereum-140cbddcb55d]

  • https://notes.ethereum.org/@vbuterin/data_sharding_roadmap

  • Cosmos and Tendermint: [comparative,scalability.layer2,layer2.Cosmos,layer2.Tendermint,00_PM.TODO]
    Cosmos is also building an ecosystem that relies on the Tendermint consensus
    mechanism that relies heavily upon Byzantine Fault Tolerance algorithms. The
    platform depends on validators that have similar roles as miners in the
    bitcoin network. The validators have staking tokens called Atoms which are
    used to secure the network via a proof of stake mechanism that relies upon
    the trust generated by the bonded validators. The interplay between the
    players in the ecosystem is also indicative of a game theoretical structure
    where validators can lose their tokens or the tokens delegated to them if
    discovered to be violating the protocol. Due to this bonded deposit design of
    stakeholders within this system, the consensus mechanism allows for an
    incentivization mechanism that secures the network. This security design
    allows for the proper functioning of the Application Blockchain Interface
    (ABCI), the Inter-Blockchain Communication protocol (IBC) as well as the
    varying interactions between the Cosmos hub and zones.
    ....

 • Ethereum Smart Contracts in L2: Optimistic Rollup
   @[https://medium.com/plasma-group/ethereum-smart-contracts-in-l2-optimistic-rollup-2c1cef2ec537]
   This post outlines optimistic rollup:
   -  a construction which enables autonomous smart contracts on layer 2 (L2)
   using the OVM. The construction borrows heavily from both plasma and
   zkRollup designs, and builds on shadow chains as described
   by Vitalik.
    This construction resembles plasma but trades off some scalability
   to enable running fully general (eg. Solidity) smart contracts in layer 2,
   secured by layer 1. Scalability is proportional to the bandwidth of data
   availability oracles which include Eth1, Eth2, or even Bitcoin Cash or ETC —
   providing a near term scalable EVM-like chain in layer 2.

 • ProgPow: ASIC resistence: [security,00_PM.TODO]
 @[https://journalducoin.com/altcoins/ethereum-eth-bientot-resistant-aux-asic-grace-a-progpow/

 • Ethereum Data Service (EDS) [[{00_PM.RADAR}]]
   - features:
     - Insert/Update/Delete of packed type data (shallow object)
     - Insert/Update/Delete for Deep Objects,
       (EDO across contracts atomically) similarly to GraphQL inserts

                                                      ┌──────┐
                                                    ┌····→ o←···· Object component
                        ┌··· reference to another ··┘ │      │  + Object behaviour
                        ·    component                └──────┘
                       ┌v────┐         ┌──────┐        Object
       User   ←········-o←·┐o│         │o ⇄  o│       Contract 4
       ====            │  o└······←·┬··←┘     │
       Person/         └─────┘      ·  └──────┘
       Contract       Contract 1    ·  Contract 3
                                    ·
                                    ·  ┌──────┐
                                    └····o    │
                                       │      │
                                       └──────┘
                                       Contract 2
  - Decentralized maintenance of types
  - Data shortcuts (alias)
  - Important available types:
    - NFT
    - Geo POI (Point-of-Interest)
    - Various Type of Hashes
    - URL
    - IPFS Pointer
    - Pointer to other Data.


  • Running on kubernetes [implementation.quorum,infrastructure.cloud,devops.k8s,infrastructure.cloud,00_PM.TODO]
   @[https://github.com/majd1239/Quarum-Maker-Kubernetes]
   See also: https://github.com/synechron-finlabs/quorum-maker/issues/75

  • Code Coverage  @ma
    https://blog.colony.io/code-coverage-for-solidity-eecfa88668c2/

  • Property based testing:
    https://iamdefinitelyahuman.medium.com/effective-smart-contract-testing-property-based-testing-9e2a2b1fe77e

  • https://soliditydeveloper.com/multiswap-advanced

  • 2022-03-18: MetaMask now offer users improved gas experience,
    terms have been changed to accurately capture market conditions:
    - "Low" (previously "Low"): is much lower than market prices and it
    allows a user to pay a lower fee when they are willing to wait a
    longer time. It allows you to wait a longer period and skip the price
    spikes (i.e. save money). Note that this setting is based on past
    trends, which means we can never be sure the transaction goes
    through. If you require a transaction to go through, this may not be
    the right setting for you.
    - "Market" (previously "Medium"): reflects market prices.
    - "Aggressive" (previously "High"): is much higher compared to market
    prices. It allows you to set a really high max fee and priority fee
    to increase the likelihood of your transaction being successful if
    you're expecting to participate in a gas war.

    Find out more about these changes and EIP-1559 in general in the
    updated MetaMask hub.

 • https://eips.ethereum.org/EIPS/eip-1767 GraphQL interface to Ethereum node data

 • https://eips.ethereum.org/EIPS/eip-2200 [gas,storage]
   This EIP mostly achieves what a transient storage tries to do
   (EIP-1087 and EIP-1153), but without the complexity of introducing
   the concept of “dirty maps”, or an extra storage struct.

 • Add summary to Diamond's standard notes:
   https://github.com/aavegotchi/ghst-staking/tree/master/contracts/facets

 • ConsenSys accelerates the NFT experience by launching
   Infura NFT API and MetaMask Institutional NFT Portfolio
   https://consensys.net/blog/press-release/consensys-accelerates-the-nft-experience-by-launching-infura-nft-api-and-metamask-institutional-nft-portfolio-view-for-developers-and-organizations/

 • https://filecoin.io/blog/posts/introducing-the-filecoin-virtual-machine/ [storage]

 • https://github.com/securing/SCSVS/tree/prerelease/SCSVSv2  [qa,security]
   Smart Contract Security Verification Standard
   Authors
   Damian Rusinek @drdr_zz (damian.rusinek@securing.pl)
   Pawel Kuryowicz @wh01s7 (pawel.kurylowicz@securing.pl)

   - FREE checklist created to standardize the security of smart contracts for
     developers, architects, security reviewers and vendors.

   - This list helps to avoid the majority of known security problems
     and vulnerabilities by providing guidance at every stage of the
     development cycle of the smart contracts (from designing to
     implementation).

   Objectives:
   - Help to develop high quality code of the smart contracts.
   - Help to mitigate known vulnerabilities by design.
   - Provide a checklist for security reviewers.
   - Provide a clear and reliable assessment - Security Health Factor -
     of how secure smart contracts are in the relation to the percentage of SCSVS coverage.
   - Updates in v2
   - Security, Composability and Transparency are fundamentals of the
     SCSVS. These values are achieved thanks to the engagement and
     cooperation of the #BlockSec community. The standard structure
     distinguishes 3 chapters, each operating in a slightly different area.
   - General - common and general security problems including, among others, design,
     upgrades, policies.
   - Components - contracts that make up the project, frequently used patterns with
     their typical security issues.
   - Integrations - components with which the project integrates, general recommendations
     and threats to frequently used smart contracts.
[[}]]

[[{00_PM.BACKLOG]]
  • Aragon OS: Advanced deployment [[{dev_framework.aragon,02_use_case.finance.DAO,security.governance}]]
  @[https://aragon.one/]
  @[https://blog.aragon.one/advanced-solidity-code-deployment-techniques-dc032665f434]

  - Upgradeability: https://hack.aragon.org/docs/apm.html
     As a DAO, each aragonPM registry includes a number of installed applications,
    including one APMRegistry, one ENSSubdomainRegistrar, and many Repo instances.

  - @[https://hack.aragon.org/docs/aragonos-intro.html]
    aragonOS provides the following functionality:
    - DAO: Decentralized Autonomous Organization
    - Upgreadability:
    - Permission control: By using the auth() and authP() modifiers you can
      protect functionality such that they're only accessible by other apps or
      entities if given permission. This completely abstracts the authentication
      logic from an app, allowing you to focus on your app's business logic.
      Example: protecting a vault so only the organization's Voting app can
      initiate an action to transfer funds.
    - Forwarders: aragonOS apps can communicate with each other by sending their
      intent to perform an action to other apps. Example: withdrawing funds from
      a vault only on the passing of a vote and the expiring of a time-lock.
    - All the above makes it very simple for aragonOS apps to incorporate governance.
      You just need to add a voting app, configure permissions the right way, and
      away you go!
   - Aragon Apps: https://github.com/aragon/aragon-apps
     This repository contains the following apps:
      - Vault       : Securely owns and manages tokens on behalf of a DAO.
      - Finance     : Send payments and manage expenses with budgeting.
      - Voting      : Create votes that execute actions on behalf of token holders.
      - Token Manager: Manages organization tokens.
      -  Payroll    : Manages employees' payrolls.
   - Aragon Connect https://aragon.org/connect
     - toolkit for developers to seamlessly integrate
       DAO functionality into apps.
     - easy to use and blazing fast!

     - Ex 1: Obtain all the token holders (e.g. members) of a DAO
       const tokens = new TokenManager(await org.app({
         appName: 'tokens.aragonpm.eth'}))
       const tokenDetails = await tokens.token()
       const tokenHolders = await tokenDetails.holders()

     - Ex 2: Get all votes (past and ongoing) of a DAO:
       const voting = new Voting(await org.app({
         appName: 'voting.aragonpm.eth'}))
       const votes = await voting.votes()

     - Allow your user to vote on a proposal:
       const [path] = await org.appIntent(
           voting, 'vote', [votes[0].id, true, true] ).
           paths(wallet.account)
       for (const transaction of path.transactions) {
         await ethers.sendTransaction(transaction)
       }

 • GNOSIS Research: [[{wallet.multisignature,02_use_case.finance.prediction_markets,02_use_case.finance}]]
@[https://github.com/gnosis/research]
  CREATE—Prediction Markets
  - Whitepaper, ed. 22 Decmber 2017
  - Any-order condition resolution in conditional prediction markets
  - Apollo Prediction Market Framework Documentation

  TRADE—Trading Protocols
  - Batch Auction Optimization
  - Batch auctions with uniform clearing price on Plasma
  - Plasma SNAPP: Fully verified Plasma chain
  - Plasma Research
  - dFusion Specs
  - DutchX: Fully decentralized auction based exchange
  - DutchX Trading Protocol Documentation


  HOLD—Multi-sig Wallets:
  - Gnosis Safe Documentation
  - Gnosis Safe Formal Verification
  - Add wallet_ methods to improve dapp to wallet interaction
    "...  Interacting with smart contract based wallets is different to
      the interaction with EOA based wallets.   The biggest difference is
      that smart contract based wallets cannot generate ECDSA signatures.
      Also smart contract based wallets provide the possibility for a lot
      of extended functionality  ..."

 • Formal Verification for Eth2.0 (Beacon Chain)
   [[{20_QA.formal_verification,scalability.consensus.ethereum2}]]
   """ ...With my colleague Joanne Fuller, PhD at ConsenSys, we are
    delighted to have released the first version of the formal
    verification of the Eth2.0 (Beacon chain) specifications
    https://lnkd.in/gw4JFf7q. This project was partially funded by a
    grant from the Ethereum Foundation. ..."

  @[https://github.com/ConsenSys/eth2.0-dafnypre]
  @[https://cs.paperswithcode.com/paper/verification-of-the-incremental-merkle-tree]
    Verification of the Incremental Merkle Tree Algorithm with Dafny by Franck Cassez

   - Who-is-Who:
     https://franck44.github.io/
     https://www.youtube.com/watch?v=pxe4qGwGBGg
      The Deposit Smart Contract (DSC) is an instrumental component of the
     Ethereum 2.0 Phase 0 infrastructure. We have developed the first
     machine-checkable version of the incremental Merkle tree algorithm
     used in the DSC. We present our new and original correctness proof of
     the algorithm along with the Dafny machine-checkable version. The
     main results are: 1) a new proof of total correctness; 2) a software
     artefact with the proof in the form of the complete Dafny code base
     and 3) new provably correct optimisations of the algorithm.


 • NuCypher: Privacy Infrastructure for the Decentralized Web.
   [[{privacy.offchain,infrastructure.storage.offchain}]]
   @[https://www.nucypher.com/]
   - Cryptographic Infrastructure for Privacy-Preserving Applications
   - Alice has sensitive data that she wants to store and share.
   - Alice encrypts her data using her public key and uploads it to
     storage.
   - Alice delegates access to Bob. The data is rekeyed to Bob's key
     using proxy re-encryption
   - Bob downloads the data and decrypts it with his own private key.

   - Manage secrets such as IAM tokens, database and SSH credentials,
     X.509 certificates, and signing/encryption keys across dynamic
     environments.
    Proxy Re-encryption (PRE)
     NuCypher's PRE network provides cryptographic access controls for
     distributed apps and protocols.

    Fully Homomorphic Encryption (FHE)
     NuCypher's NuFHE library enables secure, private computation on
     encrypted data by outsourced nodes.

   - See also:
   @[https://blog.nucypher.com/numerology-fast-ecc-arithmetic-on-chain-5eb438a735d4]

 • DeepSea: [[{20_QA.formal_verification}]]
  @[https://certik.org/deepsea_blockchain.html]
   Research at Yale and Columbia to further their work on DeepSEA,
   a formally verified language that compiles to the EVM.

 • SandCastle_SQL [[{persistence.data_structure,20_QA.solidity,12_solidity.persistence,01_doc_has.diagram}]]
  @[https://pegasys.tech/sandcastle-brings-sql-to-ethereum-smart-contracts/]
    WARN : Doesn't look to be continued.

  @[https://twitter.com/shahankhatch/status/1129427879262138369]
  |SQL| → |compiler| → |AST|  → |scopes    | → |code     | → |Solidity|
               ^                |validation|   |generator|
         ┌─────┴─────┐
         │           │
       |lexer|    |parser|
         ^           ^
         └─────┬─────┘
               │
       |parser-generator|

 • Optimistic VM (OVM) [[{layer2.*,layer2.OptimisticVM,layer2.rollup.optimistic,scalability.layer2}]]
@[https://medium.com/plasma-group/introducing-the-ovm-db253287af50]
  - VM designed to support all layer 2 (L2) protocols.
    It generality comes from a reframing of L2 as an "optimistic" fork
    choice rule layered on top of Ethereum.
  -  The formalization borrows heavily from CBC Casper research , and
    describes layer 2 as a direct extension to layer 1 consensus. This implies a
    possible unification of all “layer 2 scalability” constructions (Lightning,
    Plasma, etc) under a single theory and virtual machine: the OVM.


• Quorum-Maker: [[{devops,00_PM.low_code}]]
@[https://github.com/synechron-finlabs/quorum-maker]
•  WARN:  Abandoned project. Hyperledger Bevel (by Accenture) looks to replace it.

  - wizard-like: bootstrap Quorum network of any number of
    nodes of various configurations dynamically with
    reduced user input running on containers or Linux boxes.
  - INSTALL PRE-REQUISITES)
    ✓ docker-CE ("Long Term Support")
  - INSTALL)
      $ git clone https://github.com/synechron-finlabs/quorum-maker
  - USSAGE)
      $ ./setup.sh --help

    join      Create a node and Join to existing Network
             --oip     IP address of the other(existing) node
             --onm     Node Manager port of the other node
             --tip     IP address of this node (IP of the host machine)
             --whisper Discovery port of this node

    attach    Attach to existing Quorum Node ..
              --ip      IP address of existing Quorum
              --pk      Public Key of existing Constellation
              --whisper Discovery port of this node
              --active  Active attachment mode
              --passive Passive attachment mode

    create    Options:
              --ip        IP address of this node (IP of the host machine)
              --rpc       RPC port of this node
              --whisper   Discovery port of this node

    dev       (Create dev network)
              --project   Project Name
              --nodecount Number of nodes to be created
              --expose    Expose docker container ports (Optional)
              --tessera   Create node with Tessera Support (Optional)

    Common Options:
      --name    Name of the node to be created
      --constellation     Constellation port of this node
      --raft    Raft port of this node
      --nm      Node Manager port of this node
      --ws      Web Socket port of this node
      --tessera Create node with Tessera Support (Optional)
     --rpc     RPC port of this node

    $ ./setup.sh create -n master \
    $   --ip 10.0.2.15 -r 22000 -w 22001 \
    $   -c 22002 --raft 22003 --nm 22004 \
    $   --ws 22005

    $ ./setup.sh join -n slave1 --oip 10.0.2.15   \
    $  --onm 22004 --tip 10.0.2.15 -r 23000 -w 23001\
    $  -c 23002 --raft 23003 --nm 23004 --ws 23005


    $ ./setup.sh attach -n slave1 --ip 10.0.2.15  \
    $  --pk BULe... -r 22000 --whisper 21000        \
    $  --constellation 9001 --raft 50401 --nm 11004 \
    $  --active

    $ ./setup.sh dev -p TestNetwork -n 3

  • Gemalto HSM [[{wallet.hsm,security}]]
    @[https://safenet.gemalto.com/data-encryption/hardware-security-modules-hsms/protectserver-security-module/]
    - Supports SECP256K1 , required by Ethereum

 • Parity
   - External Links:
   @[https://parity.io/parity.html]
   @[https://github.com/paritytech/parity]
   @[https://github.com/paritytech/parity/wiki/Coding-guide]
   @[https://github.com/paritytech/parity/wiki]

   - features:
     "full" Ethereum Wallet and Dapp environment with web-front-end ("http://127.0.0.1:8180"):
     - Account, address-book and multi-sig management
     - Key creation, importing and exporting
     - Web3 Ðapp browser
     - Hardware and electronic cold-wallet support
     - Name registry support
   - Parity Substrate:
     -  Designed to build custom blockchains for enterprises
        - Right privacy level for each use case
        - Light- client- first design for mobile applications and IoT
        - Forkless upgrade path to keep networks together
        - Multi-level permissioning
        - Encrypted transactions and state
        - Limiting to asynchronous calls optionality
        - Account-level locking
        - Governance tools and methods such as stakeholder referendums,
          approval voting, and qualified abstention biasing
     - Architected on industry-standard WebAssembly  smart contracts
     - Highly extensible Libp2p networking
     - Rust-based primary implementation for speed and reliability
     - Javascript secondary implementation for developability

 • Deth (Ganache alt)
@[https://github.com/ethereum-ts/deth]
  -  RPC support
  -  state snapshots (evm_snapshot), time manipulation (evm_increaseTime),
     mining control (evm_mine)
  -  print out decoded logs and calldata for all transactions
     (even reverted ones!)
  -  display revert reasons
  -  built-in blockchain explorer
  -  ignore nonce errors(perfect while working with Metamask fox_face)
  -  much faster (60%) than Ganache

 • The Matter (500 TX/s) (Ethereum 2019 Grant) [[{scalability.zkp,00_PM.radar}]]
   - @[https://thematter.io/]
   - Productionising ‘Plasma Ignis’ code, a SNARK-driven “roll up” that can
     support up to 500 transactions per second.

 • verifiable delay functions [[{101,scalability.consensus.ethereum2,consensus.PoS,00_PM.radar}]]
  - core building block for proof stake block chains and
    secure lotteries.

 • Bulletproofs: short of non-interactive zero-knowledge proofs that [[{privacy.zkp,00_PM.radar}]]
   require no trusted setup. A bulletproof can be used to convince a
   verifier that an encrypted plaintext is well formed. For example,
   prove that an encrypted number is in a given range, without revealing
   anything else about the number. Compared to SNARKs, Bulletproofs
   require no trusted setup. However, verifying a bulletproof is more
   time consuming than verifying a SNARK proof.
   - used to secure cryptocurrencies like Monero, Mimblewimble
     and others and is used in enterprise blockchains like JP
     Morgan's quorum.

 • SuperSonic: zSNARK trustless setup: [[{privacy.zkp,scalability.zkp,00_PM.radar}]]
   - Ben Fisch, Benedikt, and Alan Szepeniec also recently introduced
     SuperSonic, the first fully practical zero-knowledge SNARK that
     doesn't require a trusted setup.

    - ... guest speaker Brecht Devos of Loopring for a presentation and
      Q+A about scaling with ZKPs and Loopring.

 • Homomorphic Hashing: [[{security,00_PM.radar}]]
 @[http://blog.notdot.net/2012/08/Damn-Cool-Algorithms-Homomorphic-Hashing]

 • Status: Wallet and IM https://status.im/ [[{wallet.mobile,00_PM.radar}]]
 @[https://github.com/status-im/status-react]
  - currently (20??-??) in alpha:
  - can be tested on Android and iPhone.
  - Status is a mobile messenger, crypto wallet, and Web3 browser.
  - peer-to-peer protocol that doesn't rely on centralized servers.

  @[https://ethereum.stackexchange.com/questions/18461/how-can-dapps-work-on-smartphones]
    - Download Status on your phone
    - configure an account
    - Install
      $ npm i -g status-dev-cli
    - In status console, enter /debug.
      That will give you your device IP address {DEVICE_IP}
    - From your machine, make sure you can see you device and status:
      status-dev-cli scan (status must be running)
    - Last step, consist in registering the dapp in status:
      status-dev-cli add
         "{\"whisper-identity\": \"my-dapp\", \"dapp-url\": \"{DAPP_URL}\", \"name\": \"MyDAPP\"}" --ip {DEVICE_IP}

 • Augur Prediction Markets (Research project) [[{02_use_case.finance.prediction_markets,00_PM.radar}]]
 @[https://www.augur.net/]
  Markets for Anyone Anywhere on Anything
 - politics and elections prediction markets
 - sport and football prediction markets
 - crypto and bitcoin prediction markets
 - prediction markets on anything
 - ...

• Zero Know. Range Pro. (ZKRP): [[{privacy.ZKP,02_use_case.*,00_PM.radar}]]
@[https://github.com/ing-bank/zkrp]
 - ING Bank:
   ...Launched in 2017, zero-knowledge range proof (ZKRP) enabled numerical
   data to be validated within a number range. For example, a mortgage
   applicant could prove that their salary sits within a certain range
   without revealing the exact figure. A year later, ING took the
   solution a step further and introduced ZKSM, which goes beyond
   numerical data to include other types of information, like locations
   and names. This made the new code, ZKSM, more powerful. For instance,
   banks could validate that a new client lives in a country that
   belongs to the European Union, without revealing the country. Simply
   put, this allows for information to be shared without revealing
   contextual details.

   Following a trend now widely adopted in the industry Bulletproofs
   code is open-source, which means that other interested parties in the
   development community are able to use, access and even contribute to
   the solution.

 • Piet: parses *.sol, generates graphs of contracts and their relations [[{12_solidity,20_QA.solidity}]]
   (inheritance structure,...).
   @[https://blog.slock.it/analyzing-solidity-smart-contracts-with-piet-6db33a733e79]
   @[https://github.com/slockit/piet]
   @[https://piet.slock.it/?container=examples%2Fexport1562664060589.piet.json]

   - Web GUI to read the state, send transactions, or list events
   - create smart contract documentation from NatSpec annotations.
   - support for Solidity source files, Truffle build files, piet
     container files and GitHub repositories.
   - Can use web3 injected objects ("MetaMask") to interact with a live blockchain.

     Warning: Piet has not yet undergone in-depth testing and may contain serious bugs.

  • EWASM: [[{scalability.ewasm}]]
  @[https://ewasm.readthedocs.io/en/mkdocs/]
  Ethereum WebAssembly is a proposed redesign of the Ethereum smart
  contract execution layer using a deterministic subset of WebAssembly.
  The use of WebAssembly as a format for smart contracts gains a
  variety of benefits, a few of which are listed below:
  - Near-native execution speed for smart contracts
  - The possibility to develop smart contracts in many traditional
    programming languages, such as C, C++, and Rust
  - Access to a vast developer community and the toolchain surrounding WebAssembly

 • Flattening code [[{12_solidity}]]
@[https://stackoverflow.com/questions/50137954/verify-smart-contract-code-deployed-with-truffle]
- https://github.com/BlockCatIO/solidity-flattener
- https://github.com/nomiclabs/buidler
- https://github.com/nomiclabs/truffle-flattener
- https://github.com/RyuuGan/sol-merger

 • QA Mythril: detects integer underflows, owner-overwrite-to-Ether-withdrawal, ...  [[{12_solidity.qa,security,00_PM.backlog}]]
  - https://github.com/ConsenSys/mythril-classic
  - Swiss army knife for smart contract security.
  - @[https://github.com/ConsenSys/mythril/wiki]
  - However, the analysis will NOT detect business
    logic issues.
  - It is NOT equivalent to formal verification.

 • Security Best Practices [[{101,security,12_solidity.qa}]]
  @[https://consensys.github.io/smart-contract-best-practices/]

 • Example ussage of msg.data: Imagine we pass 2xuint256 as msg.data:
    To use them:
      function sum() ... {
        uint256 op1;
        uint256 op2;
        uint256 result;
        bytes memory data = msg.data;
        assembly {
            op1 := mload(add(data, 36)) <- 36 (not 32) because First 4 bytes of
            op2 := mload(add(data, 68))     the msg.data is the func.selector data.
            result  := add(op1, op2)
        }
     }


 • library of standards for security tokens ("Obligation to pay") on Ethereum. @ma
   suite of standard interfaces for:
   - issuing / redeeming security tokens
   - managing ownership and transfer restrictions.
   - providing transparency on how different subsets
     of their token balance behave with respect to
     transfer restrictions, rights and obligations.
   - Standards should be backwards compatible with ERC-20 (#20).
   - Depends on:
     - ERC-1410: differentiated ownership / transparent restrictions
     - ERC-1594:  on-chain restriction checking with error-signalling.
                 off-chain data injection for transfer restrictions and
                 issuance / redemption semantics
     - ERC-1643: document / legend management
     - ERC-1644: controller operations (force transfer)

 • https://docs.openzeppelin.com/contracts/2.x/api/cryptography#MerkleProof
   verify(bytes32[] proof, bytes32 root, bytes32 leaf) -> bool

   Returns true if leaf can be proved to be a part of a Merkle tree
   defined by root when supplied with a proof.
   proof = sibling hashes in branch from leaf-to-root.
           Each pair of leaves and each pair of pre-images
           are assumed to be sorted.

  • Awesome Solidity Libraries:
    @[https://github.com/bkrem/awesome-solidity#libraries]

  • @[https://kauri.io/article/766e5d1e1ba240a7976943b659a871fc/v1/a-deep-dive-into-the-ethereum-virtual-machine-(evm)-part-2:-memory-and-storage]

  • Awesome EVM list:
   @[https://github.com/pirapira/awesome-ethereum-virtual-machine]

  • truffle: run multiline scripts.
    https://ethereum.stackexchange.com/questions/36549/how-to-run-a-multiline-script-in-truffle-console
    STEP 1)  Write script to 'myScript.js' file.
    STEP 2)  Use require or exec like:
             truffle(dev)> require ('./myScript.js')  ← alt 1:
           truffle(dev)> exec  './myScript.js'      ← alt 2:

 • solc generates two related outputs:
   - bytecode        : wrapper code necessary to init+deploy the contract
   - deployedBytecode: deployed code (with no extra init code)


 • TextUI (Console Prototyping): [[{dev_framework.python.TextUI,00_PM.low_code]]
  @[https://github.com/kayagoban/shadowlands]
  - rapid prototyping platform for Eth apps which breaks the paradigm
    that everything must be a web app.
  - Suppports: Trezor Harwdware Wallet, ... [[}]]

 • Zokrates [[{privacy.ZKP]]
   @[https://zokrates.github.io/print.html]
   @[https://www.youtube.com/watch?v=YymE69JcKEk] [Video]
   - Convert zSNARKS "algebra" circuits to Solidity verifier code.
   - Clients can send "proofs" to be verified by the Solidity code that will
     ultimately continue/rollback any TX.  [[}]]

• Whisper Dapp Protocol: [[{privacy.offchain,architecture,scalability.offchain]]
  @[https://github.com/ethereum/wiki/wiki/Whisper]
  - communication protocol to communicate DApps with each other for off-chain Data.

   USE CASE:
  - DApps that need to publish small amounts of information to each other and
    have the publication last some substantial amount of time. For example, a
    currency exchange DApp may use it to record an offer to sell some currency at
    a particular rate on an exchange. In this case, it may last anything between
    tens of minutes and days. The offer wouldn't be binding, merely a hint to get
    a potential deal started.

     DApps that need to signal to each other in order to ultimately
    collaborate on a transaction. For example, a currency exchange DApp may use
    it to coordinate an offer prior to creating one (or two, depending on how the
    exchange is structured) transactions on the exchange.

     DApps that need to provide non-real-time hinting or general
    communications between each other. E.g. a small chat-room app.

     DApps that need to provide dark (plausible denial over perfect network
    traffic analysis) comms to two correspondents that know nothing of each other
    but a hash. This could be a DApp for a whistleblower to communicate to a
    known journalist exchange some small amount of verifiable material and
    arrange between themselves for some other protocol (Swarm, perhaps) to handle
    the bulk transfer.

  *geth experimental flags related to whisper:
    --shh                       Enable Whisper
    --shh.maxmessagesize value  Max message size accepted (default: 1048576)
    --shh.pow value             Minimum POW accepted (default: 0.2)


  - Whisper Alternative: "Message Contract" and "Telehash"
[[}]]

• EtherQuery [[{integration.data,scalability.offchain,00_PM.TODO,00_PM.low_code]]
@[https://github.com/Arachnid/etherquery]
Custom ethereum client that uploads blockchain data to BigQuery
[[}]]


• AWS Lambda -> Eth.RPC
[[{devops,infrastructure.cloud.aws,infrastructure.cloud]]
@[https://blogs.sequoiainc.com/blockchain-dev-part-2-ethereum-rpc-from-aws-lambda/]
  how to interact with that node via RPC using an AWS Lambda function. This
  enables DApp development to leverage benefits of "serverless" software
  architecture while still maintaining the isolation and security of our original
  architecture.  [[}]]

  • Kaleido.io SaaS Ethereum/Quorum in AWS, Azure, ...  [[{00_PM.low_code,integration]]
  @[https://kaleido.io/]:
  - Marketplace: @[https://marketplace.kaleido.io/]
    - Salesforce Integration    :
    - APP+INTEGRATION GATEWAY   :
    - PUBLIC ETHEREUM TETHER    : Pin state proofs from your private chain to public Ether. networks
    - ETHER POOL                : Enable token economy use-cases without developing your own token
    - BLOCK EXPLORER            : Get more insights through real-time+historical snapshots of your blockchain
    - IDENTITY REGISTRY         : Bind verified digital certificates to org Ether. addresses via on-chain registry
    - IPFS FILE STORE           : Securely store data through a censorship resistant file sharing protocol
    - IDENTITY MASKING HD WALLET: Submit TXs anonymously, mask your identity+manage accounts [[privacy]]
   [[}]]

 • Data structure in Ethereum:
   https://medium.com/coinmonks/data-structure-in-ethereum-episode-4-diving-by-examples-f6a4cbd8c329

 • Geth v1.9.0 ships a preliminary integration of Blockscout     @ma
   into Puppeth.  Blockscout is a real, open source block explorer, 
   courtesy of "POA Network team" filling a huge hole in our private
   network deployment tool!
   https://docs.blockscout.com/
   OOSS Elixir application that allows users to:
   - search transactions.
   - view accounts and balances.
   - VERIFY SMART CONTRACTS ON ETHEREUM INCLUDING FORKS AND SIDECHAINS.

 • https://eips.ethereum.org/EIPS/eip-2315 [[{10_EVM]]
   Simple Subroutines for the EVM (Already implemented in Quorum 21, Geth?, others?)
   - two new opcodes: RJUMPSUB and RETURNSUB.
     together with other recent propoposals they provides 
     A STATIC, COMPLETE, SAFE, AND EFFICIENT CONTROL-FLOW FACILITY.
   - Previously calls (RJUMSUB) were synthesized by fetching-and-pushing the
     return-address and subroutine-address on the data-stack and
     executing a JUMP to the subroutine.
      "Returns" were synthesized by moving return-address to stack-top,
     then and jumping back to it, causing cost gas and increasing program size. [[}]]

 • EIP-173: Contract Ownership Standard    [[{standards.eip/erc.191,security.governance]]
   https://eips.ethereum.org/EIPS/eip-173 
   - function transferOwnership(address _newOwner) external;	
     └ event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
   - function owner() view external returns(address);
   [[}]]
[[}]]
